var dataJson = {"arch":{"ispc":false,"isunix":true,"ismac":false},"build":"MARS","ref":false,"files":[{"name":"MARS.c","type":"source","group":"model","path":"/home/aman/GitHub/flightTestingLab/controls/Ingenuity_Modelling/MATLAB-env/MARS_grt_rtw","tag":"","groupDisplay":"Model files","code":"/*\n * MARS.c\n *\n * Academic License - for use in teaching, academic research, and meeting\n * course requirements at degree granting institutions only.  Not for\n * government, commercial, or other organizational use.\n *\n * Code generation for model \"MARS\".\n *\n * Model version              : 1.28\n * Simulink Coder version : 9.7 (R2022a) 13-Nov-2021\n * C source code generated on : Fri Oct 28 08:09:17 2022\n *\n * Target selection: grt.tlc\n * Note: GRT includes extra infrastructure and instrumentation for prototyping\n * Embedded hardware selection: Intel->x86-64 (Windows64)\n * Code generation objective: Execution efficiency\n * Validation result: Not run\n */\n\n#include \"MARS.h\"\n#include \"rtwtypes.h\"\n#include \"MARS_private.h\"\n#include \"rt_assert.h\"\n#include <math.h>\n#include \"rt_nonfinite.h\"\n#include <emmintrin.h>\n#include <string.h>\n#include \"rt_defines.h\"\n#include <float.h>\n\n/* Block signals (default storage) */\nB_MARS_T MARS_B;\n\n/* Continuous states */\nX_MARS_T MARS_X;\n\n/* Block states (default storage) */\nDW_MARS_T MARS_DW;\n\n/* Real-time model */\nstatic RT_MODEL_MARS_T MARS_M_;\nRT_MODEL_MARS_T *const MARS_M = &MARS_M_;\nstatic void rate_scheduler(void);\n\n/*\n *         This function updates active task flag for each subrate.\n *         The function is called at model base rate, hence the\n *         generated code self-manages all its subrates.\n */\nstatic void rate_scheduler(void)\n{\n  /* Compute which subrates run during the next base time step.  Subrates\n   * are an integer multiple of the base rate counter.  Therefore, the subtask\n   * counter is reset when it reaches its limit (zero means run).\n   */\n  (MARS_M->Timing.TaskCounters.TID[2])++;\n  if ((MARS_M->Timing.TaskCounters.TID[2]) > 5) {/* Sample time: [0.1s, 0.0s] */\n    MARS_M->Timing.TaskCounters.TID[2] = 0;\n  }\n}\n\n/*\n * This function updates continuous states using the ODE3 fixed-step\n * solver algorithm\n */\nstatic void rt_ertODEUpdateContinuousStates(RTWSolverInfo *si )\n{\n  /* Solver Matrices */\n  static const real_T rt_ODE3_A[3] = {\n    1.0/2.0, 3.0/4.0, 1.0\n  };\n\n  static const real_T rt_ODE3_B[3][3] = {\n    { 1.0/2.0, 0.0, 0.0 },\n\n    { 0.0, 3.0/4.0, 0.0 },\n\n    { 2.0/9.0, 1.0/3.0, 4.0/9.0 }\n  };\n\n  time_T t = rtsiGetT(si);\n  time_T tnew = rtsiGetSolverStopTime(si);\n  time_T h = rtsiGetStepSize(si);\n  real_T *x = rtsiGetContStates(si);\n  ODE3_IntgData *id = (ODE3_IntgData *)rtsiGetSolverData(si);\n  real_T *y = id->y;\n  real_T *f0 = id->f[0];\n  real_T *f1 = id->f[1];\n  real_T *f2 = id->f[2];\n  real_T hB[3];\n  int_T i;\n  int_T nXc = 19;\n  rtsiSetSimTimeStep(si,MINOR_TIME_STEP);\n\n  /* Save the state values at time t in y, we'll use x as ynew. */\n  (void) memcpy(y, x,\n                (uint_T)nXc*sizeof(real_T));\n\n  /* Assumes that rtsiSetT and ModelOutputs are up-to-date */\n  /* f0 = f(t,y) */\n  rtsiSetdX(si, f0);\n  MARS_derivatives();\n\n  /* f(:,2) = feval(odefile, t + hA(1), y + f*hB(:,1), args(:)(*)); */\n  hB[0] = h * rt_ODE3_B[0][0];\n  for (i = 0; i < nXc; i++) {\n    x[i] = y[i] + (f0[i]*hB[0]);\n  }\n\n  rtsiSetT(si, t + h*rt_ODE3_A[0]);\n  rtsiSetdX(si, f1);\n  MARS_step();\n  MARS_derivatives();\n\n  /* f(:,3) = feval(odefile, t + hA(2), y + f*hB(:,2), args(:)(*)); */\n  for (i = 0; i <= 1; i++) {\n    hB[i] = h * rt_ODE3_B[1][i];\n  }\n\n  for (i = 0; i < nXc; i++) {\n    x[i] = y[i] + (f0[i]*hB[0] + f1[i]*hB[1]);\n  }\n\n  rtsiSetT(si, t + h*rt_ODE3_A[1]);\n  rtsiSetdX(si, f2);\n  MARS_step();\n  MARS_derivatives();\n\n  /* tnew = t + hA(3);\n     ynew = y + f*hB(:,3); */\n  for (i = 0; i <= 2; i++) {\n    hB[i] = h * rt_ODE3_B[2][i];\n  }\n\n  for (i = 0; i < nXc; i++) {\n    x[i] = y[i] + (f0[i]*hB[0] + f1[i]*hB[1] + f2[i]*hB[2]);\n  }\n\n  rtsiSetT(si, tnew);\n  rtsiSetSimTimeStep(si,MAJOR_TIME_STEP);\n}\n\n/*\n * Output and update for action system:\n *    '<S108>/If Action Subsystem2'\n *    '<S104>/If Action Subsystem2'\n */\nvoid MARS_IfActionSubsystem2(real_T rtu_In, real_T *rty_OutOrig)\n{\n  /* SignalConversion generated from: '<S111>/In' */\n  *rty_OutOrig = rtu_In;\n}\n\n/*\n * Output and update for action system:\n *    '<S112>/If Not Proper'\n *    '<S150>/If Not Proper'\n */\nvoid MARS_IfNotProper(real_T rtp_action)\n{\n  /* If: '<S114>/If' incorporates:\n   *  Constant: '<S114>/Constant'\n   */\n  if (rtp_action == 2.0) {\n    /* Outputs for IfAction SubSystem: '<S114>/Warning' incorporates:\n     *  ActionPort: '<S120>/Action Port'\n     */\n    /* Assertion: '<S120>/Assertion' incorporates:\n     *  Constant: '<S114>/Constant1'\n     */\n    utAssert(false);\n\n    /* End of Outputs for SubSystem: '<S114>/Warning' */\n  } else if (rtp_action == 3.0) {\n    /* Outputs for IfAction SubSystem: '<S114>/Error' incorporates:\n     *  ActionPort: '<S119>/Action Port'\n     */\n    /* Assertion: '<S119>/Assertion' incorporates:\n     *  Constant: '<S114>/Constant1'\n     */\n    utAssert(false);\n\n    /* End of Outputs for SubSystem: '<S114>/Error' */\n  }\n\n  /* End of If: '<S114>/If' */\n}\n\n/*\n * Output and update for action system:\n *    '<S112>/Else If Not Orthogonal'\n *    '<S150>/Else If Not Orthogonal'\n */\nvoid MARS_ElseIfNotOrthogonal(real_T rtp_action)\n{\n  /* If: '<S113>/If' incorporates:\n   *  Constant: '<S113>/Constant'\n   */\n  if (rtp_action == 2.0) {\n    /* Outputs for IfAction SubSystem: '<S113>/Warning' incorporates:\n     *  ActionPort: '<S118>/Action Port'\n     */\n    /* Assertion: '<S118>/Assertion' incorporates:\n     *  Constant: '<S113>/Constant1'\n     */\n    utAssert(false);\n\n    /* End of Outputs for SubSystem: '<S113>/Warning' */\n  } else if (rtp_action == 3.0) {\n    /* Outputs for IfAction SubSystem: '<S113>/Error' incorporates:\n     *  ActionPort: '<S117>/Action Port'\n     */\n    /* Assertion: '<S117>/Assertion' incorporates:\n     *  Constant: '<S113>/Constant1'\n     */\n    utAssert(false);\n\n    /* End of Outputs for SubSystem: '<S113>/Error' */\n  }\n\n  /* End of If: '<S113>/If' */\n}\n\nreal_T rt_urand_Upu32_Yd_f_pw_snf(uint32_T *u)\n{\n  uint32_T hi;\n  uint32_T lo;\n\n  /* Uniform random number generator (random number between 0 and 1)\n\n     #define IA      16807                      magic multiplier = 7^5\n     #define IM      2147483647                 modulus = 2^31-1\n     #define IQ      127773                     IM div IA\n     #define IR      2836                       IM modulo IA\n     #define S       4.656612875245797e-10      reciprocal of 2^31-1\n     test = IA * (seed % IQ) - IR * (seed/IQ)\n     seed = test < 0 ? (test + IM) : test\n     return (seed*S)\n   */\n  lo = *u % 127773U * 16807U;\n  hi = *u / 127773U * 2836U;\n  if (lo < hi) {\n    *u = 2147483647U - (hi - lo);\n  } else {\n    *u = lo - hi;\n  }\n\n  return (real_T)*u * 4.6566128752457969E-10;\n}\n\nreal_T rt_nrand_Upu32_Yd_f_pw_snf(uint32_T *u)\n{\n  real_T si;\n  real_T sr;\n  real_T y;\n\n  /* Normal (Gaussian) random number generator */\n  do {\n    sr = 2.0 * rt_urand_Upu32_Yd_f_pw_snf(u) - 1.0;\n    si = 2.0 * rt_urand_Upu32_Yd_f_pw_snf(u) - 1.0;\n    si = sr * sr + si * si;\n  } while (si > 1.0);\n\n  y = sqrt(-2.0 * log(si) / si) * sr;\n  return y;\n}\n\nreal_T rt_atan2d_snf(real_T u0, real_T u1)\n{\n  real_T y;\n  if (rtIsNaN(u0) || rtIsNaN(u1)) {\n    y = (rtNaN);\n  } else if (rtIsInf(u0) && rtIsInf(u1)) {\n    int32_T u0_0;\n    int32_T u1_0;\n    if (u0 > 0.0) {\n      u0_0 = 1;\n    } else {\n      u0_0 = -1;\n    }\n\n    if (u1 > 0.0) {\n      u1_0 = 1;\n    } else {\n      u1_0 = -1;\n    }\n\n    y = atan2(u0_0, u1_0);\n  } else if (u1 == 0.0) {\n    if (u0 > 0.0) {\n      y = RT_PI / 2.0;\n    } else if (u0 < 0.0) {\n      y = -(RT_PI / 2.0);\n    } else {\n      y = 0.0;\n    }\n  } else {\n    y = atan2(u0, u1);\n  }\n\n  return y;\n}\n\nreal_T rt_modd_snf(real_T u0, real_T u1)\n{\n  real_T y;\n  y = u0;\n  if (u1 == 0.0) {\n    if (u0 == 0.0) {\n      y = u1;\n    }\n  } else if (rtIsNaN(u0) || rtIsNaN(u1) || rtIsInf(u0)) {\n    y = (rtNaN);\n  } else if (u0 == 0.0) {\n    y = 0.0 / u1;\n  } else if (rtIsInf(u1)) {\n    if ((u1 < 0.0) != (u0 < 0.0)) {\n      y = u1;\n    }\n  } else {\n    boolean_T yEq;\n    y = fmod(u0, u1);\n    yEq = (y == 0.0);\n    if ((!yEq) && (u1 > floor(u1))) {\n      real_T q;\n      q = fabs(u0 / u1);\n      yEq = !(fabs(q - floor(q + 0.5)) > DBL_EPSILON * q);\n    }\n\n    if (yEq) {\n      y = u1 * 0.0;\n    } else if ((u0 < 0.0) != (u1 < 0.0)) {\n      y += u1;\n    }\n  }\n\n  return y;\n}\n\nreal_T rt_remd_snf(real_T u0, real_T u1)\n{\n  real_T y;\n  if (rtIsNaN(u0) || rtIsNaN(u1) || rtIsInf(u0)) {\n    y = (rtNaN);\n  } else if (rtIsInf(u1)) {\n    y = u0;\n  } else if ((u1 != 0.0) && (u1 != trunc(u1))) {\n    real_T q;\n    q = fabs(u0 / u1);\n    if (!(fabs(q - floor(q + 0.5)) > DBL_EPSILON * q)) {\n      y = 0.0 * u0;\n    } else {\n      y = fmod(u0, u1);\n    }\n  } else {\n    y = fmod(u0, u1);\n  }\n\n  return y;\n}\n\nreal_T rt_powd_snf(real_T u0, real_T u1)\n{\n  real_T y;\n  if (rtIsNaN(u0) || rtIsNaN(u1)) {\n    y = (rtNaN);\n  } else {\n    real_T tmp;\n    real_T tmp_0;\n    tmp = fabs(u0);\n    tmp_0 = fabs(u1);\n    if (rtIsInf(u1)) {\n      if (tmp == 1.0) {\n        y = 1.0;\n      } else if (tmp > 1.0) {\n        if (u1 > 0.0) {\n          y = (rtInf);\n        } else {\n          y = 0.0;\n        }\n      } else if (u1 > 0.0) {\n        y = 0.0;\n      } else {\n        y = (rtInf);\n      }\n    } else if (tmp_0 == 0.0) {\n      y = 1.0;\n    } else if (tmp_0 == 1.0) {\n      if (u1 > 0.0) {\n        y = u0;\n      } else {\n        y = 1.0 / u0;\n      }\n    } else if (u1 == 2.0) {\n      y = u0 * u0;\n    } else if ((u1 == 0.5) && (u0 >= 0.0)) {\n      y = sqrt(u0);\n    } else if ((u0 < 0.0) && (u1 > floor(u1))) {\n      y = (rtNaN);\n    } else {\n      y = pow(u0, u1);\n    }\n  }\n\n  return y;\n}\n\nvoid rt_mrdivide_U1d1x3_U2d_9vOrDY9Z(const real_T u0[3], const real_T u1[9],\n  real_T y[3])\n{\n  real_T A[9];\n  real_T a21;\n  real_T maxval;\n  int32_T r1;\n  int32_T r2;\n  int32_T r3;\n  memcpy(&A[0], &u1[0], 9U * sizeof(real_T));\n  r1 = 0;\n  r2 = 1;\n  r3 = 2;\n  maxval = fabs(u1[0]);\n  a21 = fabs(u1[1]);\n  if (a21 > maxval) {\n    maxval = a21;\n    r1 = 1;\n    r2 = 0;\n  }\n\n  if (fabs(u1[2]) > maxval) {\n    r1 = 2;\n    r2 = 1;\n    r3 = 0;\n  }\n\n  A[r2] = u1[r2] / u1[r1];\n  A[r3] /= A[r1];\n  A[r2 + 3] -= A[r1 + 3] * A[r2];\n  A[r3 + 3] -= A[r1 + 3] * A[r3];\n  A[r2 + 6] -= A[r1 + 6] * A[r2];\n  A[r3 + 6] -= A[r1 + 6] * A[r3];\n  if (fabs(A[r3 + 3]) > fabs(A[r2 + 3])) {\n    int32_T rtemp;\n    rtemp = r2 + 1;\n    r2 = r3;\n    r3 = rtemp - 1;\n  }\n\n  A[r3 + 3] /= A[r2 + 3];\n  A[r3 + 6] -= A[r3 + 3] * A[r2 + 6];\n  y[r1] = u0[0] / A[r1];\n  y[r2] = u0[1] - A[r1 + 3] * y[r1];\n  y[r3] = u0[2] - A[r1 + 6] * y[r1];\n  y[r2] /= A[r2 + 3];\n  y[r3] -= A[r2 + 6] * y[r2];\n  y[r3] /= A[r3 + 6];\n  y[r2] -= A[r3 + 3] * y[r3];\n  y[r1] -= y[r3] * A[r3];\n  y[r1] -= y[r2] * A[r2];\n}\n\n/* Model step function */\nvoid MARS_step(void)\n{\n  /* local block i/o variables */\n  real_T rtb_VectorConcatenate[7];\n  __m128d tmp_1;\n  __m128d tmp_2;\n  __m128d tmp_3;\n  __m128d tmp_4;\n  real_T rtb_Product4_g_tmp[9];\n  real_T rtb_VectorConcatenate_b[9];\n  real_T rtb_VectorConcatenate_f[9];\n  real_T rtb_Gain_a[3];\n  real_T rtb_Sum2[3];\n  real_T rtb_Sum2_0[3];\n  real_T rtb_Sum_hp[3];\n  real_T rtb_ECEFPositiontoLLA_o1_idx_0;\n  real_T rtb_ECEFPositiontoLLA_o2;\n  real_T rtb_Gain_f;\n  real_T rtb_VectorConcatenate_f_tmp;\n  real_T rtb_VectorConcatenate_f_tmp_0;\n  real_T rtb_VectorConcatenate_f_tmp_1;\n  real_T rtb_VectorConcatenate_f_tmp_2;\n  real_T rtb_VectorConcatenate_f_tmp_3;\n  real_T rtb_VectorConcatenate_f_tmp_4;\n  real_T rtb_VectorConcatenate_f_tmp_5;\n  real_T rtb_ixk;\n  real_T rtb_jxi;\n  real_T rtb_kxj;\n  real_T rtb_sincos_o2_idx_1;\n  real_T uTmp_idx_0;\n  real_T uTmp_idx_1;\n  int32_T Product4_tmp;\n  int32_T i;\n  int32_T i_0;\n  int8_T rtAction;\n  boolean_T rtb_Compare_a[9];\n  if (rtmIsMajorTimeStep(MARS_M)) {\n    /* set solver stop time */\n    rtsiSetSolverStopTime(&MARS_M->solverInfo,((MARS_M->Timing.clockTick0+1)*\n      MARS_M->Timing.stepSize0));\n  }                                    /* end MajorTimeStep */\n\n  /* Update absolute time of base rate at minor time step */\n  if (rtmIsMinorTimeStep(MARS_M)) {\n    MARS_M->Timing.t[0] = rtsiGetT(&MARS_M->solverInfo);\n  }\n\n  /* Integrator: '<S62>/p1' */\n  if (MARS_DW.p1_IWORK != 0) {\n    MARS_X.p1_CSTATE[0] = 2.5914814724705652E+6;\n    MARS_X.p1_CSTATE[1] = -1.0790161949738523E+6;\n    MARS_X.p1_CSTATE[2] = 5.7079879931331929E+6;\n  }\n\n  /* ECEF2LLA: '<S57>/ECEF Position to LLA' incorporates:\n   *  Integrator: '<S62>/p1'\n   */\n  uTmp_idx_0 = MARS_X.p1_CSTATE[0];\n  uTmp_idx_1 = MARS_X.p1_CSTATE[1];\n  rtb_jxi = sqrt(MARS_X.p1_CSTATE[0] * MARS_X.p1_CSTATE[0] + MARS_X.p1_CSTATE[1]\n                 * MARS_X.p1_CSTATE[1]);\n  rtb_ixk = rt_atan2d_snf(MARS_X.p1_CSTATE[2], 0.99664718933525254 * rtb_jxi);\n  rtb_Gain_f = sin(rtb_ixk);\n  rtb_ECEFPositiontoLLA_o2 = cos(rtb_ixk);\n  rtb_Gain_f = rt_atan2d_snf(42841.311513313573 * rtb_Gain_f * rtb_Gain_f *\n    rtb_Gain_f + MARS_X.p1_CSTATE[2], rtb_jxi - 42697.672707179969 *\n    rtb_ECEFPositiontoLLA_o2 * rtb_ECEFPositiontoLLA_o2 *\n    rtb_ECEFPositiontoLLA_o2);\n  rtb_ECEFPositiontoLLA_o2 = rt_atan2d_snf(0.99664718933525254 * sin(rtb_Gain_f),\n    cos(rtb_Gain_f));\n  i = 0;\n  while ((rtb_ixk != rtb_ECEFPositiontoLLA_o2) && (i < 5)) {\n    rtb_ixk = rtb_ECEFPositiontoLLA_o2;\n    rtb_Gain_f = sin(rtb_ECEFPositiontoLLA_o2);\n    rtb_ECEFPositiontoLLA_o2 = cos(rtb_ECEFPositiontoLLA_o2);\n    rtb_Gain_f = rt_atan2d_snf(42841.311513313573 * rtb_Gain_f * rtb_Gain_f *\n      rtb_Gain_f + MARS_X.p1_CSTATE[2], sqrt(uTmp_idx_0 * uTmp_idx_0 +\n      uTmp_idx_1 * uTmp_idx_1) - 42697.672707179969 * rtb_ECEFPositiontoLLA_o2 *\n      rtb_ECEFPositiontoLLA_o2 * rtb_ECEFPositiontoLLA_o2);\n    rtb_ECEFPositiontoLLA_o2 = rt_atan2d_snf(0.99664718933525254 * sin\n      (rtb_Gain_f), cos(rtb_Gain_f));\n    i++;\n  }\n\n  rtb_kxj = fabs(rtb_Gain_f);\n  rtb_ixk = rtb_Gain_f;\n  rtb_ECEFPositiontoLLA_o2 = rt_atan2d_snf(MARS_X.p1_CSTATE[1],\n    MARS_X.p1_CSTATE[0]);\n  if (rtb_kxj > 3.1415926535897931) {\n    rtb_ixk = rt_modd_snf(rtb_Gain_f + 3.1415926535897931, 6.2831853071795862) -\n      3.1415926535897931;\n    rtb_kxj = fabs(rtb_ixk);\n  }\n\n  if (rtb_kxj > 1.5707963267948966) {\n    rtb_ECEFPositiontoLLA_o2 += 3.1415926535897931;\n    if (!rtIsNaN(rtb_ixk)) {\n      if (rtb_ixk < 0.0) {\n        rtb_ixk = -1.0;\n      } else {\n        rtb_ixk = (rtb_ixk > 0.0);\n      }\n    }\n\n    rtb_ixk *= 1.5707963267948966 - (rtb_kxj - 1.5707963267948966);\n  }\n\n  if (fabs(rtb_ECEFPositiontoLLA_o2) > 3.1415926535897931) {\n    rtb_ECEFPositiontoLLA_o2 = rt_remd_snf(rtb_ECEFPositiontoLLA_o2,\n      6.2831853071795862);\n    rtb_ECEFPositiontoLLA_o2 -= trunc(rtb_ECEFPositiontoLLA_o2 /\n      3.1415926535897931) * 6.2831853071795862;\n  }\n\n  rtb_ECEFPositiontoLLA_o1_idx_0 = rtb_ixk * 180.0 / 3.1415926535897931;\n  rtb_kxj = rtb_ECEFPositiontoLLA_o2 * 180.0 / 3.1415926535897931;\n  rtb_ixk = sin(rtb_Gain_f);\n  rtb_ECEFPositiontoLLA_o2 = ((6.378137E+6 / sqrt(1.0 - rtb_ixk * rtb_ixk *\n    0.0066943799901413165) * 0.0066943799901413165 * rtb_ixk + MARS_X.p1_CSTATE\n    [2]) * rtb_ixk + rtb_jxi * cos(rtb_Gain_f)) - 6.378137E+6 / sqrt(1.0 - sin\n    (rtb_Gain_f) * sin(rtb_Gain_f) * 0.0066943799901413165);\n\n  /* End of ECEF2LLA: '<S57>/ECEF Position to LLA' */\n  if (rtmIsMajorTimeStep(MARS_M) &&\n      MARS_M->Timing.TaskCounters.TID[1] == 0) {\n    /* If: '<S74>/If' */\n    if (rtsiIsModeUpdateTimeStep(&MARS_M->solverInfo)) {\n      rtAction = 1;\n      MARS_DW.If_ActiveSubsystem = 1;\n    } else {\n      rtAction = MARS_DW.If_ActiveSubsystem;\n    }\n\n    switch (rtAction) {\n     case 0:\n      /* Outputs for IfAction SubSystem: '<S74>/Positive Trace' incorporates:\n       *  ActionPort: '<S125>/Action Port'\n       */\n      /* Gain: '<S125>/Gain' incorporates:\n       *  Merge: '<S74>/Merge'\n       */\n      MARS_B.Merge[0] = 0.22088421489473928;\n\n      /* Product: '<S125>/Product' incorporates:\n       *  Merge: '<S74>/Merge'\n       */\n      MARS_B.Merge[1] = MARS_ConstB.Add_jx / 0.88353685957895711;\n      MARS_B.Merge[2] = MARS_ConstB.Add_o / 0.88353685957895711;\n      MARS_B.Merge[3] = MARS_ConstB.Add_n / 0.88353685957895711;\n\n      /* End of Outputs for SubSystem: '<S74>/Positive Trace' */\n      break;\n\n     case 1:\n      /* Outputs for IfAction SubSystem: '<S74>/Negative Trace' incorporates:\n       *  ActionPort: '<S124>/Action Port'\n       */\n      /* If: '<S124>/Find Maximum Diagonal Value' */\n      if ((MARS_ConstB.Product2[4] > MARS_ConstB.Product2[0]) &&\n          (MARS_ConstB.Product2[4] > MARS_ConstB.Product2[8])) {\n        /* Outputs for IfAction SubSystem: '<S124>/Maximum Value at DCM(2,2)' incorporates:\n         *  ActionPort: '<S129>/Action Port'\n         */\n        /* Gain: '<S129>/Gain' incorporates:\n         *  Merge: '<S74>/Merge'\n         */\n        MARS_B.Merge[2] = 0.955404187046654;\n\n        /* Gain: '<S129>/Gain1' incorporates:\n         *  Merge: '<S74>/Merge'\n         */\n        MARS_B.Merge[1] = MARS_ConstB.Product_d[0];\n\n        /* Gain: '<S129>/Gain3' incorporates:\n         *  Merge: '<S74>/Merge'\n         */\n        MARS_B.Merge[3] = MARS_ConstB.Product_d[1];\n\n        /* Gain: '<S129>/Gain4' incorporates:\n         *  Merge: '<S74>/Merge'\n         */\n        MARS_B.Merge[0] = MARS_ConstB.Product_d[2];\n\n        /* End of Outputs for SubSystem: '<S124>/Maximum Value at DCM(2,2)' */\n      } else if (MARS_ConstB.Product2[8] > MARS_ConstB.Product2[0]) {\n        /* Outputs for IfAction SubSystem: '<S124>/Maximum Value at DCM(3,3)' incorporates:\n         *  ActionPort: '<S130>/Action Port'\n         */\n        /* Gain: '<S130>/Gain' incorporates:\n         *  Merge: '<S74>/Merge'\n         */\n        MARS_B.Merge[3] = 0.044147846096478843;\n\n        /* Gain: '<S130>/Gain1' incorporates:\n         *  Merge: '<S74>/Merge'\n         */\n        MARS_B.Merge[1] = MARS_ConstB.Product_l[0];\n\n        /* Gain: '<S130>/Gain2' incorporates:\n         *  Merge: '<S74>/Merge'\n         */\n        MARS_B.Merge[2] = MARS_ConstB.Product_l[1];\n\n        /* Gain: '<S130>/Gain3' incorporates:\n         *  Merge: '<S74>/Merge'\n         */\n        MARS_B.Merge[0] = MARS_ConstB.Product_l[2];\n\n        /* End of Outputs for SubSystem: '<S124>/Maximum Value at DCM(3,3)' */\n      } else {\n        /* Outputs for IfAction SubSystem: '<S124>/Maximum Value at DCM(1,1)' incorporates:\n         *  ActionPort: '<S128>/Action Port'\n         */\n        /* Gain: '<S128>/Gain' incorporates:\n         *  Merge: '<S74>/Merge'\n         */\n        MARS_B.Merge[1] = 0.19095541539610353;\n\n        /* Gain: '<S128>/Gain1' incorporates:\n         *  Merge: '<S74>/Merge'\n         */\n        MARS_B.Merge[2] = MARS_ConstB.Product_n[0];\n\n        /* Gain: '<S128>/Gain2' incorporates:\n         *  Merge: '<S74>/Merge'\n         */\n        MARS_B.Merge[3] = MARS_ConstB.Product_n[1];\n\n        /* Gain: '<S128>/Gain3' incorporates:\n         *  Merge: '<S74>/Merge'\n         */\n        MARS_B.Merge[0] = MARS_ConstB.Product_n[2];\n\n        /* End of Outputs for SubSystem: '<S124>/Maximum Value at DCM(1,1)' */\n      }\n\n      /* End of If: '<S124>/Find Maximum Diagonal Value' */\n      /* End of Outputs for SubSystem: '<S74>/Negative Trace' */\n      break;\n    }\n\n    /* End of If: '<S74>/If' */\n  }\n\n  /* Integrator: '<S61>/q' */\n  if (MARS_DW.q_IWORK != 0) {\n    MARS_X.q_CSTATE[0] = MARS_B.Merge[0];\n    MARS_X.q_CSTATE[1] = MARS_B.Merge[1];\n    MARS_X.q_CSTATE[2] = MARS_B.Merge[2];\n    MARS_X.q_CSTATE[3] = MARS_B.Merge[3];\n  }\n\n  /* Sqrt: '<S173>/sqrt' incorporates:\n   *  Integrator: '<S61>/q'\n   *  Product: '<S174>/Product'\n   *  Product: '<S174>/Product1'\n   *  Product: '<S174>/Product2'\n   *  Product: '<S174>/Product3'\n   *  Sqrt: '<S177>/sqrt'\n   *  Sum: '<S174>/Sum'\n   */\n  rtb_Gain_f = sqrt(((MARS_X.q_CSTATE[0] * MARS_X.q_CSTATE[0] + MARS_X.q_CSTATE\n                      [1] * MARS_X.q_CSTATE[1]) + MARS_X.q_CSTATE[2] *\n                     MARS_X.q_CSTATE[2]) + MARS_X.q_CSTATE[3] * MARS_X.q_CSTATE\n                    [3]);\n\n  /* Product: '<S172>/Product' incorporates:\n   *  Integrator: '<S61>/q'\n   *  Sqrt: '<S173>/sqrt'\n   */\n  rtb_ixk = MARS_X.q_CSTATE[0] / rtb_Gain_f;\n\n  /* Product: '<S172>/Product1' incorporates:\n   *  Integrator: '<S61>/q'\n   *  Sqrt: '<S173>/sqrt'\n   */\n  rtb_jxi = MARS_X.q_CSTATE[1] / rtb_Gain_f;\n\n  /* Product: '<S172>/Product2' incorporates:\n   *  Integrator: '<S61>/q'\n   *  Product: '<S176>/Product2'\n   *  Sqrt: '<S173>/sqrt'\n   */\n  uTmp_idx_0 = MARS_X.q_CSTATE[2] / rtb_Gain_f;\n\n  /* Product: '<S172>/Product3' incorporates:\n   *  Integrator: '<S61>/q'\n   *  Product: '<S176>/Product3'\n   *  Sqrt: '<S173>/sqrt'\n   */\n  uTmp_idx_1 = MARS_X.q_CSTATE[3] / rtb_Gain_f;\n\n  /* Product: '<S162>/Product3' incorporates:\n   *  Product: '<S166>/Product3'\n   */\n  rtb_sincos_o2_idx_1 = rtb_ixk * rtb_ixk;\n\n  /* Product: '<S162>/Product2' incorporates:\n   *  Product: '<S166>/Product2'\n   */\n  rtb_VectorConcatenate_f_tmp_1 = rtb_jxi * rtb_jxi;\n\n  /* Product: '<S162>/Product1' incorporates:\n   *  Product: '<S166>/Product1'\n   *  Product: '<S170>/Product1'\n   *  Product: '<S172>/Product2'\n   */\n  rtb_VectorConcatenate_f_tmp_2 = uTmp_idx_0 * uTmp_idx_0;\n\n  /* Product: '<S162>/Product' incorporates:\n   *  Product: '<S166>/Product'\n   *  Product: '<S170>/Product'\n   *  Product: '<S172>/Product3'\n   */\n  rtb_VectorConcatenate_f_tmp_3 = uTmp_idx_1 * uTmp_idx_1;\n\n  /* Sum: '<S162>/Sum' incorporates:\n   *  Product: '<S162>/Product'\n   *  Product: '<S162>/Product1'\n   *  Product: '<S162>/Product2'\n   *  Product: '<S162>/Product3'\n   */\n  rtb_VectorConcatenate_f[0] = ((rtb_sincos_o2_idx_1 +\n    rtb_VectorConcatenate_f_tmp_1) - rtb_VectorConcatenate_f_tmp_2) -\n    rtb_VectorConcatenate_f_tmp_3;\n\n  /* Product: '<S165>/Product3' incorporates:\n   *  Product: '<S163>/Product3'\n   *  Product: '<S172>/Product3'\n   */\n  rtb_VectorConcatenate_f_tmp = uTmp_idx_1 * rtb_ixk;\n\n  /* Product: '<S165>/Product2' incorporates:\n   *  Product: '<S163>/Product2'\n   *  Product: '<S172>/Product2'\n   */\n  rtb_VectorConcatenate_f_tmp_0 = rtb_jxi * uTmp_idx_0;\n\n  /* Gain: '<S165>/Gain' incorporates:\n   *  Product: '<S165>/Product2'\n   *  Product: '<S165>/Product3'\n   *  Sum: '<S165>/Sum'\n   */\n  rtb_VectorConcatenate_f[1] = (rtb_VectorConcatenate_f_tmp_0 -\n    rtb_VectorConcatenate_f_tmp) * 2.0;\n\n  /* Product: '<S168>/Product2' incorporates:\n   *  Product: '<S164>/Product2'\n   *  Product: '<S172>/Product3'\n   */\n  rtb_VectorConcatenate_f_tmp_4 = rtb_jxi * uTmp_idx_1;\n\n  /* Product: '<S168>/Product1' incorporates:\n   *  Product: '<S164>/Product1'\n   *  Product: '<S172>/Product2'\n   */\n  rtb_VectorConcatenate_f_tmp_5 = rtb_ixk * uTmp_idx_0;\n\n  /* Gain: '<S168>/Gain' incorporates:\n   *  Product: '<S168>/Product1'\n   *  Product: '<S168>/Product2'\n   *  Sum: '<S168>/Sum'\n   */\n  rtb_VectorConcatenate_f[2] = (rtb_VectorConcatenate_f_tmp_5 +\n    rtb_VectorConcatenate_f_tmp_4) * 2.0;\n\n  /* Gain: '<S163>/Gain' incorporates:\n   *  Sum: '<S163>/Sum'\n   */\n  rtb_VectorConcatenate_f[3] = (rtb_VectorConcatenate_f_tmp +\n    rtb_VectorConcatenate_f_tmp_0) * 2.0;\n\n  /* Sum: '<S166>/Sum' incorporates:\n   *  Sum: '<S170>/Sum'\n   */\n  rtb_sincos_o2_idx_1 -= rtb_VectorConcatenate_f_tmp_1;\n  rtb_VectorConcatenate_f[4] = (rtb_sincos_o2_idx_1 +\n    rtb_VectorConcatenate_f_tmp_2) - rtb_VectorConcatenate_f_tmp_3;\n\n  /* Product: '<S169>/Product1' incorporates:\n   *  Product: '<S167>/Product1'\n   */\n  rtb_VectorConcatenate_f_tmp_1 = rtb_ixk * rtb_jxi;\n\n  /* Product: '<S169>/Product2' incorporates:\n   *  Product: '<S167>/Product2'\n   *  Product: '<S172>/Product2'\n   *  Product: '<S172>/Product3'\n   */\n  rtb_VectorConcatenate_f_tmp = uTmp_idx_0 * uTmp_idx_1;\n\n  /* Gain: '<S169>/Gain' incorporates:\n   *  Product: '<S169>/Product1'\n   *  Product: '<S169>/Product2'\n   *  Sum: '<S169>/Sum'\n   */\n  rtb_VectorConcatenate_f[5] = (rtb_VectorConcatenate_f_tmp -\n    rtb_VectorConcatenate_f_tmp_1) * 2.0;\n\n  /* Gain: '<S164>/Gain' incorporates:\n   *  Sum: '<S164>/Sum'\n   */\n  rtb_VectorConcatenate_f[6] = (rtb_VectorConcatenate_f_tmp_4 -\n    rtb_VectorConcatenate_f_tmp_5) * 2.0;\n\n  /* Gain: '<S167>/Gain' incorporates:\n   *  Sum: '<S167>/Sum'\n   */\n  rtb_VectorConcatenate_f[7] = (rtb_VectorConcatenate_f_tmp_1 +\n    rtb_VectorConcatenate_f_tmp) * 2.0;\n\n  /* Sum: '<S170>/Sum' */\n  rtb_VectorConcatenate_f[8] = (rtb_sincos_o2_idx_1 -\n    rtb_VectorConcatenate_f_tmp_2) + rtb_VectorConcatenate_f_tmp_3;\n\n  /* UnitConversion: '<S87>/Unit Conversion' incorporates:\n   *  UnitConversion: '<S197>/Unit Conversion'\n   */\n  /* Unit Conversion - from: deg to: rad\n     Expression: output = (0.0174533*input) + (0) */\n  rtb_ECEFPositiontoLLA_o1_idx_0 *= 0.017453292519943295;\n\n  /* Trigonometry: '<S71>/sincos' incorporates:\n   *  Trigonometry: '<S70>/sine'\n   *  UnitConversion: '<S87>/Unit Conversion'\n   */\n  rtb_jxi = cos(rtb_ECEFPositiontoLLA_o1_idx_0);\n  rtb_VectorConcatenate_f_tmp_1 = sin(rtb_ECEFPositiontoLLA_o1_idx_0);\n\n  /* UnitConversion: '<S87>/Unit Conversion' */\n  rtb_kxj *= 0.017453292519943295;\n\n  /* Trigonometry: '<S71>/sincos' */\n  rtb_sincos_o2_idx_1 = cos(rtb_kxj);\n  rtb_kxj = sin(rtb_kxj);\n\n  /* UnaryMinus: '<S78>/Unary Minus' incorporates:\n   *  Product: '<S78>/u(1)*u(4)'\n   *  Trigonometry: '<S71>/sincos'\n   */\n  rtb_VectorConcatenate_b[0] = -(rtb_VectorConcatenate_f_tmp_1 *\n    rtb_sincos_o2_idx_1);\n\n  /* UnaryMinus: '<S81>/Unary Minus' */\n  rtb_VectorConcatenate_b[1] = -rtb_kxj;\n\n  /* UnaryMinus: '<S84>/Unary Minus' incorporates:\n   *  Product: '<S84>/u(3)*u(4)'\n   */\n  rtb_VectorConcatenate_b[2] = -(rtb_jxi * rtb_sincos_o2_idx_1);\n\n  /* UnaryMinus: '<S79>/Unary Minus' incorporates:\n   *  Product: '<S79>/u(1)*u(2)'\n   *  Trigonometry: '<S71>/sincos'\n   */\n  rtb_VectorConcatenate_b[3] = -(rtb_VectorConcatenate_f_tmp_1 * rtb_kxj);\n\n  /* SignalConversion generated from: '<S88>/Vector Concatenate' */\n  rtb_VectorConcatenate_b[4] = rtb_sincos_o2_idx_1;\n\n  /* UnaryMinus: '<S85>/Unary Minus' incorporates:\n   *  Product: '<S85>/u(2)*u(3)'\n   */\n  rtb_VectorConcatenate_b[5] = -(rtb_jxi * rtb_kxj);\n\n  /* SignalConversion generated from: '<S88>/Vector Concatenate' */\n  rtb_VectorConcatenate_b[6] = rtb_jxi;\n\n  /* SignalConversion generated from: '<S88>/Vector Concatenate' incorporates:\n   *  Constant: '<S83>/Constant'\n   */\n  rtb_VectorConcatenate_b[7] = 0.0;\n\n  /* UnaryMinus: '<S86>/Unary Minus' incorporates:\n   *  Trigonometry: '<S71>/sincos'\n   */\n  rtb_VectorConcatenate_b[8] = -rtb_VectorConcatenate_f_tmp_1;\n  for (i = 0; i < 3; i++) {\n    for (i_0 = 0; i_0 <= 0; i_0 += 2) {\n      /* Product: '<S61>/Product4' incorporates:\n       *  Math: '<S61>/Math Function2'\n       */\n      Product4_tmp = 3 * i + i_0;\n      _mm_storeu_pd(&MARS_B.Product4[Product4_tmp], _mm_set1_pd(0.0));\n\n      /* Product: '<S61>/Product4' incorporates:\n       *  Concatenate: '<S171>/Vector Concatenate'\n       *  Concatenate: '<S196>/Vector Concatenate'\n       *  Math: '<S61>/Math Function2'\n       */\n      tmp_3 = _mm_loadu_pd(&rtb_VectorConcatenate_f[i_0]);\n      tmp_4 = _mm_loadu_pd(&MARS_B.Product4[Product4_tmp]);\n      _mm_storeu_pd(&MARS_B.Product4[Product4_tmp], _mm_add_pd(tmp_4, _mm_mul_pd\n        (tmp_3, _mm_set1_pd(rtb_VectorConcatenate_b[i]))));\n      tmp_3 = _mm_loadu_pd(&rtb_VectorConcatenate_f[i_0 + 3]);\n      tmp_4 = _mm_loadu_pd(&MARS_B.Product4[Product4_tmp]);\n      _mm_storeu_pd(&MARS_B.Product4[Product4_tmp], _mm_add_pd(tmp_4, _mm_mul_pd\n        (tmp_3, _mm_set1_pd(rtb_VectorConcatenate_b[i + 3]))));\n      tmp_3 = _mm_loadu_pd(&rtb_VectorConcatenate_f[i_0 + 6]);\n      tmp_4 = _mm_loadu_pd(&MARS_B.Product4[Product4_tmp]);\n      _mm_storeu_pd(&MARS_B.Product4[Product4_tmp], _mm_add_pd(tmp_4, _mm_mul_pd\n        (tmp_3, _mm_set1_pd(rtb_VectorConcatenate_b[i + 6]))));\n    }\n\n    for (i_0 = 2; i_0 < 3; i_0++) {\n      /* Product: '<S61>/Product4' incorporates:\n       *  Concatenate: '<S171>/Vector Concatenate'\n       *  Concatenate: '<S196>/Vector Concatenate'\n       *  Math: '<S61>/Math Function2'\n       */\n      Product4_tmp = 3 * i + i_0;\n      MARS_B.Product4[Product4_tmp] = 0.0;\n      MARS_B.Product4[Product4_tmp] += rtb_VectorConcatenate_f[i_0] *\n        rtb_VectorConcatenate_b[i];\n      MARS_B.Product4[Product4_tmp] += rtb_VectorConcatenate_f[i_0 + 3] *\n        rtb_VectorConcatenate_b[i + 3];\n      MARS_B.Product4[Product4_tmp] += rtb_VectorConcatenate_f[i_0 + 6] *\n        rtb_VectorConcatenate_b[i + 6];\n    }\n  }\n\n  /* Gain: '<S102>/Gain1' incorporates:\n   *  Concatenate: '<S102>/Vector Concatenate'\n   *  Product: '<S61>/Product4'\n   *  Selector: '<S102>/Selector1'\n   */\n  rtb_VectorConcatenate[0] = MARS_B.Product4[3];\n  rtb_VectorConcatenate[1] = MARS_B.Product4[0];\n  rtb_VectorConcatenate[2] = -MARS_B.Product4[6];\n\n  /* Gain: '<S102>/Gain2' incorporates:\n   *  Concatenate: '<S102>/Vector Concatenate'\n   *  Product: '<S61>/Product4'\n   *  Selector: '<S102>/Selector2'\n   */\n  rtb_VectorConcatenate[3] = MARS_B.Product4[7];\n\n  /* Gain: '<S102>/Gain3' incorporates:\n   *  Concatenate: '<S102>/Vector Concatenate'\n   *  Product: '<S61>/Product4'\n   *  Selector: '<S102>/Selector3'\n   */\n  rtb_VectorConcatenate[5] = -MARS_B.Product4[1];\n\n  /* Gain: '<S102>/Gain2' incorporates:\n   *  Concatenate: '<S102>/Vector Concatenate'\n   *  Product: '<S61>/Product4'\n   *  Selector: '<S102>/Selector2'\n   */\n  rtb_VectorConcatenate[4] = MARS_B.Product4[8];\n\n  /* Gain: '<S102>/Gain3' incorporates:\n   *  Concatenate: '<S102>/Vector Concatenate'\n   *  Product: '<S61>/Product4'\n   *  Selector: '<S102>/Selector3'\n   */\n  rtb_VectorConcatenate[6] = MARS_B.Product4[4];\n\n  /* If: '<S73>/If' */\n  if (rtsiIsModeUpdateTimeStep(&MARS_M->solverInfo)) {\n    rtAction = (int8_T)((!(rtb_VectorConcatenate[2] >= 1.0)) &&\n                        (!(rtb_VectorConcatenate[2] <= -1.0)));\n    MARS_DW.If_ActiveSubsystem_h = rtAction;\n  } else {\n    rtAction = MARS_DW.If_ActiveSubsystem_h;\n  }\n\n  switch (rtAction) {\n   case 0:\n    /* Outputs for IfAction SubSystem: '<S73>/AxisRotZeroR3' incorporates:\n     *  ActionPort: '<S101>/Action Port'\n     */\n    /* If: '<S108>/If' */\n    if (rtsiIsModeUpdateTimeStep(&MARS_M->solverInfo)) {\n      if (rtb_VectorConcatenate[2] > 1.0) {\n        rtAction = 0;\n      } else if (rtb_VectorConcatenate[2] < -1.0) {\n        rtAction = 1;\n      } else {\n        rtAction = 2;\n      }\n\n      MARS_DW.If_ActiveSubsystem_c0 = rtAction;\n    } else {\n      rtAction = MARS_DW.If_ActiveSubsystem_c0;\n    }\n\n    switch (rtAction) {\n     case 0:\n      /* Outputs for IfAction SubSystem: '<S108>/If Action Subsystem' incorporates:\n       *  ActionPort: '<S109>/Action Port'\n       */\n      if (rtmIsMajorTimeStep(MARS_M) &&\n          MARS_M->Timing.TaskCounters.TID[1] == 0) {\n        /* Merge: '<S108>/Merge' incorporates:\n         *  Constant: '<S109>/Constant'\n         */\n        MARS_B.Merge_j2 = 1.0;\n      }\n\n      /* End of Outputs for SubSystem: '<S108>/If Action Subsystem' */\n      break;\n\n     case 1:\n      /* Outputs for IfAction SubSystem: '<S108>/If Action Subsystem1' incorporates:\n       *  ActionPort: '<S110>/Action Port'\n       */\n      if (rtmIsMajorTimeStep(MARS_M) &&\n          MARS_M->Timing.TaskCounters.TID[1] == 0) {\n        /* Merge: '<S108>/Merge' incorporates:\n         *  Constant: '<S110>/Constant'\n         */\n        MARS_B.Merge_j2 = 1.0;\n      }\n\n      /* End of Outputs for SubSystem: '<S108>/If Action Subsystem1' */\n      break;\n\n     case 2:\n      /* Outputs for IfAction SubSystem: '<S108>/If Action Subsystem2' incorporates:\n       *  ActionPort: '<S111>/Action Port'\n       */\n      MARS_IfActionSubsystem2(rtb_VectorConcatenate[2], &MARS_B.Merge_j2);\n\n      /* End of Outputs for SubSystem: '<S108>/If Action Subsystem2' */\n      break;\n    }\n\n    /* End of If: '<S108>/If' */\n    /* End of Outputs for SubSystem: '<S73>/AxisRotZeroR3' */\n    break;\n\n   case 1:\n    /* Outputs for IfAction SubSystem: '<S73>/AxisRotDefault' incorporates:\n     *  ActionPort: '<S100>/Action Port'\n     */\n    /* If: '<S104>/If' */\n    if (rtsiIsModeUpdateTimeStep(&MARS_M->solverInfo)) {\n      if (rtb_VectorConcatenate[2] > 1.0) {\n        rtAction = 0;\n      } else if (rtb_VectorConcatenate[2] < -1.0) {\n        rtAction = 1;\n      } else {\n        rtAction = 2;\n      }\n\n      MARS_DW.If_ActiveSubsystem_c = rtAction;\n    } else {\n      rtAction = MARS_DW.If_ActiveSubsystem_c;\n    }\n\n    switch (rtAction) {\n     case 0:\n      /* Outputs for IfAction SubSystem: '<S104>/If Action Subsystem' incorporates:\n       *  ActionPort: '<S105>/Action Port'\n       */\n      if (rtmIsMajorTimeStep(MARS_M) &&\n          MARS_M->Timing.TaskCounters.TID[1] == 0) {\n        /* Merge: '<S104>/Merge' incorporates:\n         *  Constant: '<S105>/Constant'\n         */\n        MARS_B.Merge_j = 1.0;\n      }\n\n      /* End of Outputs for SubSystem: '<S104>/If Action Subsystem' */\n      break;\n\n     case 1:\n      /* Outputs for IfAction SubSystem: '<S104>/If Action Subsystem1' incorporates:\n       *  ActionPort: '<S106>/Action Port'\n       */\n      if (rtmIsMajorTimeStep(MARS_M) &&\n          MARS_M->Timing.TaskCounters.TID[1] == 0) {\n        /* Merge: '<S104>/Merge' incorporates:\n         *  Constant: '<S106>/Constant'\n         */\n        MARS_B.Merge_j = 1.0;\n      }\n\n      /* End of Outputs for SubSystem: '<S104>/If Action Subsystem1' */\n      break;\n\n     case 2:\n      /* Outputs for IfAction SubSystem: '<S104>/If Action Subsystem2' incorporates:\n       *  ActionPort: '<S107>/Action Port'\n       */\n      MARS_IfActionSubsystem2(rtb_VectorConcatenate[2], &MARS_B.Merge_j);\n\n      /* End of Outputs for SubSystem: '<S104>/If Action Subsystem2' */\n      break;\n    }\n\n    /* End of If: '<S104>/If' */\n    /* End of Outputs for SubSystem: '<S73>/AxisRotDefault' */\n    break;\n  }\n\n  /* End of If: '<S73>/If' */\n  if (rtmIsMajorTimeStep(MARS_M) &&\n      MARS_M->Timing.TaskCounters.TID[2] == 0) {\n    /* Gain: '<S5>/Output' incorporates:\n     *  RandomNumber: '<S5>/White Noise'\n     */\n    MARS_B.Output = 2.23606797749979 * MARS_DW.NextOutput;\n  }\n\n  /* Sum: '<S2>/Subtract' incorporates:\n   *  Constant: '<S2>/Ref Altitude'\n   *  MultiPortSwitch: '<S1>/Height'\n   *  Sum: '<S1>/Sum'\n   */\n  rtb_ixk = 100.0 - (MARS_B.Output + rtb_ECEFPositiontoLLA_o2);\n\n  /* Gain: '<S35>/Integral Gain' */\n  MARS_B.IntegralGain = 0.002 * rtb_ixk;\n\n  /* Gain: '<S41>/Filter Coefficient' incorporates:\n   *  Gain: '<S32>/Derivative Gain'\n   *  Integrator: '<S33>/Filter'\n   *  Sum: '<S33>/SumD'\n   */\n  MARS_B.FilterCoefficient = (0.064118 * rtb_ixk - MARS_X.Filter_CSTATE) * 360.0;\n\n  /* Sum: '<S47>/Sum' incorporates:\n   *  Gain: '<S43>/Proportional Gain'\n   *  Integrator: '<S38>/Integrator'\n   */\n  rtb_jxi = (0.02 * rtb_ixk + MARS_X.Integrator_CSTATE) +\n    MARS_B.FilterCoefficient;\n  if (rtmIsMajorTimeStep(MARS_M) &&\n      MARS_M->Timing.TaskCounters.TID[1] == 0) {\n    boolean_T tmp;\n\n    /* If: '<S103>/If1' */\n    rtAction = -1;\n    if (rtsiIsModeUpdateTimeStep(&MARS_M->solverInfo)) {\n      MARS_DW.If1_ActiveSubsystem = -1;\n    } else {\n      rtAction = MARS_DW.If1_ActiveSubsystem;\n    }\n\n    if (rtAction == 0) {\n      /* Outputs for IfAction SubSystem: '<S103>/If Warning//Error' incorporates:\n       *  ActionPort: '<S112>/if'\n       */\n      /* Bias: '<S115>/Bias1' incorporates:\n       *  Math: '<S115>/Math Function'\n       *  Product: '<S115>/Product'\n       *  Product: '<S61>/Product4'\n       */\n      for (i = 0; i < 3; i++) {\n        for (i_0 = 0; i_0 < 3; i_0++) {\n          Product4_tmp = 3 * i + i_0;\n          rtb_Product4_g_tmp[Product4_tmp] = ((MARS_B.Product4[3 * i_0 + 1] *\n            MARS_B.Product4[3 * i + 1] + MARS_B.Product4[3 * i_0] *\n            MARS_B.Product4[3 * i]) + MARS_B.Product4[3 * i_0 + 2] *\n            MARS_B.Product4[3 * i + 2]) + MARS_ConstP.pooled5[Product4_tmp];\n        }\n      }\n\n      /* End of Bias: '<S115>/Bias1' */\n\n      /* RelationalOperator: '<S121>/Compare' incorporates:\n       *  Abs: '<S115>/Abs2'\n       *  Constant: '<S121>/Constant'\n       */\n      for (i = 0; i < 9; i++) {\n        rtb_Compare_a[i] = (fabs(rtb_Product4_g_tmp[i]) > 4.4408920985006262E-16);\n      }\n\n      /* End of RelationalOperator: '<S121>/Compare' */\n\n      /* Logic: '<S115>/Logical Operator1' incorporates:\n       *  RelationalOperator: '<S121>/Compare'\n       */\n      tmp = rtb_Compare_a[0];\n      for (i = 0; i < 8; i++) {\n        tmp = (tmp || rtb_Compare_a[i + 1]);\n      }\n\n      /* If: '<S112>/If' incorporates:\n       *  Abs: '<S116>/Abs1'\n       *  Bias: '<S116>/Bias'\n       *  Constant: '<S123>/Constant'\n       *  Logic: '<S115>/Logical Operator1'\n       *  Product: '<S122>/Product'\n       *  Product: '<S122>/Product1'\n       *  Product: '<S122>/Product2'\n       *  Product: '<S122>/Product3'\n       *  Product: '<S122>/Product4'\n       *  Product: '<S122>/Product5'\n       *  Product: '<S61>/Product4'\n       *  RelationalOperator: '<S123>/Compare'\n       *  Reshape: '<S122>/Reshape'\n       *  Sum: '<S122>/Sum'\n       */\n      if (fabs((((((MARS_B.Product4[0] * MARS_B.Product4[4] * MARS_B.Product4[8]\n                    - MARS_B.Product4[0] * MARS_B.Product4[5] * MARS_B.Product4\n                    [7]) - MARS_B.Product4[1] * MARS_B.Product4[3] *\n                   MARS_B.Product4[8]) + MARS_B.Product4[2] * MARS_B.Product4[3]\n                  * MARS_B.Product4[7]) + MARS_B.Product4[1] * MARS_B.Product4[5]\n                 * MARS_B.Product4[6]) - MARS_B.Product4[2] * MARS_B.Product4[4]\n                * MARS_B.Product4[6]) + -1.0) > 4.4408920985006262E-16) {\n        /* Outputs for IfAction SubSystem: '<S112>/If Not Proper' incorporates:\n         *  ActionPort: '<S114>/Action Port'\n         */\n        MARS_IfNotProper(1.0);\n\n        /* End of Outputs for SubSystem: '<S112>/If Not Proper' */\n      } else if (tmp) {\n        /* Outputs for IfAction SubSystem: '<S112>/Else If Not Orthogonal' incorporates:\n         *  ActionPort: '<S113>/Action Port'\n         */\n        MARS_ElseIfNotOrthogonal(1.0);\n\n        /* End of Outputs for SubSystem: '<S112>/Else If Not Orthogonal' */\n      }\n\n      /* End of If: '<S112>/If' */\n      /* End of Outputs for SubSystem: '<S103>/If Warning//Error' */\n    }\n\n    /* End of If: '<S103>/If1' */\n\n    /* If: '<S126>/If1' */\n    rtAction = -1;\n    if (rtsiIsModeUpdateTimeStep(&MARS_M->solverInfo)) {\n      MARS_DW.If1_ActiveSubsystem_l = -1;\n    } else {\n      rtAction = MARS_DW.If1_ActiveSubsystem_l;\n    }\n\n    if (rtAction == 0) {\n      /* Outputs for IfAction SubSystem: '<S126>/If Warning//Error' incorporates:\n       *  ActionPort: '<S150>/if'\n       */\n      /* RelationalOperator: '<S159>/Compare' incorporates:\n       *  Abs: '<S153>/Abs2'\n       *  Constant: '<S159>/Constant'\n       */\n      for (i = 0; i < 9; i++) {\n        rtb_Compare_a[i] = (MARS_ConstB.Abs2[i] > 4.4408920985006262E-16);\n      }\n\n      /* End of RelationalOperator: '<S159>/Compare' */\n\n      /* Logic: '<S153>/Logical Operator1' incorporates:\n       *  RelationalOperator: '<S159>/Compare'\n       */\n      tmp = rtb_Compare_a[0];\n      for (i = 0; i < 8; i++) {\n        tmp = (tmp || rtb_Compare_a[i + 1]);\n      }\n\n      /* If: '<S150>/If' incorporates:\n       *  Logic: '<S153>/Logical Operator1'\n       */\n      if (tmp) {\n        /* Outputs for IfAction SubSystem: '<S150>/Else If Not Orthogonal' incorporates:\n         *  ActionPort: '<S151>/Action Port'\n         */\n        MARS_ElseIfNotOrthogonal(1.0);\n\n        /* End of Outputs for SubSystem: '<S150>/Else If Not Orthogonal' */\n      }\n\n      /* End of If: '<S150>/If' */\n      /* End of Outputs for SubSystem: '<S126>/If Warning//Error' */\n    }\n\n    /* End of If: '<S126>/If1' */\n  }\n\n  /* Trigonometry: '<S67>/sincos' incorporates:\n   *  Integrator: '<S65>/Integrator'\n   */\n  rtb_ixk = sin(MARS_X.Integrator_CSTATE_f);\n  rtb_kxj = cos(MARS_X.Integrator_CSTATE_f);\n\n  /* SignalConversion generated from: '<S196>/Vector Concatenate' */\n  rtb_VectorConcatenate_b[0] = rtb_kxj;\n\n  /* SignalConversion generated from: '<S196>/Vector Concatenate' */\n  rtb_VectorConcatenate_b[1] = rtb_ixk;\n\n  /* SignalConversion generated from: '<S196>/Vector Concatenate' incorporates:\n   *  Constant: '<S67>/Zero'\n   */\n  rtb_VectorConcatenate_b[2] = 0.0;\n\n  /* UnaryMinus: '<S67>/Unary Minus' */\n  rtb_VectorConcatenate_b[3] = -rtb_ixk;\n\n  /* SignalConversion generated from: '<S196>/Vector Concatenate' */\n  rtb_VectorConcatenate_b[4] = rtb_kxj;\n\n  /* SignalConversion generated from: '<S196>/Vector Concatenate' incorporates:\n   *  Constant: '<S67>/Zero'\n   */\n  rtb_VectorConcatenate_b[5] = 0.0;\n\n  /* SignalConversion generated from: '<S196>/Vector Concatenate' incorporates:\n   *  Constant: '<S67>/Zero'\n   */\n  rtb_VectorConcatenate_b[6] = 0.0;\n\n  /* SignalConversion generated from: '<S196>/Vector Concatenate' incorporates:\n   *  Constant: '<S67>/Zero'\n   */\n  rtb_VectorConcatenate_b[7] = 0.0;\n\n  /* SignalConversion generated from: '<S196>/Vector Concatenate' incorporates:\n   *  Constant: '<S67>/Zero1'\n   */\n  rtb_VectorConcatenate_b[8] = 1.0;\n  for (i = 0; i < 3; i++) {\n    /* Product: '<S57>/Product3' incorporates:\n     *  Concatenate: '<S171>/Vector Concatenate'\n     *  Product: '<S63>/Product2'\n     */\n    rtb_Sum_hp[i] = (rtb_VectorConcatenate_f[i + 3] * 0.0 +\n                     rtb_VectorConcatenate_f[i] * 0.0) +\n      rtb_VectorConcatenate_f[i + 6] * 7.292115E-5;\n\n    /* Product: '<S70>/Product3' incorporates:\n     *  Integrator: '<S63>/ub,vb,wb'\n     *  Math: '<S70>/Math Function2'\n     *  Product: '<S61>/Product4'\n     */\n    rtb_Sum2[i] = (MARS_B.Product4[3 * i + 1] * MARS_X.ubvbwb_CSTATE[1] +\n                   MARS_B.Product4[3 * i] * MARS_X.ubvbwb_CSTATE[0]) +\n      MARS_B.Product4[3 * i + 2] * MARS_X.ubvbwb_CSTATE[2];\n  }\n\n  /* Sum: '<S70>/Sum2' incorporates:\n   *  Constant: '<S70>/f2'\n   *  Product: '<S70>/Product'\n   */\n  /* Unit Conversion - from: deg to: rad\n     Expression: output = (0.0174533*input) + (0) */\n  rtb_kxj = 1.0 - rtb_VectorConcatenate_f_tmp_1 * rtb_VectorConcatenate_f_tmp_1 *\n    0.00669437999014133;\n\n  /* Product: '<S70>/w1' incorporates:\n   *  Constant: '<S199>/f4'\n   *  Product: '<S199>/N'\n   *  Sqrt: '<S199>/sqrt'\n   *  Sum: '<S199>/Sum4'\n   */\n  rtb_ixk = rtb_Sum2[1] / (6.378137E+6 / sqrt(rtb_kxj) +\n    rtb_ECEFPositiontoLLA_o2);\n\n  /* SignalConversion generated from: '<S57>/Product2' incorporates:\n   *  Constant: '<S198>/f1'\n   *  Constant: '<S198>/f3'\n   *  Gain: '<S70>/Gain'\n   *  Gain: '<S70>/Gain1'\n   *  Math: '<S198>/Math Function'\n   *  Product: '<S198>/M'\n   *  Product: '<S70>/w2'\n   *  Product: '<S70>/w3'\n   *  Sum: '<S198>/Sum1'\n   *  Trigonometry: '<S70>/tan'\n   */\n  rtb_ECEFPositiontoLLA_o2 = -(rtb_Sum2[0] / (6.3354393272928195E+6 /\n    rt_powd_snf(rtb_kxj, 1.5) + rtb_ECEFPositiontoLLA_o2));\n  rtb_kxj = -(rtb_ixk * tan(rtb_ECEFPositiontoLLA_o1_idx_0));\n  for (i = 0; i <= 0; i += 2) {\n    /* Sum: '<S57>/Sum2' incorporates:\n     *  Product: '<S57>/Product2'\n     *  Product: '<S61>/Product4'\n     */\n    tmp_3 = _mm_loadu_pd(&MARS_B.Product4[i + 3]);\n    tmp_4 = _mm_loadu_pd(&MARS_B.Product4[i]);\n    tmp_1 = _mm_loadu_pd(&MARS_B.Product4[i + 6]);\n\n    /* Product: '<S57>/Product3' incorporates:\n     *  Product: '<S57>/Product2'\n     *  Sum: '<S57>/Sum2'\n     */\n    tmp_2 = _mm_loadu_pd(&rtb_Sum_hp[i]);\n\n    /* Sum: '<S57>/Sum2' incorporates:\n     *  Product: '<S57>/Product2'\n     *  SignalConversion generated from: '<S57>/Product2'\n     */\n    _mm_storeu_pd(&MARS_B.Sum2[i], _mm_add_pd(_mm_add_pd(_mm_add_pd(_mm_mul_pd\n      (tmp_3, _mm_set1_pd(rtb_ECEFPositiontoLLA_o2)), _mm_mul_pd(tmp_4,\n      _mm_set1_pd(rtb_ixk))), _mm_mul_pd(tmp_1, _mm_set1_pd(rtb_kxj))), tmp_2));\n  }\n\n  for (i = 2; i < 3; i++) {\n    /* Sum: '<S57>/Sum2' incorporates:\n     *  Product: '<S57>/Product2'\n     *  Product: '<S57>/Product3'\n     *  Product: '<S61>/Product4'\n     *  SignalConversion generated from: '<S57>/Product2'\n     *  Sum: '<S57>/Sum3'\n     */\n    MARS_B.Sum2[i] = ((MARS_B.Product4[i + 3] * rtb_ECEFPositiontoLLA_o2 +\n                       MARS_B.Product4[i] * rtb_ixk) + MARS_B.Product4[i + 6] *\n                      rtb_kxj) + rtb_Sum_hp[i];\n  }\n\n  /* Integrator: '<S57>/p,q,r ' */\n  if (MARS_DW.pqr_IWORK != 0) {\n    MARS_X.pqr_CSTATE[0] = MARS_B.Sum2[0];\n    MARS_X.pqr_CSTATE[1] = MARS_B.Sum2[1];\n    MARS_X.pqr_CSTATE[2] = MARS_B.Sum2[2];\n  }\n\n  /* Sum: '<S57>/Sum4' incorporates:\n   *  Integrator: '<S57>/p,q,r '\n   *  Product: '<S57>/Product3'\n   */\n  rtb_Sum2[0] = MARS_X.pqr_CSTATE[0] - rtb_Sum_hp[0];\n  rtb_Sum2[1] = MARS_X.pqr_CSTATE[1] - rtb_Sum_hp[1];\n  rtb_Sum2[2] = MARS_X.pqr_CSTATE[2] - rtb_Sum_hp[2];\n\n  /* Product: '<S176>/Product' incorporates:\n   *  Integrator: '<S61>/q'\n   */\n  rtb_ECEFPositiontoLLA_o2 = MARS_X.q_CSTATE[0] / rtb_Gain_f;\n\n  /* Product: '<S176>/Product1' incorporates:\n   *  Integrator: '<S61>/q'\n   */\n  rtb_kxj = MARS_X.q_CSTATE[1] / rtb_Gain_f;\n\n  /* SignalConversion generated from: '<S61>/q' incorporates:\n   *  Fcn: '<S77>/q0dot'\n   *  Fcn: '<S77>/q1dot'\n   *  Fcn: '<S77>/q2dot'\n   *  Fcn: '<S77>/q3dot'\n   */\n  MARS_B.TmpSignalConversionAtqInport1[0] = ((rtb_kxj * rtb_Sum2[0] + uTmp_idx_0\n    * rtb_Sum2[1]) + uTmp_idx_1 * rtb_Sum2[2]) * -0.5;\n  MARS_B.TmpSignalConversionAtqInport1[1] = ((rtb_ECEFPositiontoLLA_o2 *\n    rtb_Sum2[0] + uTmp_idx_0 * rtb_Sum2[2]) - uTmp_idx_1 * rtb_Sum2[1]) * 0.5;\n  MARS_B.TmpSignalConversionAtqInport1[2] = ((rtb_ECEFPositiontoLLA_o2 *\n    rtb_Sum2[1] + uTmp_idx_1 * rtb_Sum2[0]) - rtb_kxj * rtb_Sum2[2]) * 0.5;\n  MARS_B.TmpSignalConversionAtqInport1[3] = ((rtb_ECEFPositiontoLLA_o2 *\n    rtb_Sum2[2] + rtb_kxj * rtb_Sum2[1]) - uTmp_idx_0 * rtb_Sum2[0]) * 0.5;\n  for (i = 0; i < 3; i++) {\n    /* Product: '<S62>/Product1' */\n    MARS_B.Product1[i] = 0.0;\n\n    /* Product: '<S62>/Product1' incorporates:\n     *  Concatenate: '<S196>/Vector Concatenate'\n     */\n    rtb_Gain_f = rtb_VectorConcatenate_b[i];\n\n    /* Product: '<S62>/Product1' incorporates:\n     *  LLA2ECEF: '<S62>/LLA to ECEF Position'\n     */\n    MARS_B.Product1[i] += rtb_Gain_f * 2.5914814724705652E+6;\n\n    /* Math: '<S62>/Math Function1' incorporates:\n     *  Math: '<S61>/Math Function'\n     */\n    rtb_Product4_g_tmp[3 * i] = rtb_Gain_f;\n\n    /* Product: '<S62>/Product1' incorporates:\n     *  Concatenate: '<S196>/Vector Concatenate'\n     */\n    rtb_Gain_f = rtb_VectorConcatenate_b[i + 3];\n\n    /* Product: '<S62>/Product1' incorporates:\n     *  LLA2ECEF: '<S62>/LLA to ECEF Position'\n     */\n    MARS_B.Product1[i] += rtb_Gain_f * -1.0790161949738523E+6;\n\n    /* Math: '<S62>/Math Function1' incorporates:\n     *  Math: '<S61>/Math Function'\n     */\n    rtb_Product4_g_tmp[3 * i + 1] = rtb_Gain_f;\n\n    /* Product: '<S62>/Product1' incorporates:\n     *  Concatenate: '<S196>/Vector Concatenate'\n     */\n    rtb_Gain_f = rtb_VectorConcatenate_b[i + 6];\n\n    /* Product: '<S62>/Product1' incorporates:\n     *  LLA2ECEF: '<S62>/LLA to ECEF Position'\n     */\n    MARS_B.Product1[i] += rtb_Gain_f * 5.7079879931331929E+6;\n\n    /* Math: '<S62>/Math Function1' incorporates:\n     *  Math: '<S61>/Math Function'\n     */\n    rtb_Product4_g_tmp[3 * i + 2] = rtb_Gain_f;\n  }\n\n  for (i = 0; i < 3; i++) {\n    /* Product: '<S62>/Product5' incorporates:\n     *  Concatenate: '<S171>/Vector Concatenate'\n     *  Integrator: '<S63>/ub,vb,wb'\n     *  Math: '<S62>/Math Function2'\n     */\n    MARS_B.Product5[i] = 0.0;\n    MARS_B.Product5[i] += rtb_VectorConcatenate_f[3 * i] * MARS_X.ubvbwb_CSTATE\n      [0];\n    MARS_B.Product5[i] += rtb_VectorConcatenate_f[3 * i + 1] *\n      MARS_X.ubvbwb_CSTATE[1];\n    MARS_B.Product5[i] += rtb_VectorConcatenate_f[3 * i + 2] *\n      MARS_X.ubvbwb_CSTATE[2];\n\n    /* Product: '<S62>/Product4' incorporates:\n     *  Math: '<S62>/Math Function1'\n     */\n    rtb_Sum2[i] = (rtb_Product4_g_tmp[i + 3] * 0.0 + rtb_Product4_g_tmp[i] * 0.0)\n      + rtb_Product4_g_tmp[i + 6] * 7.292115E-5;\n  }\n\n  /* Integrator: '<S62>/p' */\n  if (MARS_DW.p_IWORK != 0) {\n    MARS_X.p_CSTATE[0] = MARS_B.Product1[0];\n    MARS_X.p_CSTATE[1] = MARS_B.Product1[1];\n    MARS_X.p_CSTATE[2] = MARS_B.Product1[2];\n  }\n\n  /* Sum: '<S179>/Sum' incorporates:\n   *  Integrator: '<S62>/p'\n   *  Product: '<S180>/i x j'\n   *  Product: '<S180>/j x k'\n   *  Product: '<S180>/k x i'\n   *  Product: '<S181>/i x k'\n   *  Product: '<S181>/j x i'\n   *  Product: '<S181>/k x j'\n   */\n  rtb_Gain_a[0] = MARS_X.p_CSTATE[1] * rtb_Sum2[2];\n  rtb_Gain_a[1] = rtb_Sum2[0] * MARS_X.p_CSTATE[2];\n  rtb_Gain_a[2] = MARS_X.p_CSTATE[0] * rtb_Sum2[1];\n  rtb_Sum2_0[0] = rtb_Sum2[1] * MARS_X.p_CSTATE[2];\n  rtb_Sum2_0[1] = MARS_X.p_CSTATE[0] * rtb_Sum2[2];\n  rtb_Sum2_0[2] = rtb_Sum2[0] * MARS_X.p_CSTATE[1];\n  for (i = 0; i < 3; i++) {\n    /* Sum: '<S62>/Sum2' */\n    rtb_Gain_f = 0.0;\n    for (i_0 = 0; i_0 < 3; i_0++) {\n      /* Math: '<S62>/Math Function' incorporates:\n       *  Concatenate: '<S171>/Vector Concatenate'\n       *  Math: '<S61>/Math Function'\n       *  Product: '<S61>/Product1'\n       *  Product: '<S62>/Product2'\n       */\n      Product4_tmp = 3 * i_0 + i;\n      rtb_VectorConcatenate_b[Product4_tmp] = 0.0;\n      rtb_VectorConcatenate_b[Product4_tmp] += rtb_Product4_g_tmp[3 * i] *\n        rtb_VectorConcatenate_f[i_0];\n      rtb_VectorConcatenate_b[Product4_tmp] += rtb_Product4_g_tmp[3 * i + 1] *\n        rtb_VectorConcatenate_f[i_0 + 3];\n      rtb_VectorConcatenate_b[Product4_tmp] += rtb_Product4_g_tmp[3 * i + 2] *\n        rtb_VectorConcatenate_f[i_0 + 6];\n\n      /* Sum: '<S62>/Sum2' incorporates:\n       *  Integrator: '<S63>/ub,vb,wb'\n       *  Product: '<S62>/Product2'\n       */\n      rtb_Gain_f += rtb_VectorConcatenate_b[Product4_tmp] *\n        MARS_X.ubvbwb_CSTATE[i_0];\n    }\n\n    /* Sum: '<S62>/Sum2' incorporates:\n     *  Product: '<S62>/Product2'\n     *  Sum: '<S179>/Sum'\n     */\n    MARS_B.Sum2_e[i] = rtb_Gain_f - (rtb_Gain_a[i] - rtb_Sum2_0[i]);\n\n    /* Sum: '<S63>/Sum2' incorporates:\n     *  Integrator: '<S57>/p,q,r '\n     *  Product: '<S63>/Product2'\n     */\n    rtb_Sum_hp[i] += MARS_X.pqr_CSTATE[i];\n  }\n\n  /* Sum: '<S184>/Sum' incorporates:\n   *  Constant: '<S57>/omega_earth2'\n   *  Constant: '<S57>/omega_earth3'\n   *  Integrator: '<S62>/p1'\n   *  Product: '<S189>/i x j'\n   *  Product: '<S189>/j x k'\n   *  Product: '<S189>/k x i'\n   *  Product: '<S190>/i x k'\n   *  Product: '<S190>/j x i'\n   *  Product: '<S190>/k x j'\n   */\n  rtb_Sum2[0] = 0.0 * MARS_X.p1_CSTATE[2] - 7.292115E-5 * MARS_X.p1_CSTATE[1];\n  rtb_Sum2[1] = 7.292115E-5 * MARS_X.p1_CSTATE[0] - 0.0 * MARS_X.p1_CSTATE[2];\n  rtb_Sum2[2] = 0.0 * MARS_X.p1_CSTATE[1] - 0.0 * MARS_X.p1_CSTATE[0];\n\n  /* Saturate: '<S45>/Saturation' */\n  if (rtb_jxi > 1.0) {\n    rtb_jxi = 1.0;\n  } else if (rtb_jxi < 0.2) {\n    rtb_jxi = 0.2;\n  }\n\n  /* End of Saturate: '<S45>/Saturation' */\n\n  /* Product: '<S59>/Product2' incorporates:\n   *  Constant: '<S4>/Max Thrust'\n   */\n  rtb_jxi *= 40.0;\n\n  /* Product: '<S202>/Tsin(delta)' */\n  rtb_ECEFPositiontoLLA_o2 = rtb_jxi * 0.0;\n\n  /* Product: '<S202>/Product' */\n  rtb_Gain_f = rtb_ECEFPositiontoLLA_o2;\n\n  /* Product: '<S202>/Product1' */\n  rtb_ECEFPositiontoLLA_o2 *= 0.0;\n\n  /* Sum: '<S182>/Sum' incorporates:\n   *  Integrator: '<S63>/ub,vb,wb'\n   *  Product: '<S185>/i x j'\n   *  Product: '<S185>/j x k'\n   *  Product: '<S185>/k x i'\n   *  Product: '<S186>/i x k'\n   *  Product: '<S186>/j x i'\n   *  Product: '<S186>/k x j'\n   */\n  rtb_Gain_a[0] = MARS_X.ubvbwb_CSTATE[1] * rtb_Sum_hp[2];\n  rtb_Gain_a[1] = rtb_Sum_hp[0] * MARS_X.ubvbwb_CSTATE[2];\n  rtb_Gain_a[2] = MARS_X.ubvbwb_CSTATE[0] * rtb_Sum_hp[1];\n  rtb_Sum2_0[0] = rtb_Sum_hp[1] * MARS_X.ubvbwb_CSTATE[2];\n  rtb_Sum2_0[1] = MARS_X.ubvbwb_CSTATE[0] * rtb_Sum_hp[2];\n  rtb_Sum2_0[2] = rtb_Sum_hp[0] * MARS_X.ubvbwb_CSTATE[1];\n\n  /* Sum: '<S183>/Sum' incorporates:\n   *  Constant: '<S57>/omega_earth2'\n   *  Constant: '<S57>/omega_earth3'\n   *  Product: '<S187>/i x j'\n   *  Product: '<S187>/j x k'\n   *  Product: '<S187>/k x i'\n   *  Product: '<S188>/i x k'\n   *  Product: '<S188>/j x i'\n   *  Product: '<S188>/k x j'\n   */\n  uTmp_idx_0 = 0.0 * rtb_Sum2[2] - 7.292115E-5 * rtb_Sum2[1];\n  uTmp_idx_1 = 7.292115E-5 * rtb_Sum2[0] - 0.0 * rtb_Sum2[2];\n  rtb_ixk = 0.0 * rtb_Sum2[1] - 0.0 * rtb_Sum2[0];\n  for (i = 0; i <= 0; i += 2) {\n    __m128d tmp_0;\n\n    /* Sum: '<S182>/Sum' incorporates:\n     *  Product: '<S63>/Product1'\n     *  Sum: '<S63>/Sum'\n     */\n    tmp_3 = _mm_loadu_pd(&rtb_Gain_a[i]);\n    tmp_4 = _mm_loadu_pd(&rtb_Sum2_0[i]);\n\n    /* Sum: '<S63>/Sum' incorporates:\n     *  Concatenate: '<S171>/Vector Concatenate'\n     *  Product: '<S63>/Product1'\n     */\n    tmp_1 = _mm_loadu_pd(&rtb_VectorConcatenate_f[i + 3]);\n    tmp_2 = _mm_loadu_pd(&rtb_VectorConcatenate_f[i]);\n    tmp_0 = _mm_loadu_pd(&rtb_VectorConcatenate_f[i + 6]);\n    _mm_storeu_pd(&rtb_Sum2[i], _mm_sub_pd(_mm_sub_pd(tmp_3, tmp_4), _mm_add_pd\n      (_mm_add_pd(_mm_mul_pd(tmp_1, _mm_set1_pd(uTmp_idx_1)), _mm_mul_pd(tmp_2,\n      _mm_set1_pd(uTmp_idx_0))), _mm_mul_pd(tmp_0, _mm_set1_pd(rtb_ixk)))));\n  }\n\n  /* Sum: '<S63>/Sum' incorporates:\n   *  Concatenate: '<S171>/Vector Concatenate'\n   *  Product: '<S63>/Product1'\n   *  Sum: '<S182>/Sum'\n   */\n  for (i = 2; i < 3; i++) {\n    rtb_Sum2[i] = (rtb_Gain_a[i] - rtb_Sum2_0[i]) - ((rtb_VectorConcatenate_f[i\n      + 3] * uTmp_idx_1 + rtb_VectorConcatenate_f[i] * uTmp_idx_0) +\n      rtb_VectorConcatenate_f[i + 6] * rtb_ixk);\n  }\n\n  /* Product: '<S57>/Product' incorporates:\n   *  Constant: '<S66>/Constant'\n   *  Gain: '<S202>/Gain2'\n   *  Gain: '<S202>/Gain4'\n   *  Product: '<S202>/Tcos(delta)'\n   *  Sum: '<S202>/Sum'\n   */\n  rtb_Gain_a[0] = rtb_Gain_f / 1.6;\n  rtb_Gain_a[1] = -rtb_ECEFPositiontoLLA_o2 / 1.6;\n  rtb_Gain_a[2] = -(rtb_jxi + -18.605) / 1.6;\n  for (i = 0; i < 3; i++) {\n    /* Sum: '<S63>/Sum' */\n    rtb_jxi = rtb_Sum2[i] + rtb_Gain_a[i];\n\n    /* DeadZone: '<S63>/Dead Zone' */\n    if (rtb_jxi > 2.2204460492503131E-16) {\n      /* DeadZone: '<S63>/Dead Zone' */\n      MARS_B.DeadZone[i] = rtb_jxi - 2.2204460492503131E-16;\n    } else if (rtb_jxi >= -2.2204460492503131E-16) {\n      /* DeadZone: '<S63>/Dead Zone' */\n      MARS_B.DeadZone[i] = 0.0;\n    } else {\n      /* DeadZone: '<S63>/Dead Zone' */\n      MARS_B.DeadZone[i] = rtb_jxi - -2.2204460492503131E-16;\n    }\n\n    /* End of DeadZone: '<S63>/Dead Zone' */\n\n    /* Sum: '<S63>/Sum' incorporates:\n     *  Integrator: '<S57>/p,q,r '\n     *  Product: '<S192>/Product'\n     *  Selector: '<S64>/Selector'\n     */\n    rtb_Sum_hp[i] = (MARS_ConstB.Selector[i + 3] * MARS_X.pqr_CSTATE[1] +\n                     MARS_ConstB.Selector[i] * MARS_X.pqr_CSTATE[0]) +\n      MARS_ConstB.Selector[i + 6] * MARS_X.pqr_CSTATE[2];\n  }\n\n  /* Sum: '<S191>/Sum' incorporates:\n   *  Integrator: '<S57>/p,q,r '\n   *  Product: '<S194>/i x j'\n   *  Product: '<S194>/j x k'\n   *  Product: '<S194>/k x i'\n   *  Product: '<S195>/i x k'\n   *  Product: '<S195>/j x i'\n   *  Product: '<S195>/k x j'\n   */\n  rtb_Gain_a[0] = MARS_X.pqr_CSTATE[1] * rtb_Sum_hp[2];\n  rtb_Gain_a[1] = rtb_Sum_hp[0] * MARS_X.pqr_CSTATE[2];\n  rtb_Gain_a[2] = MARS_X.pqr_CSTATE[0] * rtb_Sum_hp[1];\n  rtb_Sum2_0[0] = rtb_Sum_hp[1] * MARS_X.pqr_CSTATE[2];\n  rtb_Sum2_0[1] = MARS_X.pqr_CSTATE[0] * rtb_Sum_hp[2];\n  rtb_Sum2_0[2] = rtb_Sum_hp[0] * MARS_X.pqr_CSTATE[1];\n  for (i = 0; i <= 0; i += 2) {\n    /* Sum: '<S191>/Sum' */\n    tmp_3 = _mm_loadu_pd(&rtb_Gain_a[i]);\n    tmp_4 = _mm_loadu_pd(&rtb_Sum2_0[i]);\n    _mm_storeu_pd(&rtb_Sum_hp[i], _mm_sub_pd(tmp_3, tmp_4));\n\n    /* Product: '<S193>/Product' incorporates:\n     *  Integrator: '<S57>/p,q,r '\n     *  Sum: '<S191>/Sum'\n     *  Sum: '<S64>/Sum2'\n     */\n    _mm_storeu_pd(&rtb_Sum2[i], _mm_set1_pd(0.0 * MARS_X.pqr_CSTATE[2] + (0.0 *\n      MARS_X.pqr_CSTATE[1] + 0.0 * MARS_X.pqr_CSTATE[0])));\n  }\n\n  for (i = 2; i < 3; i++) {\n    /* Sum: '<S191>/Sum' */\n    rtb_Sum_hp[i] = rtb_Gain_a[i] - rtb_Sum2_0[i];\n\n    /* Product: '<S193>/Product' incorporates:\n     *  Integrator: '<S57>/p,q,r '\n     *  Sum: '<S64>/Sum2'\n     */\n    rtb_Sum2[i] = (0.0 * MARS_X.pqr_CSTATE[1] + 0.0 * MARS_X.pqr_CSTATE[0]) +\n      0.0 * MARS_X.pqr_CSTATE[2];\n  }\n\n  /* Sum: '<S64>/Sum2' incorporates:\n   *  Constant: '<S4>/M_x'\n   *  Gain: '<S4>/Gain'\n   *  Gain: '<S4>/Gain1'\n   */\n  rtb_Gain_a[0] = (0.1 * rtb_Gain_f - rtb_Sum2[0]) - rtb_Sum_hp[0];\n  rtb_Gain_a[1] = (0.1 * rtb_ECEFPositiontoLLA_o2 - rtb_Sum2[1]) - rtb_Sum_hp[1];\n  rtb_Gain_a[2] = (0.0 - rtb_Sum2[2]) - rtb_Sum_hp[2];\n\n  /* Product: '<S64>/Product2' incorporates:\n   *  Selector: '<S64>/Selector2'\n   */\n  rt_mrdivide_U1d1x3_U2d_9vOrDY9Z(rtb_Gain_a, MARS_ConstB.Selector2,\n    MARS_B.Product2);\n  if (rtmIsMajorTimeStep(MARS_M)) {\n    /* Update for Integrator: '<S62>/p1' */\n    MARS_DW.p1_IWORK = 0;\n\n    /* Update for Integrator: '<S61>/q' */\n    MARS_DW.q_IWORK = 0;\n    if (rtmIsMajorTimeStep(MARS_M) &&\n        MARS_M->Timing.TaskCounters.TID[2] == 0) {\n      /* Update for RandomNumber: '<S5>/White Noise' */\n      MARS_DW.NextOutput = rt_nrand_Upu32_Yd_f_pw_snf(&MARS_DW.RandSeed);\n    }\n\n    /* Update for Integrator: '<S57>/p,q,r ' */\n    MARS_DW.pqr_IWORK = 0;\n\n    /* Update for Integrator: '<S62>/p' */\n    MARS_DW.p_IWORK = 0;\n  }                                    /* end MajorTimeStep */\n\n  if (rtmIsMajorTimeStep(MARS_M)) {\n    rt_ertODEUpdateContinuousStates(&MARS_M->solverInfo);\n\n    /* Update absolute time for base rate */\n    /* The \"clockTick0\" counts the number of times the code of this task has\n     * been executed. The absolute time is the multiplication of \"clockTick0\"\n     * and \"Timing.stepSize0\". Size of \"clockTick0\" ensures timer will not\n     * overflow during the application lifespan selected.\n     */\n    ++MARS_M->Timing.clockTick0;\n    MARS_M->Timing.t[0] = rtsiGetSolverStopTime(&MARS_M->solverInfo);\n\n    {\n      /* Update absolute timer for sample time: [0.016666666666666666s, 0.0s] */\n      /* The \"clockTick1\" counts the number of times the code of this task has\n       * been executed. The resolution of this integer timer is 0.016666666666666666, which is the step size\n       * of the task. Size of \"clockTick1\" ensures timer will not overflow during the\n       * application lifespan selected.\n       */\n      MARS_M->Timing.clockTick1++;\n    }\n\n    rate_scheduler();\n  }                                    /* end MajorTimeStep */\n}\n\n/* Derivatives for root system: '<Root>' */\nvoid MARS_derivatives(void)\n{\n  XDot_MARS_T *_rtXdot;\n  _rtXdot = ((XDot_MARS_T *) MARS_M->derivs);\n\n  /* Derivatives for Integrator: '<S62>/p1' */\n  _rtXdot->p1_CSTATE[0] = MARS_B.Product5[0];\n  _rtXdot->p1_CSTATE[1] = MARS_B.Product5[1];\n  _rtXdot->p1_CSTATE[2] = MARS_B.Product5[2];\n\n  /* Derivatives for Integrator: '<S61>/q' */\n  _rtXdot->q_CSTATE[0] = MARS_B.TmpSignalConversionAtqInport1[0];\n  _rtXdot->q_CSTATE[1] = MARS_B.TmpSignalConversionAtqInport1[1];\n  _rtXdot->q_CSTATE[2] = MARS_B.TmpSignalConversionAtqInport1[2];\n  _rtXdot->q_CSTATE[3] = MARS_B.TmpSignalConversionAtqInport1[3];\n\n  /* Derivatives for Integrator: '<S33>/Filter' */\n  _rtXdot->Filter_CSTATE = MARS_B.FilterCoefficient;\n\n  /* Derivatives for Integrator: '<S38>/Integrator' */\n  _rtXdot->Integrator_CSTATE = MARS_B.IntegralGain;\n\n  /* Derivatives for Integrator: '<S65>/Integrator' incorporates:\n   *  Constant: '<S65>/Constant1'\n   */\n  _rtXdot->Integrator_CSTATE_f = 7.292115E-5;\n\n  /* Derivatives for Integrator: '<S63>/ub,vb,wb' */\n  _rtXdot->ubvbwb_CSTATE[0] = MARS_B.DeadZone[0];\n\n  /* Derivatives for Integrator: '<S57>/p,q,r ' */\n  _rtXdot->pqr_CSTATE[0] = MARS_B.Product2[0];\n\n  /* Derivatives for Integrator: '<S62>/p' */\n  _rtXdot->p_CSTATE[0] = MARS_B.Sum2_e[0];\n\n  /* Derivatives for Integrator: '<S63>/ub,vb,wb' */\n  _rtXdot->ubvbwb_CSTATE[1] = MARS_B.DeadZone[1];\n\n  /* Derivatives for Integrator: '<S57>/p,q,r ' */\n  _rtXdot->pqr_CSTATE[1] = MARS_B.Product2[1];\n\n  /* Derivatives for Integrator: '<S62>/p' */\n  _rtXdot->p_CSTATE[1] = MARS_B.Sum2_e[1];\n\n  /* Derivatives for Integrator: '<S63>/ub,vb,wb' */\n  _rtXdot->ubvbwb_CSTATE[2] = MARS_B.DeadZone[2];\n\n  /* Derivatives for Integrator: '<S57>/p,q,r ' */\n  _rtXdot->pqr_CSTATE[2] = MARS_B.Product2[2];\n\n  /* Derivatives for Integrator: '<S62>/p' */\n  _rtXdot->p_CSTATE[2] = MARS_B.Sum2_e[2];\n}\n\n/* Model initialize function */\nvoid MARS_initialize(void)\n{\n  /* Registration code */\n\n  /* initialize non-finites */\n  rt_InitInfAndNaN(sizeof(real_T));\n\n  /* initialize real-time model */\n  (void) memset((void *)MARS_M, 0,\n                sizeof(RT_MODEL_MARS_T));\n\n  {\n    /* Setup solver object */\n    rtsiSetSimTimeStepPtr(&MARS_M->solverInfo, &MARS_M->Timing.simTimeStep);\n    rtsiSetTPtr(&MARS_M->solverInfo, &rtmGetTPtr(MARS_M));\n    rtsiSetStepSizePtr(&MARS_M->solverInfo, &MARS_M->Timing.stepSize0);\n    rtsiSetdXPtr(&MARS_M->solverInfo, &MARS_M->derivs);\n    rtsiSetContStatesPtr(&MARS_M->solverInfo, (real_T **) &MARS_M->contStates);\n    rtsiSetNumContStatesPtr(&MARS_M->solverInfo, &MARS_M->Sizes.numContStates);\n    rtsiSetNumPeriodicContStatesPtr(&MARS_M->solverInfo,\n      &MARS_M->Sizes.numPeriodicContStates);\n    rtsiSetPeriodicContStateIndicesPtr(&MARS_M->solverInfo,\n      &MARS_M->periodicContStateIndices);\n    rtsiSetPeriodicContStateRangesPtr(&MARS_M->solverInfo,\n      &MARS_M->periodicContStateRanges);\n    rtsiSetErrorStatusPtr(&MARS_M->solverInfo, (&rtmGetErrorStatus(MARS_M)));\n    rtsiSetRTModelPtr(&MARS_M->solverInfo, MARS_M);\n  }\n\n  rtsiSetSimTimeStep(&MARS_M->solverInfo, MAJOR_TIME_STEP);\n  MARS_M->intgData.y = MARS_M->odeY;\n  MARS_M->intgData.f[0] = MARS_M->odeF[0];\n  MARS_M->intgData.f[1] = MARS_M->odeF[1];\n  MARS_M->intgData.f[2] = MARS_M->odeF[2];\n  MARS_M->contStates = ((X_MARS_T *) &MARS_X);\n  rtsiSetSolverData(&MARS_M->solverInfo, (void *)&MARS_M->intgData);\n  rtsiSetIsMinorTimeStepWithModeChange(&MARS_M->solverInfo, false);\n  rtsiSetSolverName(&MARS_M->solverInfo,\"ode3\");\n  rtmSetTPtr(MARS_M, &MARS_M->Timing.tArray[0]);\n  MARS_M->Timing.stepSize0 = 0.016666666666666666;\n  rtmSetFirstInitCond(MARS_M, 1);\n\n  /* block I/O */\n  (void) memset(((void *) &MARS_B), 0,\n                sizeof(B_MARS_T));\n\n  /* states (continuous) */\n  {\n    (void) memset((void *)&MARS_X, 0,\n                  sizeof(X_MARS_T));\n  }\n\n  /* states (dwork) */\n  (void) memset((void *)&MARS_DW, 0,\n                sizeof(DW_MARS_T));\n\n  /* Start for If: '<S74>/If' */\n  MARS_DW.If_ActiveSubsystem = -1;\n\n  /* Start for If: '<S73>/If' */\n  MARS_DW.If_ActiveSubsystem_h = -1;\n\n  /* Start for If: '<S103>/If1' */\n  MARS_DW.If1_ActiveSubsystem = -1;\n\n  /* Start for If: '<S126>/If1' */\n  MARS_DW.If1_ActiveSubsystem_l = -1;\n\n  /* InitializeConditions for Integrator: '<S62>/p1' incorporates:\n   *  Integrator: '<S61>/q'\n   */\n  if (rtmIsFirstInitCond(MARS_M)) {\n    MARS_X.p1_CSTATE[0] = 0.0;\n    MARS_X.p1_CSTATE[1] = 0.0;\n    MARS_X.p1_CSTATE[2] = 0.0;\n    MARS_X.q_CSTATE[0] = 0.0;\n    MARS_X.q_CSTATE[1] = 0.0;\n    MARS_X.q_CSTATE[2] = 0.0;\n    MARS_X.q_CSTATE[3] = 0.0;\n  }\n\n  MARS_DW.p1_IWORK = 1;\n\n  /* End of InitializeConditions for Integrator: '<S62>/p1' */\n\n  /* InitializeConditions for Integrator: '<S61>/q' */\n  MARS_DW.q_IWORK = 1;\n\n  /* InitializeConditions for RandomNumber: '<S5>/White Noise' */\n  MARS_DW.RandSeed = 1529675776U;\n  MARS_DW.NextOutput = rt_nrand_Upu32_Yd_f_pw_snf(&MARS_DW.RandSeed);\n\n  /* InitializeConditions for Integrator: '<S33>/Filter' */\n  MARS_X.Filter_CSTATE = 0.0;\n\n  /* InitializeConditions for Integrator: '<S38>/Integrator' */\n  MARS_X.Integrator_CSTATE = 0.0;\n\n  /* InitializeConditions for Integrator: '<S65>/Integrator' */\n  MARS_X.Integrator_CSTATE_f = 0.0;\n\n  /* InitializeConditions for Integrator: '<S63>/ub,vb,wb' */\n  MARS_X.ubvbwb_CSTATE[0] = 0.0;\n  MARS_X.ubvbwb_CSTATE[1] = 0.0;\n  MARS_X.ubvbwb_CSTATE[2] = 0.0;\n\n  /* InitializeConditions for Integrator: '<S57>/p,q,r ' incorporates:\n   *  Integrator: '<S62>/p'\n   */\n  if (rtmIsFirstInitCond(MARS_M)) {\n    MARS_X.pqr_CSTATE[0] = 0.0;\n    MARS_X.pqr_CSTATE[1] = 0.0;\n    MARS_X.pqr_CSTATE[2] = 0.0;\n    MARS_X.p_CSTATE[0] = 0.0;\n    MARS_X.p_CSTATE[1] = 0.0;\n    MARS_X.p_CSTATE[2] = 0.0;\n  }\n\n  MARS_DW.pqr_IWORK = 1;\n\n  /* End of InitializeConditions for Integrator: '<S57>/p,q,r ' */\n\n  /* InitializeConditions for Integrator: '<S62>/p' */\n  MARS_DW.p_IWORK = 1;\n\n  /* SystemInitialize for Merge: '<S74>/Merge' */\n  MARS_B.Merge[0] = 1.0;\n  MARS_B.Merge[1] = 0.0;\n  MARS_B.Merge[2] = 0.0;\n  MARS_B.Merge[3] = 0.0;\n\n  /* SystemInitialize for IfAction SubSystem: '<S73>/AxisRotZeroR3' */\n  /* Start for If: '<S108>/If' */\n  MARS_DW.If_ActiveSubsystem_c0 = -1;\n\n  /* End of SystemInitialize for SubSystem: '<S73>/AxisRotZeroR3' */\n\n  /* SystemInitialize for IfAction SubSystem: '<S73>/AxisRotDefault' */\n  /* Start for If: '<S104>/If' */\n  MARS_DW.If_ActiveSubsystem_c = -1;\n\n  /* End of SystemInitialize for SubSystem: '<S73>/AxisRotDefault' */\n\n  /* set \"at time zero\" to false */\n  if (rtmIsFirstInitCond(MARS_M)) {\n    rtmSetFirstInitCond(MARS_M, 0);\n  }\n}\n\n/* Model terminate function */\nvoid MARS_terminate(void)\n{\n  /* (no terminate code required) */\n}\n"},{"name":"MARS.h","type":"header","group":"model","path":"/home/aman/GitHub/flightTestingLab/controls/Ingenuity_Modelling/MATLAB-env/MARS_grt_rtw","tag":"","groupDisplay":"Model files","code":"/*\n * MARS.h\n *\n * Academic License - for use in teaching, academic research, and meeting\n * course requirements at degree granting institutions only.  Not for\n * government, commercial, or other organizational use.\n *\n * Code generation for model \"MARS\".\n *\n * Model version              : 1.28\n * Simulink Coder version : 9.7 (R2022a) 13-Nov-2021\n * C source code generated on : Fri Oct 28 08:09:17 2022\n *\n * Target selection: grt.tlc\n * Note: GRT includes extra infrastructure and instrumentation for prototyping\n * Embedded hardware selection: Intel->x86-64 (Windows64)\n * Code generation objective: Execution efficiency\n * Validation result: Not run\n */\n\n#ifndef RTW_HEADER_MARS_h_\n#define RTW_HEADER_MARS_h_\n#ifndef MARS_COMMON_INCLUDES_\n#define MARS_COMMON_INCLUDES_\n#include \"rtwtypes.h\"\n#include \"rtw_continuous.h\"\n#include \"rtw_solver.h\"\n#endif                                 /* MARS_COMMON_INCLUDES_ */\n\n#include \"MARS_types.h\"\n#include <string.h>\n#include \"rt_nonfinite.h\"\n\n/* Macros for accessing real-time model data structure */\n#ifndef rtmGetContStateDisabled\n#define rtmGetContStateDisabled(rtm)   ((rtm)->contStateDisabled)\n#endif\n\n#ifndef rtmSetContStateDisabled\n#define rtmSetContStateDisabled(rtm, val) ((rtm)->contStateDisabled = (val))\n#endif\n\n#ifndef rtmGetContStates\n#define rtmGetContStates(rtm)          ((rtm)->contStates)\n#endif\n\n#ifndef rtmSetContStates\n#define rtmSetContStates(rtm, val)     ((rtm)->contStates = (val))\n#endif\n\n#ifndef rtmGetContTimeOutputInconsistentWithStateAtMajorStepFlag\n#define rtmGetContTimeOutputInconsistentWithStateAtMajorStepFlag(rtm) ((rtm)->CTOutputIncnstWithState)\n#endif\n\n#ifndef rtmSetContTimeOutputInconsistentWithStateAtMajorStepFlag\n#define rtmSetContTimeOutputInconsistentWithStateAtMajorStepFlag(rtm, val) ((rtm)->CTOutputIncnstWithState = (val))\n#endif\n\n#ifndef rtmGetDerivCacheNeedsReset\n#define rtmGetDerivCacheNeedsReset(rtm) ((rtm)->derivCacheNeedsReset)\n#endif\n\n#ifndef rtmSetDerivCacheNeedsReset\n#define rtmSetDerivCacheNeedsReset(rtm, val) ((rtm)->derivCacheNeedsReset = (val))\n#endif\n\n#ifndef rtmGetIntgData\n#define rtmGetIntgData(rtm)            ((rtm)->intgData)\n#endif\n\n#ifndef rtmSetIntgData\n#define rtmSetIntgData(rtm, val)       ((rtm)->intgData = (val))\n#endif\n\n#ifndef rtmGetOdeF\n#define rtmGetOdeF(rtm)                ((rtm)->odeF)\n#endif\n\n#ifndef rtmSetOdeF\n#define rtmSetOdeF(rtm, val)           ((rtm)->odeF = (val))\n#endif\n\n#ifndef rtmGetOdeY\n#define rtmGetOdeY(rtm)                ((rtm)->odeY)\n#endif\n\n#ifndef rtmSetOdeY\n#define rtmSetOdeY(rtm, val)           ((rtm)->odeY = (val))\n#endif\n\n#ifndef rtmGetPeriodicContStateIndices\n#define rtmGetPeriodicContStateIndices(rtm) ((rtm)->periodicContStateIndices)\n#endif\n\n#ifndef rtmSetPeriodicContStateIndices\n#define rtmSetPeriodicContStateIndices(rtm, val) ((rtm)->periodicContStateIndices = (val))\n#endif\n\n#ifndef rtmGetPeriodicContStateRanges\n#define rtmGetPeriodicContStateRanges(rtm) ((rtm)->periodicContStateRanges)\n#endif\n\n#ifndef rtmSetPeriodicContStateRanges\n#define rtmSetPeriodicContStateRanges(rtm, val) ((rtm)->periodicContStateRanges = (val))\n#endif\n\n#ifndef rtmGetZCCacheNeedsReset\n#define rtmGetZCCacheNeedsReset(rtm)   ((rtm)->zCCacheNeedsReset)\n#endif\n\n#ifndef rtmSetZCCacheNeedsReset\n#define rtmSetZCCacheNeedsReset(rtm, val) ((rtm)->zCCacheNeedsReset = (val))\n#endif\n\n#ifndef rtmGetdX\n#define rtmGetdX(rtm)                  ((rtm)->derivs)\n#endif\n\n#ifndef rtmSetdX\n#define rtmSetdX(rtm, val)             ((rtm)->derivs = (val))\n#endif\n\n#ifndef rtmGetErrorStatus\n#define rtmGetErrorStatus(rtm)         ((rtm)->errorStatus)\n#endif\n\n#ifndef rtmSetErrorStatus\n#define rtmSetErrorStatus(rtm, val)    ((rtm)->errorStatus = (val))\n#endif\n\n#ifndef rtmGetStopRequested\n#define rtmGetStopRequested(rtm)       ((rtm)->Timing.stopRequestedFlag)\n#endif\n\n#ifndef rtmSetStopRequested\n#define rtmSetStopRequested(rtm, val)  ((rtm)->Timing.stopRequestedFlag = (val))\n#endif\n\n#ifndef rtmGetStopRequestedPtr\n#define rtmGetStopRequestedPtr(rtm)    (&((rtm)->Timing.stopRequestedFlag))\n#endif\n\n#ifndef rtmGetT\n#define rtmGetT(rtm)                   (rtmGetTPtr((rtm))[0])\n#endif\n\n#ifndef rtmGetTPtr\n#define rtmGetTPtr(rtm)                ((rtm)->Timing.t)\n#endif\n\n/* Block signals (default storage) */\ntypedef struct {\n  real_T Merge[4];                     /* '<S74>/Merge' */\n  real_T Product4[9];                  /* '<S61>/Product4' */\n  real_T Output;                       /* '<S5>/Output' */\n  real_T IntegralGain;                 /* '<S35>/Integral Gain' */\n  real_T FilterCoefficient;            /* '<S41>/Filter Coefficient' */\n  real_T Sum2[3];                      /* '<S57>/Sum2' */\n  real_T TmpSignalConversionAtqInport1[4];/* '<S61>/qdot' */\n  real_T Product1[3];                  /* '<S62>/Product1' */\n  real_T Product5[3];                  /* '<S62>/Product5' */\n  real_T Sum2_e[3];                    /* '<S62>/Sum2' */\n  real_T DeadZone[3];                  /* '<S63>/Dead Zone' */\n  real_T Product2[3];                  /* '<S64>/Product2' */\n  real_T Merge_j;                      /* '<S104>/Merge' */\n  real_T Merge_j2;                     /* '<S108>/Merge' */\n} B_MARS_T;\n\n/* Block states (default storage) for system '<Root>' */\ntypedef struct {\n  real_T NextOutput;                   /* '<S5>/White Noise' */\n  real_T Product2_DWORK4[9];           /* '<S64>/Product2' */\n  uint32_T RandSeed;                   /* '<S5>/White Noise' */\n  int_T p1_IWORK;                      /* '<S62>/p1' */\n  int_T q_IWORK;                       /* '<S61>/q' */\n  int_T pqr_IWORK;                     /* '<S57>/p,q,r ' */\n  int_T p_IWORK;                       /* '<S62>/p' */\n  int8_T If_ActiveSubsystem;           /* '<S74>/If' */\n  int8_T If_ActiveSubsystem_h;         /* '<S73>/If' */\n  int8_T If1_ActiveSubsystem;          /* '<S103>/If1' */\n  int8_T If1_ActiveSubsystem_l;        /* '<S126>/If1' */\n  int8_T If_ActiveSubsystem_c;         /* '<S104>/If' */\n  int8_T If_ActiveSubsystem_c0;        /* '<S108>/If' */\n} DW_MARS_T;\n\n/* Continuous states (default storage) */\ntypedef struct {\n  real_T p1_CSTATE[3];                 /* '<S62>/p1' */\n  real_T q_CSTATE[4];                  /* '<S61>/q' */\n  real_T Filter_CSTATE;                /* '<S33>/Filter' */\n  real_T Integrator_CSTATE;            /* '<S38>/Integrator' */\n  real_T Integrator_CSTATE_f;          /* '<S65>/Integrator' */\n  real_T ubvbwb_CSTATE[3];             /* '<S63>/ub,vb,wb' */\n  real_T pqr_CSTATE[3];                /* '<S57>/p,q,r ' */\n  real_T p_CSTATE[3];                  /* '<S62>/p' */\n} X_MARS_T;\n\n/* State derivatives (default storage) */\ntypedef struct {\n  real_T p1_CSTATE[3];                 /* '<S62>/p1' */\n  real_T q_CSTATE[4];                  /* '<S61>/q' */\n  real_T Filter_CSTATE;                /* '<S33>/Filter' */\n  real_T Integrator_CSTATE;            /* '<S38>/Integrator' */\n  real_T Integrator_CSTATE_f;          /* '<S65>/Integrator' */\n  real_T ubvbwb_CSTATE[3];             /* '<S63>/ub,vb,wb' */\n  real_T pqr_CSTATE[3];                /* '<S57>/p,q,r ' */\n  real_T p_CSTATE[3];                  /* '<S62>/p' */\n} XDot_MARS_T;\n\n/* State disabled  */\ntypedef struct {\n  boolean_T p1_CSTATE[3];              /* '<S62>/p1' */\n  boolean_T q_CSTATE[4];               /* '<S61>/q' */\n  boolean_T Filter_CSTATE;             /* '<S33>/Filter' */\n  boolean_T Integrator_CSTATE;         /* '<S38>/Integrator' */\n  boolean_T Integrator_CSTATE_f;       /* '<S65>/Integrator' */\n  boolean_T ubvbwb_CSTATE[3];          /* '<S63>/ub,vb,wb' */\n  boolean_T pqr_CSTATE[3];             /* '<S57>/p,q,r ' */\n  boolean_T p_CSTATE[3];               /* '<S62>/p' */\n} XDis_MARS_T;\n\n/* Invariant block signals (default storage) */\ntypedef struct {\n  const real_T Product2[9];            /* '<S61>/Product2' */\n  const real_T Selector[9];            /* '<S64>/Selector' */\n  const real_T Selector2[9];           /* '<S64>/Selector2' */\n  const real_T Abs2[9];                /* '<S153>/Abs2' */\n  const real_T Product_n[3];           /* '<S128>/Product' */\n  const real_T Product_l[3];           /* '<S130>/Product' */\n  const real_T Product_d[3];           /* '<S129>/Product' */\n  const real_T Add_o;                  /* '<S147>/Add' */\n  const real_T Add_jx;                 /* '<S148>/Add' */\n  const real_T Add_n;                  /* '<S149>/Add' */\n} ConstB_MARS_T;\n\n#ifndef ODE3_INTG\n#define ODE3_INTG\n\n/* ODE3 Integration Data */\ntypedef struct {\n  real_T *y;                           /* output */\n  real_T *f[3];                        /* derivatives */\n} ODE3_IntgData;\n\n#endif\n\n/* Constant parameters (default storage) */\ntypedef struct {\n  /* Pooled Parameter (Expression: -eye(3))\n   * Referenced by:\n   *   '<S115>/Bias1'\n   *   '<S153>/Bias1'\n   */\n  real_T pooled5[9];\n} ConstP_MARS_T;\n\n/* Real-time Model Data Structure */\nstruct tag_RTM_MARS_T {\n  const char_T *errorStatus;\n  RTWSolverInfo solverInfo;\n  X_MARS_T *contStates;\n  int_T *periodicContStateIndices;\n  real_T *periodicContStateRanges;\n  real_T *derivs;\n  boolean_T *contStateDisabled;\n  boolean_T zCCacheNeedsReset;\n  boolean_T derivCacheNeedsReset;\n  boolean_T CTOutputIncnstWithState;\n  real_T odeY[19];\n  real_T odeF[3][19];\n  ODE3_IntgData intgData;\n\n  /*\n   * Sizes:\n   * The following substructure contains sizes information\n   * for many of the model attributes such as inputs, outputs,\n   * dwork, sample times, etc.\n   */\n  struct {\n    int_T numContStates;\n    int_T numPeriodicContStates;\n    int_T numSampTimes;\n  } Sizes;\n\n  /*\n   * Timing:\n   * The following substructure contains information regarding\n   * the timing information for the model.\n   */\n  struct {\n    uint32_T clockTick0;\n    time_T stepSize0;\n    uint32_T clockTick1;\n    boolean_T firstInitCondFlag;\n    struct {\n      uint8_T TID[3];\n    } TaskCounters;\n\n    SimTimeStep simTimeStep;\n    boolean_T stopRequestedFlag;\n    time_T *t;\n    time_T tArray[3];\n  } Timing;\n};\n\n/* Block signals (default storage) */\nextern B_MARS_T MARS_B;\n\n/* Continuous states (default storage) */\nextern X_MARS_T MARS_X;\n\n/* Block states (default storage) */\nextern DW_MARS_T MARS_DW;\nextern const ConstB_MARS_T MARS_ConstB;/* constant block i/o */\n\n/* Constant parameters (default storage) */\nextern const ConstP_MARS_T MARS_ConstP;\n\n/* Model entry point functions */\nextern void MARS_initialize(void);\nextern void MARS_step(void);\nextern void MARS_terminate(void);\n\n/* Real-time Model object */\nextern RT_MODEL_MARS_T *const MARS_M;\n\n/*-\n * These blocks were eliminated from the model due to optimizations:\n *\n * Block '<S1>/Constant' : Unused code path elimination\n * Block '<S2>/Display' : Unused code path elimination\n * Block '<S2>/Scope' : Unused code path elimination\n * Block '<S2>/Scope1' : Unused code path elimination\n * Block '<S57>/Math Function1' : Unused code path elimination\n * Block '<S57>/Product1' : Unused code path elimination\n * Block '<S57>/Sum1' : Unused code path elimination\n * Block '<S68>/Unit Conversion' : Unused code path elimination\n * Block '<S69>/Unit Conversion' : Unused code path elimination\n * Block '<S4>/Height' : Unused code path elimination\n * Block '<S4>/Index' : Unused code path elimination\n * Block '<S58>/Divide' : Unused code path elimination\n * Block '<S58>/Exp' : Unused code path elimination\n * Block '<S58>/Gamma*R' : Unused code path elimination\n * Block '<S58>/Height Limiter' : Unused code path elimination\n * Block '<S58>/Multiply' : Unused code path elimination\n * Block '<S58>/Pres Lapse' : Unused code path elimination\n * Block '<S58>/R' : Unused code path elimination\n * Block '<S58>/Square Root' : Unused code path elimination\n * Block '<S58>/Sum' : Unused code path elimination\n * Block '<S58>/Surface Temp' : Unused code path elimination\n * Block '<S58>/TempLapse' : Unused code path elimination\n * Block '<S3>/Rate Transition' : Eliminated since input and output rates are identical\n * Block '<S88>/Reshape (9) to [3x3] column-major' : Reshape block reduction\n * Block '<S99>/Reshape (9) to [3x3] column-major' : Reshape block reduction\n * Block '<S102>/Reshape' : Reshape block reduction\n * Block '<S102>/Reshape1' : Reshape block reduction\n * Block '<S102>/Reshape2' : Reshape block reduction\n * Block '<S115>/Reshape' : Reshape block reduction\n * Block '<S74>/Reshape 3x3 -> 9' : Reshape block reduction\n * Block '<S153>/Reshape' : Reshape block reduction\n * Block '<S160>/Reshape' : Reshape block reduction\n * Block '<S171>/Reshape (9) to [3x3] column-major' : Reshape block reduction\n * Block '<S175>/Reshape (9) to [3x3] column-major' : Reshape block reduction\n * Block '<S192>/Reshape1' : Reshape block reduction\n * Block '<S192>/Reshape2' : Reshape block reduction\n * Block '<S193>/Reshape1' : Reshape block reduction\n * Block '<S193>/Reshape2' : Reshape block reduction\n * Block '<S64>/Reshape' : Reshape block reduction\n * Block '<S64>/Reshape1' : Reshape block reduction\n * Block '<S196>/Reshape (9) to [3x3] column-major' : Reshape block reduction\n */\n\n/*-\n * The generated code includes comments that allow you to trace directly\n * back to the appropriate location in the model.  The basic format\n * is <system>/block_name, where system is the system number (uniquely\n * assigned by Simulink) and block_name is the name of the block.\n *\n * Use the MATLAB hilite_system command to trace the generated code back\n * to the model.  For example,\n *\n * hilite_system('<S3>')    - opens system 3\n * hilite_system('<S3>/Kp') - opens and selects block Kp which resides in S3\n *\n * Here is the system hierarchy for this model\n *\n * '<Root>' : 'MARS'\n * '<S1>'   : 'MARS/Altimeter'\n * '<S2>'   : 'MARS/Altitude Hold Control'\n * '<S3>'   : 'MARS/FlightGear Preconfigured 6DoF Animation'\n * '<S4>'   : 'MARS/M.A.R.S.'\n * '<S5>'   : 'MARS/Altimeter/Band-Limited White Noise'\n * '<S6>'   : 'MARS/Altitude Hold Control/PID Controller'\n * '<S7>'   : 'MARS/Altitude Hold Control/PID Controller/Anti-windup'\n * '<S8>'   : 'MARS/Altitude Hold Control/PID Controller/D Gain'\n * '<S9>'   : 'MARS/Altitude Hold Control/PID Controller/Filter'\n * '<S10>'  : 'MARS/Altitude Hold Control/PID Controller/Filter ICs'\n * '<S11>'  : 'MARS/Altitude Hold Control/PID Controller/I Gain'\n * '<S12>'  : 'MARS/Altitude Hold Control/PID Controller/Ideal P Gain'\n * '<S13>'  : 'MARS/Altitude Hold Control/PID Controller/Ideal P Gain Fdbk'\n * '<S14>'  : 'MARS/Altitude Hold Control/PID Controller/Integrator'\n * '<S15>'  : 'MARS/Altitude Hold Control/PID Controller/Integrator ICs'\n * '<S16>'  : 'MARS/Altitude Hold Control/PID Controller/N Copy'\n * '<S17>'  : 'MARS/Altitude Hold Control/PID Controller/N Gain'\n * '<S18>'  : 'MARS/Altitude Hold Control/PID Controller/P Copy'\n * '<S19>'  : 'MARS/Altitude Hold Control/PID Controller/Parallel P Gain'\n * '<S20>'  : 'MARS/Altitude Hold Control/PID Controller/Reset Signal'\n * '<S21>'  : 'MARS/Altitude Hold Control/PID Controller/Saturation'\n * '<S22>'  : 'MARS/Altitude Hold Control/PID Controller/Saturation Fdbk'\n * '<S23>'  : 'MARS/Altitude Hold Control/PID Controller/Sum'\n * '<S24>'  : 'MARS/Altitude Hold Control/PID Controller/Sum Fdbk'\n * '<S25>'  : 'MARS/Altitude Hold Control/PID Controller/Tracking Mode'\n * '<S26>'  : 'MARS/Altitude Hold Control/PID Controller/Tracking Mode Sum'\n * '<S27>'  : 'MARS/Altitude Hold Control/PID Controller/Tsamp - Integral'\n * '<S28>'  : 'MARS/Altitude Hold Control/PID Controller/Tsamp - Ngain'\n * '<S29>'  : 'MARS/Altitude Hold Control/PID Controller/postSat Signal'\n * '<S30>'  : 'MARS/Altitude Hold Control/PID Controller/preSat Signal'\n * '<S31>'  : 'MARS/Altitude Hold Control/PID Controller/Anti-windup/Passthrough'\n * '<S32>'  : 'MARS/Altitude Hold Control/PID Controller/D Gain/Internal Parameters'\n * '<S33>'  : 'MARS/Altitude Hold Control/PID Controller/Filter/Cont. Filter'\n * '<S34>'  : 'MARS/Altitude Hold Control/PID Controller/Filter ICs/Internal IC - Filter'\n * '<S35>'  : 'MARS/Altitude Hold Control/PID Controller/I Gain/Internal Parameters'\n * '<S36>'  : 'MARS/Altitude Hold Control/PID Controller/Ideal P Gain/Passthrough'\n * '<S37>'  : 'MARS/Altitude Hold Control/PID Controller/Ideal P Gain Fdbk/Disabled'\n * '<S38>'  : 'MARS/Altitude Hold Control/PID Controller/Integrator/Continuous'\n * '<S39>'  : 'MARS/Altitude Hold Control/PID Controller/Integrator ICs/Internal IC'\n * '<S40>'  : 'MARS/Altitude Hold Control/PID Controller/N Copy/Disabled'\n * '<S41>'  : 'MARS/Altitude Hold Control/PID Controller/N Gain/Internal Parameters'\n * '<S42>'  : 'MARS/Altitude Hold Control/PID Controller/P Copy/Disabled'\n * '<S43>'  : 'MARS/Altitude Hold Control/PID Controller/Parallel P Gain/Internal Parameters'\n * '<S44>'  : 'MARS/Altitude Hold Control/PID Controller/Reset Signal/Disabled'\n * '<S45>'  : 'MARS/Altitude Hold Control/PID Controller/Saturation/Enabled'\n * '<S46>'  : 'MARS/Altitude Hold Control/PID Controller/Saturation Fdbk/Disabled'\n * '<S47>'  : 'MARS/Altitude Hold Control/PID Controller/Sum/Sum_PID'\n * '<S48>'  : 'MARS/Altitude Hold Control/PID Controller/Sum Fdbk/Disabled'\n * '<S49>'  : 'MARS/Altitude Hold Control/PID Controller/Tracking Mode/Disabled'\n * '<S50>'  : 'MARS/Altitude Hold Control/PID Controller/Tracking Mode Sum/Passthrough'\n * '<S51>'  : 'MARS/Altitude Hold Control/PID Controller/Tsamp - Integral/Passthrough'\n * '<S52>'  : 'MARS/Altitude Hold Control/PID Controller/Tsamp - Ngain/Passthrough'\n * '<S53>'  : 'MARS/Altitude Hold Control/PID Controller/postSat Signal/Forward_Path'\n * '<S54>'  : 'MARS/Altitude Hold Control/PID Controller/preSat Signal/Forward_Path'\n * '<S55>'  : 'MARS/FlightGear Preconfigured 6DoF Animation/Angle Conversion'\n * '<S56>'  : 'MARS/FlightGear Preconfigured 6DoF Animation/Angle Conversion1'\n * '<S57>'  : 'MARS/M.A.R.S./6DOF ECEF (Quaternion)'\n * '<S58>'  : 'MARS/M.A.R.S./Mars Atmospheric Model'\n * '<S59>'  : 'MARS/M.A.R.S./Subsystem1'\n * '<S60>'  : 'MARS/M.A.R.S./6DOF ECEF (Quaternion)/Angle Conversion'\n * '<S61>'  : 'MARS/M.A.R.S./6DOF ECEF (Quaternion)/Calculate DCM & Euler Angles'\n * '<S62>'  : 'MARS/M.A.R.S./6DOF ECEF (Quaternion)/Calculate Position in EI '\n * '<S63>'  : 'MARS/M.A.R.S./6DOF ECEF (Quaternion)/Calculate Velocity in Body Axes'\n * '<S64>'  : 'MARS/M.A.R.S./6DOF ECEF (Quaternion)/Calculate omega_dot'\n * '<S65>'  : 'MARS/M.A.R.S./6DOF ECEF (Quaternion)/Celestial Longitude of Greenwich'\n * '<S66>'  : 'MARS/M.A.R.S./6DOF ECEF (Quaternion)/Determine Force,  Mass & Inertia'\n * '<S67>'  : 'MARS/M.A.R.S./6DOF ECEF (Quaternion)/ECEF to Inertial'\n * '<S68>'  : 'MARS/M.A.R.S./6DOF ECEF (Quaternion)/Velocity Conversion'\n * '<S69>'  : 'MARS/M.A.R.S./6DOF ECEF (Quaternion)/Velocity Conversion2'\n * '<S70>'  : 'MARS/M.A.R.S./6DOF ECEF (Quaternion)/w_ned'\n * '<S71>'  : 'MARS/M.A.R.S./6DOF ECEF (Quaternion)/Calculate DCM & Euler Angles/Direction Cosine Matrix ECEF to NED'\n * '<S72>'  : 'MARS/M.A.R.S./6DOF ECEF (Quaternion)/Calculate DCM & Euler Angles/Direction Cosine Matrix ECEF to NED1'\n * '<S73>'  : 'MARS/M.A.R.S./6DOF ECEF (Quaternion)/Calculate DCM & Euler Angles/Direction Cosine Matrix to Rotation Angles'\n * '<S74>'  : 'MARS/M.A.R.S./6DOF ECEF (Quaternion)/Calculate DCM & Euler Angles/Direction Cosine Matrix  to Quaternions'\n * '<S75>'  : 'MARS/M.A.R.S./6DOF ECEF (Quaternion)/Calculate DCM & Euler Angles/Quaternions to  Direction Cosine Matrix'\n * '<S76>'  : 'MARS/M.A.R.S./6DOF ECEF (Quaternion)/Calculate DCM & Euler Angles/Rotation Angles to Direction Cosine Matrix'\n * '<S77>'  : 'MARS/M.A.R.S./6DOF ECEF (Quaternion)/Calculate DCM & Euler Angles/qdot'\n * '<S78>'  : 'MARS/M.A.R.S./6DOF ECEF (Quaternion)/Calculate DCM & Euler Angles/Direction Cosine Matrix ECEF to NED/A11'\n * '<S79>'  : 'MARS/M.A.R.S./6DOF ECEF (Quaternion)/Calculate DCM & Euler Angles/Direction Cosine Matrix ECEF to NED/A12'\n * '<S80>'  : 'MARS/M.A.R.S./6DOF ECEF (Quaternion)/Calculate DCM & Euler Angles/Direction Cosine Matrix ECEF to NED/A13'\n * '<S81>'  : 'MARS/M.A.R.S./6DOF ECEF (Quaternion)/Calculate DCM & Euler Angles/Direction Cosine Matrix ECEF to NED/A21'\n * '<S82>'  : 'MARS/M.A.R.S./6DOF ECEF (Quaternion)/Calculate DCM & Euler Angles/Direction Cosine Matrix ECEF to NED/A22'\n * '<S83>'  : 'MARS/M.A.R.S./6DOF ECEF (Quaternion)/Calculate DCM & Euler Angles/Direction Cosine Matrix ECEF to NED/A23'\n * '<S84>'  : 'MARS/M.A.R.S./6DOF ECEF (Quaternion)/Calculate DCM & Euler Angles/Direction Cosine Matrix ECEF to NED/A31'\n * '<S85>'  : 'MARS/M.A.R.S./6DOF ECEF (Quaternion)/Calculate DCM & Euler Angles/Direction Cosine Matrix ECEF to NED/A32'\n * '<S86>'  : 'MARS/M.A.R.S./6DOF ECEF (Quaternion)/Calculate DCM & Euler Angles/Direction Cosine Matrix ECEF to NED/A33'\n * '<S87>'  : 'MARS/M.A.R.S./6DOF ECEF (Quaternion)/Calculate DCM & Euler Angles/Direction Cosine Matrix ECEF to NED/Angle Conversion'\n * '<S88>'  : 'MARS/M.A.R.S./6DOF ECEF (Quaternion)/Calculate DCM & Euler Angles/Direction Cosine Matrix ECEF to NED/Create Transformation Matrix'\n * '<S89>'  : 'MARS/M.A.R.S./6DOF ECEF (Quaternion)/Calculate DCM & Euler Angles/Direction Cosine Matrix ECEF to NED1/A11'\n * '<S90>'  : 'MARS/M.A.R.S./6DOF ECEF (Quaternion)/Calculate DCM & Euler Angles/Direction Cosine Matrix ECEF to NED1/A12'\n * '<S91>'  : 'MARS/M.A.R.S./6DOF ECEF (Quaternion)/Calculate DCM & Euler Angles/Direction Cosine Matrix ECEF to NED1/A13'\n * '<S92>'  : 'MARS/M.A.R.S./6DOF ECEF (Quaternion)/Calculate DCM & Euler Angles/Direction Cosine Matrix ECEF to NED1/A21'\n * '<S93>'  : 'MARS/M.A.R.S./6DOF ECEF (Quaternion)/Calculate DCM & Euler Angles/Direction Cosine Matrix ECEF to NED1/A22'\n * '<S94>'  : 'MARS/M.A.R.S./6DOF ECEF (Quaternion)/Calculate DCM & Euler Angles/Direction Cosine Matrix ECEF to NED1/A23'\n * '<S95>'  : 'MARS/M.A.R.S./6DOF ECEF (Quaternion)/Calculate DCM & Euler Angles/Direction Cosine Matrix ECEF to NED1/A31'\n * '<S96>'  : 'MARS/M.A.R.S./6DOF ECEF (Quaternion)/Calculate DCM & Euler Angles/Direction Cosine Matrix ECEF to NED1/A32'\n * '<S97>'  : 'MARS/M.A.R.S./6DOF ECEF (Quaternion)/Calculate DCM & Euler Angles/Direction Cosine Matrix ECEF to NED1/A33'\n * '<S98>'  : 'MARS/M.A.R.S./6DOF ECEF (Quaternion)/Calculate DCM & Euler Angles/Direction Cosine Matrix ECEF to NED1/Angle Conversion'\n * '<S99>'  : 'MARS/M.A.R.S./6DOF ECEF (Quaternion)/Calculate DCM & Euler Angles/Direction Cosine Matrix ECEF to NED1/Create Transformation Matrix'\n * '<S100>' : 'MARS/M.A.R.S./6DOF ECEF (Quaternion)/Calculate DCM & Euler Angles/Direction Cosine Matrix to Rotation Angles/AxisRotDefault'\n * '<S101>' : 'MARS/M.A.R.S./6DOF ECEF (Quaternion)/Calculate DCM & Euler Angles/Direction Cosine Matrix to Rotation Angles/AxisRotZeroR3'\n * '<S102>' : 'MARS/M.A.R.S./6DOF ECEF (Quaternion)/Calculate DCM & Euler Angles/Direction Cosine Matrix to Rotation Angles/Get DCM Values'\n * '<S103>' : 'MARS/M.A.R.S./6DOF ECEF (Quaternion)/Calculate DCM & Euler Angles/Direction Cosine Matrix to Rotation Angles/Validate DCM'\n * '<S104>' : 'MARS/M.A.R.S./6DOF ECEF (Quaternion)/Calculate DCM & Euler Angles/Direction Cosine Matrix to Rotation Angles/AxisRotDefault/Protect asincos input'\n * '<S105>' : 'MARS/M.A.R.S./6DOF ECEF (Quaternion)/Calculate DCM & Euler Angles/Direction Cosine Matrix to Rotation Angles/AxisRotDefault/Protect asincos input/If Action Subsystem'\n * '<S106>' : 'MARS/M.A.R.S./6DOF ECEF (Quaternion)/Calculate DCM & Euler Angles/Direction Cosine Matrix to Rotation Angles/AxisRotDefault/Protect asincos input/If Action Subsystem1'\n * '<S107>' : 'MARS/M.A.R.S./6DOF ECEF (Quaternion)/Calculate DCM & Euler Angles/Direction Cosine Matrix to Rotation Angles/AxisRotDefault/Protect asincos input/If Action Subsystem2'\n * '<S108>' : 'MARS/M.A.R.S./6DOF ECEF (Quaternion)/Calculate DCM & Euler Angles/Direction Cosine Matrix to Rotation Angles/AxisRotZeroR3/Protect asincos input'\n * '<S109>' : 'MARS/M.A.R.S./6DOF ECEF (Quaternion)/Calculate DCM & Euler Angles/Direction Cosine Matrix to Rotation Angles/AxisRotZeroR3/Protect asincos input/If Action Subsystem'\n * '<S110>' : 'MARS/M.A.R.S./6DOF ECEF (Quaternion)/Calculate DCM & Euler Angles/Direction Cosine Matrix to Rotation Angles/AxisRotZeroR3/Protect asincos input/If Action Subsystem1'\n * '<S111>' : 'MARS/M.A.R.S./6DOF ECEF (Quaternion)/Calculate DCM & Euler Angles/Direction Cosine Matrix to Rotation Angles/AxisRotZeroR3/Protect asincos input/If Action Subsystem2'\n * '<S112>' : 'MARS/M.A.R.S./6DOF ECEF (Quaternion)/Calculate DCM & Euler Angles/Direction Cosine Matrix to Rotation Angles/Validate DCM/If Warning//Error'\n * '<S113>' : 'MARS/M.A.R.S./6DOF ECEF (Quaternion)/Calculate DCM & Euler Angles/Direction Cosine Matrix to Rotation Angles/Validate DCM/If Warning//Error/Else If Not Orthogonal'\n * '<S114>' : 'MARS/M.A.R.S./6DOF ECEF (Quaternion)/Calculate DCM & Euler Angles/Direction Cosine Matrix to Rotation Angles/Validate DCM/If Warning//Error/If Not Proper'\n * '<S115>' : 'MARS/M.A.R.S./6DOF ECEF (Quaternion)/Calculate DCM & Euler Angles/Direction Cosine Matrix to Rotation Angles/Validate DCM/If Warning//Error/isNotOrthogonal'\n * '<S116>' : 'MARS/M.A.R.S./6DOF ECEF (Quaternion)/Calculate DCM & Euler Angles/Direction Cosine Matrix to Rotation Angles/Validate DCM/If Warning//Error/isNotProper'\n * '<S117>' : 'MARS/M.A.R.S./6DOF ECEF (Quaternion)/Calculate DCM & Euler Angles/Direction Cosine Matrix to Rotation Angles/Validate DCM/If Warning//Error/Else If Not Orthogonal/Error'\n * '<S118>' : 'MARS/M.A.R.S./6DOF ECEF (Quaternion)/Calculate DCM & Euler Angles/Direction Cosine Matrix to Rotation Angles/Validate DCM/If Warning//Error/Else If Not Orthogonal/Warning'\n * '<S119>' : 'MARS/M.A.R.S./6DOF ECEF (Quaternion)/Calculate DCM & Euler Angles/Direction Cosine Matrix to Rotation Angles/Validate DCM/If Warning//Error/If Not Proper/Error'\n * '<S120>' : 'MARS/M.A.R.S./6DOF ECEF (Quaternion)/Calculate DCM & Euler Angles/Direction Cosine Matrix to Rotation Angles/Validate DCM/If Warning//Error/If Not Proper/Warning'\n * '<S121>' : 'MARS/M.A.R.S./6DOF ECEF (Quaternion)/Calculate DCM & Euler Angles/Direction Cosine Matrix to Rotation Angles/Validate DCM/If Warning//Error/isNotOrthogonal/transpose*dcm ~= eye(3)'\n * '<S122>' : 'MARS/M.A.R.S./6DOF ECEF (Quaternion)/Calculate DCM & Euler Angles/Direction Cosine Matrix to Rotation Angles/Validate DCM/If Warning//Error/isNotProper/Determinant of 3x3 Matrix'\n * '<S123>' : 'MARS/M.A.R.S./6DOF ECEF (Quaternion)/Calculate DCM & Euler Angles/Direction Cosine Matrix to Rotation Angles/Validate DCM/If Warning//Error/isNotProper/determinant does not equal 1'\n * '<S124>' : 'MARS/M.A.R.S./6DOF ECEF (Quaternion)/Calculate DCM & Euler Angles/Direction Cosine Matrix  to Quaternions/Negative Trace'\n * '<S125>' : 'MARS/M.A.R.S./6DOF ECEF (Quaternion)/Calculate DCM & Euler Angles/Direction Cosine Matrix  to Quaternions/Positive Trace'\n * '<S126>' : 'MARS/M.A.R.S./6DOF ECEF (Quaternion)/Calculate DCM & Euler Angles/Direction Cosine Matrix  to Quaternions/Validate DCM'\n * '<S127>' : 'MARS/M.A.R.S./6DOF ECEF (Quaternion)/Calculate DCM & Euler Angles/Direction Cosine Matrix  to Quaternions/trace(DCM)'\n * '<S128>' : 'MARS/M.A.R.S./6DOF ECEF (Quaternion)/Calculate DCM & Euler Angles/Direction Cosine Matrix  to Quaternions/Negative Trace/Maximum Value at DCM(1,1)'\n * '<S129>' : 'MARS/M.A.R.S./6DOF ECEF (Quaternion)/Calculate DCM & Euler Angles/Direction Cosine Matrix  to Quaternions/Negative Trace/Maximum Value at DCM(2,2)'\n * '<S130>' : 'MARS/M.A.R.S./6DOF ECEF (Quaternion)/Calculate DCM & Euler Angles/Direction Cosine Matrix  to Quaternions/Negative Trace/Maximum Value at DCM(3,3)'\n * '<S131>' : 'MARS/M.A.R.S./6DOF ECEF (Quaternion)/Calculate DCM & Euler Angles/Direction Cosine Matrix  to Quaternions/Negative Trace/diag(DCM)'\n * '<S132>' : 'MARS/M.A.R.S./6DOF ECEF (Quaternion)/Calculate DCM & Euler Angles/Direction Cosine Matrix  to Quaternions/Negative Trace/Maximum Value at DCM(1,1)/cos(phi)sin(theta)cos(psi) + sin(phi)sin(psi) -sin(theta)'\n * '<S133>' : 'MARS/M.A.R.S./6DOF ECEF (Quaternion)/Calculate DCM & Euler Angles/Direction Cosine Matrix  to Quaternions/Negative Trace/Maximum Value at DCM(1,1)/cos(theta)sin(phi) - (cos(phi)sin(theta)sin(psi) - sin(phi)cos(psi))'\n * '<S134>' : 'MARS/M.A.R.S./6DOF ECEF (Quaternion)/Calculate DCM & Euler Angles/Direction Cosine Matrix  to Quaternions/Negative Trace/Maximum Value at DCM(1,1)/cos(theta)sin(psi) + (sin(phi)sin(theta)cos(psi) - cos(phi)sin(psi))'\n * '<S135>' : 'MARS/M.A.R.S./6DOF ECEF (Quaternion)/Calculate DCM & Euler Angles/Direction Cosine Matrix  to Quaternions/Negative Trace/Maximum Value at DCM(1,1)/if s~=0; s=0.5//s'\n * '<S136>' : 'MARS/M.A.R.S./6DOF ECEF (Quaternion)/Calculate DCM & Euler Angles/Direction Cosine Matrix  to Quaternions/Negative Trace/Maximum Value at DCM(1,1)/u(1) -(u(5)+u(9)) +1'\n * '<S137>' : 'MARS/M.A.R.S./6DOF ECEF (Quaternion)/Calculate DCM & Euler Angles/Direction Cosine Matrix  to Quaternions/Negative Trace/Maximum Value at DCM(2,2)/cos(phi)sin(theta)cos(psi) + sin(phi)sin(psi) +sin(theta)'\n * '<S138>' : 'MARS/M.A.R.S./6DOF ECEF (Quaternion)/Calculate DCM & Euler Angles/Direction Cosine Matrix  to Quaternions/Negative Trace/Maximum Value at DCM(2,2)/cos(theta)sin(phi) + (cos(phi)sin(theta)sin(psi) - sin(phi)cos(psi))'\n * '<S139>' : 'MARS/M.A.R.S./6DOF ECEF (Quaternion)/Calculate DCM & Euler Angles/Direction Cosine Matrix  to Quaternions/Negative Trace/Maximum Value at DCM(2,2)/cos(theta)sin(psi) + (sin(phi)sin(theta)cos(psi) - cos(phi)sin(psi))'\n * '<S140>' : 'MARS/M.A.R.S./6DOF ECEF (Quaternion)/Calculate DCM & Euler Angles/Direction Cosine Matrix  to Quaternions/Negative Trace/Maximum Value at DCM(2,2)/if s~=0; s=0.5//s'\n * '<S141>' : 'MARS/M.A.R.S./6DOF ECEF (Quaternion)/Calculate DCM & Euler Angles/Direction Cosine Matrix  to Quaternions/Negative Trace/Maximum Value at DCM(2,2)/u(5) -(u(1)+u(9)) +1'\n * '<S142>' : 'MARS/M.A.R.S./6DOF ECEF (Quaternion)/Calculate DCM & Euler Angles/Direction Cosine Matrix  to Quaternions/Negative Trace/Maximum Value at DCM(3,3)/cos(phi)sin(theta)cos(psi) + sin(phi)sin(psi) -sin(theta)'\n * '<S143>' : 'MARS/M.A.R.S./6DOF ECEF (Quaternion)/Calculate DCM & Euler Angles/Direction Cosine Matrix  to Quaternions/Negative Trace/Maximum Value at DCM(3,3)/cos(theta)sin(phi) + (cos(phi)sin(theta)sin(psi) - sin(phi)cos(psi))'\n * '<S144>' : 'MARS/M.A.R.S./6DOF ECEF (Quaternion)/Calculate DCM & Euler Angles/Direction Cosine Matrix  to Quaternions/Negative Trace/Maximum Value at DCM(3,3)/cos(theta)sin(psi) - (sin(phi)sin(theta)cos(psi) - cos(phi)sin(psi))'\n * '<S145>' : 'MARS/M.A.R.S./6DOF ECEF (Quaternion)/Calculate DCM & Euler Angles/Direction Cosine Matrix  to Quaternions/Negative Trace/Maximum Value at DCM(3,3)/if s~=0; s=0.5//s'\n * '<S146>' : 'MARS/M.A.R.S./6DOF ECEF (Quaternion)/Calculate DCM & Euler Angles/Direction Cosine Matrix  to Quaternions/Negative Trace/Maximum Value at DCM(3,3)/u(9) -(u(1)+u(5)) +1'\n * '<S147>' : 'MARS/M.A.R.S./6DOF ECEF (Quaternion)/Calculate DCM & Euler Angles/Direction Cosine Matrix  to Quaternions/Positive Trace/cos(phi)sin(theta)cos(psi) + sin(phi)sin(psi) +sin(theta)'\n * '<S148>' : 'MARS/M.A.R.S./6DOF ECEF (Quaternion)/Calculate DCM & Euler Angles/Direction Cosine Matrix  to Quaternions/Positive Trace/cos(theta)sin(phi) - (cos(phi)sin(theta)sin(psi) - sin(phi)cos(psi))'\n * '<S149>' : 'MARS/M.A.R.S./6DOF ECEF (Quaternion)/Calculate DCM & Euler Angles/Direction Cosine Matrix  to Quaternions/Positive Trace/cos(theta)sin(psi) - (sin(phi)sin(theta)cos(psi) - cos(phi)sin(psi))'\n * '<S150>' : 'MARS/M.A.R.S./6DOF ECEF (Quaternion)/Calculate DCM & Euler Angles/Direction Cosine Matrix  to Quaternions/Validate DCM/If Warning//Error'\n * '<S151>' : 'MARS/M.A.R.S./6DOF ECEF (Quaternion)/Calculate DCM & Euler Angles/Direction Cosine Matrix  to Quaternions/Validate DCM/If Warning//Error/Else If Not Orthogonal'\n * '<S152>' : 'MARS/M.A.R.S./6DOF ECEF (Quaternion)/Calculate DCM & Euler Angles/Direction Cosine Matrix  to Quaternions/Validate DCM/If Warning//Error/If Not Proper'\n * '<S153>' : 'MARS/M.A.R.S./6DOF ECEF (Quaternion)/Calculate DCM & Euler Angles/Direction Cosine Matrix  to Quaternions/Validate DCM/If Warning//Error/isNotOrthogonal'\n * '<S154>' : 'MARS/M.A.R.S./6DOF ECEF (Quaternion)/Calculate DCM & Euler Angles/Direction Cosine Matrix  to Quaternions/Validate DCM/If Warning//Error/isNotProper'\n * '<S155>' : 'MARS/M.A.R.S./6DOF ECEF (Quaternion)/Calculate DCM & Euler Angles/Direction Cosine Matrix  to Quaternions/Validate DCM/If Warning//Error/Else If Not Orthogonal/Error'\n * '<S156>' : 'MARS/M.A.R.S./6DOF ECEF (Quaternion)/Calculate DCM & Euler Angles/Direction Cosine Matrix  to Quaternions/Validate DCM/If Warning//Error/Else If Not Orthogonal/Warning'\n * '<S157>' : 'MARS/M.A.R.S./6DOF ECEF (Quaternion)/Calculate DCM & Euler Angles/Direction Cosine Matrix  to Quaternions/Validate DCM/If Warning//Error/If Not Proper/Error'\n * '<S158>' : 'MARS/M.A.R.S./6DOF ECEF (Quaternion)/Calculate DCM & Euler Angles/Direction Cosine Matrix  to Quaternions/Validate DCM/If Warning//Error/If Not Proper/Warning'\n * '<S159>' : 'MARS/M.A.R.S./6DOF ECEF (Quaternion)/Calculate DCM & Euler Angles/Direction Cosine Matrix  to Quaternions/Validate DCM/If Warning//Error/isNotOrthogonal/transpose*dcm ~= eye(3)'\n * '<S160>' : 'MARS/M.A.R.S./6DOF ECEF (Quaternion)/Calculate DCM & Euler Angles/Direction Cosine Matrix  to Quaternions/Validate DCM/If Warning//Error/isNotProper/Determinant of 3x3 Matrix'\n * '<S161>' : 'MARS/M.A.R.S./6DOF ECEF (Quaternion)/Calculate DCM & Euler Angles/Direction Cosine Matrix  to Quaternions/Validate DCM/If Warning//Error/isNotProper/determinant does not equal 1'\n * '<S162>' : 'MARS/M.A.R.S./6DOF ECEF (Quaternion)/Calculate DCM & Euler Angles/Quaternions to  Direction Cosine Matrix/A11'\n * '<S163>' : 'MARS/M.A.R.S./6DOF ECEF (Quaternion)/Calculate DCM & Euler Angles/Quaternions to  Direction Cosine Matrix/A12'\n * '<S164>' : 'MARS/M.A.R.S./6DOF ECEF (Quaternion)/Calculate DCM & Euler Angles/Quaternions to  Direction Cosine Matrix/A13'\n * '<S165>' : 'MARS/M.A.R.S./6DOF ECEF (Quaternion)/Calculate DCM & Euler Angles/Quaternions to  Direction Cosine Matrix/A21'\n * '<S166>' : 'MARS/M.A.R.S./6DOF ECEF (Quaternion)/Calculate DCM & Euler Angles/Quaternions to  Direction Cosine Matrix/A22'\n * '<S167>' : 'MARS/M.A.R.S./6DOF ECEF (Quaternion)/Calculate DCM & Euler Angles/Quaternions to  Direction Cosine Matrix/A23'\n * '<S168>' : 'MARS/M.A.R.S./6DOF ECEF (Quaternion)/Calculate DCM & Euler Angles/Quaternions to  Direction Cosine Matrix/A31'\n * '<S169>' : 'MARS/M.A.R.S./6DOF ECEF (Quaternion)/Calculate DCM & Euler Angles/Quaternions to  Direction Cosine Matrix/A32'\n * '<S170>' : 'MARS/M.A.R.S./6DOF ECEF (Quaternion)/Calculate DCM & Euler Angles/Quaternions to  Direction Cosine Matrix/A33'\n * '<S171>' : 'MARS/M.A.R.S./6DOF ECEF (Quaternion)/Calculate DCM & Euler Angles/Quaternions to  Direction Cosine Matrix/Create 3x3 Matrix'\n * '<S172>' : 'MARS/M.A.R.S./6DOF ECEF (Quaternion)/Calculate DCM & Euler Angles/Quaternions to  Direction Cosine Matrix/Quaternion Normalize'\n * '<S173>' : 'MARS/M.A.R.S./6DOF ECEF (Quaternion)/Calculate DCM & Euler Angles/Quaternions to  Direction Cosine Matrix/Quaternion Normalize/Quaternion Modulus'\n * '<S174>' : 'MARS/M.A.R.S./6DOF ECEF (Quaternion)/Calculate DCM & Euler Angles/Quaternions to  Direction Cosine Matrix/Quaternion Normalize/Quaternion Modulus/Quaternion Norm'\n * '<S175>' : 'MARS/M.A.R.S./6DOF ECEF (Quaternion)/Calculate DCM & Euler Angles/Rotation Angles to Direction Cosine Matrix/Create 3x3 Matrix'\n * '<S176>' : 'MARS/M.A.R.S./6DOF ECEF (Quaternion)/Calculate DCM & Euler Angles/qdot/Quaternion Normalize'\n * '<S177>' : 'MARS/M.A.R.S./6DOF ECEF (Quaternion)/Calculate DCM & Euler Angles/qdot/Quaternion Normalize/Quaternion Modulus'\n * '<S178>' : 'MARS/M.A.R.S./6DOF ECEF (Quaternion)/Calculate DCM & Euler Angles/qdot/Quaternion Normalize/Quaternion Modulus/Quaternion Norm'\n * '<S179>' : 'MARS/M.A.R.S./6DOF ECEF (Quaternion)/Calculate Position in EI /pxwe'\n * '<S180>' : 'MARS/M.A.R.S./6DOF ECEF (Quaternion)/Calculate Position in EI /pxwe/Subsystem'\n * '<S181>' : 'MARS/M.A.R.S./6DOF ECEF (Quaternion)/Calculate Position in EI /pxwe/Subsystem1'\n * '<S182>' : 'MARS/M.A.R.S./6DOF ECEF (Quaternion)/Calculate Velocity in Body Axes/Vbxwb'\n * '<S183>' : 'MARS/M.A.R.S./6DOF ECEF (Quaternion)/Calculate Velocity in Body Axes/wex(wexp)'\n * '<S184>' : 'MARS/M.A.R.S./6DOF ECEF (Quaternion)/Calculate Velocity in Body Axes/wexp'\n * '<S185>' : 'MARS/M.A.R.S./6DOF ECEF (Quaternion)/Calculate Velocity in Body Axes/Vbxwb/Subsystem'\n * '<S186>' : 'MARS/M.A.R.S./6DOF ECEF (Quaternion)/Calculate Velocity in Body Axes/Vbxwb/Subsystem1'\n * '<S187>' : 'MARS/M.A.R.S./6DOF ECEF (Quaternion)/Calculate Velocity in Body Axes/wex(wexp)/Subsystem'\n * '<S188>' : 'MARS/M.A.R.S./6DOF ECEF (Quaternion)/Calculate Velocity in Body Axes/wex(wexp)/Subsystem1'\n * '<S189>' : 'MARS/M.A.R.S./6DOF ECEF (Quaternion)/Calculate Velocity in Body Axes/wexp/Subsystem'\n * '<S190>' : 'MARS/M.A.R.S./6DOF ECEF (Quaternion)/Calculate Velocity in Body Axes/wexp/Subsystem1'\n * '<S191>' : 'MARS/M.A.R.S./6DOF ECEF (Quaternion)/Calculate omega_dot/3x3 Cross Product'\n * '<S192>' : 'MARS/M.A.R.S./6DOF ECEF (Quaternion)/Calculate omega_dot/I x w'\n * '<S193>' : 'MARS/M.A.R.S./6DOF ECEF (Quaternion)/Calculate omega_dot/I x w1'\n * '<S194>' : 'MARS/M.A.R.S./6DOF ECEF (Quaternion)/Calculate omega_dot/3x3 Cross Product/Subsystem'\n * '<S195>' : 'MARS/M.A.R.S./6DOF ECEF (Quaternion)/Calculate omega_dot/3x3 Cross Product/Subsystem1'\n * '<S196>' : 'MARS/M.A.R.S./6DOF ECEF (Quaternion)/ECEF to Inertial/Create 3x3 Matrix'\n * '<S197>' : 'MARS/M.A.R.S./6DOF ECEF (Quaternion)/w_ned/Angle Conversion'\n * '<S198>' : 'MARS/M.A.R.S./6DOF ECEF (Quaternion)/w_ned/M+h'\n * '<S199>' : 'MARS/M.A.R.S./6DOF ECEF (Quaternion)/w_ned/N+h'\n * '<S200>' : 'MARS/M.A.R.S./6DOF ECEF (Quaternion)/w_ned/e2'\n * '<S201>' : 'MARS/M.A.R.S./Subsystem1/Components'\n * '<S202>' : 'MARS/M.A.R.S./Subsystem1/Subsystem'\n */\n#endif                                 /* RTW_HEADER_MARS_h_ */\n"},{"name":"MARS_private.h","type":"header","group":"model","path":"/home/aman/GitHub/flightTestingLab/controls/Ingenuity_Modelling/MATLAB-env/MARS_grt_rtw","tag":"","groupDisplay":"Model files","code":"/*\n * MARS_private.h\n *\n * Academic License - for use in teaching, academic research, and meeting\n * course requirements at degree granting institutions only.  Not for\n * government, commercial, or other organizational use.\n *\n * Code generation for model \"MARS\".\n *\n * Model version              : 1.28\n * Simulink Coder version : 9.7 (R2022a) 13-Nov-2021\n * C source code generated on : Fri Oct 28 08:09:17 2022\n *\n * Target selection: grt.tlc\n * Note: GRT includes extra infrastructure and instrumentation for prototyping\n * Embedded hardware selection: Intel->x86-64 (Windows64)\n * Code generation objective: Execution efficiency\n * Validation result: Not run\n */\n\n#ifndef RTW_HEADER_MARS_private_h_\n#define RTW_HEADER_MARS_private_h_\n#include \"rtwtypes.h\"\n#include \"multiword_types.h\"\n#include \"MARS.h\"\n\n/* Private macros used by the generated code to access rtModel */\n#ifndef rtmSetFirstInitCond\n#define rtmSetFirstInitCond(rtm, val)  ((rtm)->Timing.firstInitCondFlag = (val))\n#endif\n\n#ifndef rtmIsFirstInitCond\n#define rtmIsFirstInitCond(rtm)        ((rtm)->Timing.firstInitCondFlag)\n#endif\n\n#ifndef rtmIsMajorTimeStep\n#define rtmIsMajorTimeStep(rtm)        (((rtm)->Timing.simTimeStep) == MAJOR_TIME_STEP)\n#endif\n\n#ifndef rtmIsMinorTimeStep\n#define rtmIsMinorTimeStep(rtm)        (((rtm)->Timing.simTimeStep) == MINOR_TIME_STEP)\n#endif\n\n#ifndef rtmSetTPtr\n#define rtmSetTPtr(rtm, val)           ((rtm)->Timing.t = (val))\n#endif\n\nextern real_T rt_urand_Upu32_Yd_f_pw_snf(uint32_T *u);\nextern real_T rt_nrand_Upu32_Yd_f_pw_snf(uint32_T *u);\nextern real_T rt_atan2d_snf(real_T u0, real_T u1);\nextern real_T rt_modd_snf(real_T u0, real_T u1);\nextern real_T rt_remd_snf(real_T u0, real_T u1);\nextern real_T rt_powd_snf(real_T u0, real_T u1);\nextern void rt_mrdivide_U1d1x3_U2d_9vOrDY9Z(const real_T u0[3], const real_T u1\n  [9], real_T y[3]);\nextern void MARS_IfActionSubsystem2(real_T rtu_In, real_T *rty_OutOrig);\nextern void MARS_IfNotProper(real_T rtp_action);\nextern void MARS_ElseIfNotOrthogonal(real_T rtp_action);\n\n/* private model entry point functions */\nextern void MARS_derivatives(void);\n\n#endif                                 /* RTW_HEADER_MARS_private_h_ */\n"},{"name":"MARS_types.h","type":"header","group":"model","path":"/home/aman/GitHub/flightTestingLab/controls/Ingenuity_Modelling/MATLAB-env/MARS_grt_rtw","tag":"","groupDisplay":"Model files","code":"/*\n * MARS_types.h\n *\n * Academic License - for use in teaching, academic research, and meeting\n * course requirements at degree granting institutions only.  Not for\n * government, commercial, or other organizational use.\n *\n * Code generation for model \"MARS\".\n *\n * Model version              : 1.28\n * Simulink Coder version : 9.7 (R2022a) 13-Nov-2021\n * C source code generated on : Fri Oct 28 08:09:17 2022\n *\n * Target selection: grt.tlc\n * Note: GRT includes extra infrastructure and instrumentation for prototyping\n * Embedded hardware selection: Intel->x86-64 (Windows64)\n * Code generation objective: Execution efficiency\n * Validation result: Not run\n */\n\n#ifndef RTW_HEADER_MARS_types_h_\n#define RTW_HEADER_MARS_types_h_\n\n/* Model Code Variants */\n\n/* Forward declaration for rtModel */\ntypedef struct tag_RTM_MARS_T RT_MODEL_MARS_T;\n\n#endif                                 /* RTW_HEADER_MARS_types_h_ */\n"},{"name":"MARS_data.c","type":"source","group":"data","path":"/home/aman/GitHub/flightTestingLab/controls/Ingenuity_Modelling/MATLAB-env/MARS_grt_rtw","tag":"","groupDisplay":"Data files","code":"/*\n * MARS_data.c\n *\n * Academic License - for use in teaching, academic research, and meeting\n * course requirements at degree granting institutions only.  Not for\n * government, commercial, or other organizational use.\n *\n * Code generation for model \"MARS\".\n *\n * Model version              : 1.28\n * Simulink Coder version : 9.7 (R2022a) 13-Nov-2021\n * C source code generated on : Fri Oct 28 08:09:17 2022\n *\n * Target selection: grt.tlc\n * Note: GRT includes extra infrastructure and instrumentation for prototyping\n * Embedded hardware selection: Intel->x86-64 (Windows64)\n * Code generation objective: Execution efficiency\n * Validation result: Not run\n */\n\n#include \"MARS.h\"\n\n/* Invariant block signals (default storage) */\nconst ConstB_MARS_T MARS_ConstB = {\n  { -0.82949238588247243, 0.38438233146596967, -0.4052068669455009,\n    0.34537608216871168, 0.92317399403188638, 0.1687161480386685,\n    0.43892794810628633, 0.0, -0.89852226259075252 },/* '<S61>/Product2' */\n\n  { 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0 },/* '<S64>/Selector' */\n\n  { 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0 },/* '<S64>/Selector2' */\n\n  { 1.1102230246251565E-16, 1.3877787807814457E-17, 0.0, 1.3877787807814457E-17,\n    1.1102230246251565E-16, 0.0, 0.0, 0.0, 0.0 },/* '<S153>/Abs2' */\n\n  { 0.95540418704665353, 0.044147846096478795, -0.22088421489473919 },/* '<S128>/Product' */\n\n  { 0.19095541539610336, 0.95540418704665309, -0.22088421489473903 },/* '<S130>/Product' */\n\n  { 0.19095541539610345, 0.044147846096478795, -0.22088421489473928 },/* '<S129>/Product' */\n  -0.84413481505178722,                /* '<S147>/Add' */\n  -0.1687161480386685,                 /* '<S148>/Add' */\n  -0.039006249297257989                /* '<S149>/Add' */\n};\n\n/* Constant parameters (default storage) */\nconst ConstP_MARS_T MARS_ConstP = {\n  /* Pooled Parameter (Expression: -eye(3))\n   * Referenced by:\n   *   '<S115>/Bias1'\n   *   '<S153>/Bias1'\n   */\n  { -1.0, -0.0, -0.0, -0.0, -1.0, -0.0, -0.0, -0.0, -1.0 }\n};\n"},{"name":"multiword_types.h","type":"header","group":"utility","path":"/home/aman/GitHub/flightTestingLab/controls/Ingenuity_Modelling/MATLAB-env/MARS_grt_rtw","tag":"","groupDisplay":"Utility files","code":"/*\n * multiword_types.h\n *\n * Academic License - for use in teaching, academic research, and meeting\n * course requirements at degree granting institutions only.  Not for\n * government, commercial, or other organizational use.\n *\n * Code generation for model \"MARS\".\n *\n * Model version              : 1.28\n * Simulink Coder version : 9.7 (R2022a) 13-Nov-2021\n * C source code generated on : Fri Oct 28 08:09:17 2022\n *\n * Target selection: grt.tlc\n * Note: GRT includes extra infrastructure and instrumentation for prototyping\n * Embedded hardware selection: Intel->x86-64 (Windows64)\n * Code generation objective: Execution efficiency\n * Validation result: Not run\n */\n\n#ifndef MULTIWORD_TYPES_H\n#define MULTIWORD_TYPES_H\n#include \"rtwtypes.h\"\n\n/*\n * MultiWord supporting definitions\n */\ntypedef long long longlong_T;\n\n/*\n * MultiWord types\n */\ntypedef struct {\n  uint64_T chunks[2];\n} int128m_T;\n\ntypedef struct {\n  int128m_T re;\n  int128m_T im;\n} cint128m_T;\n\ntypedef struct {\n  uint64_T chunks[2];\n} uint128m_T;\n\ntypedef struct {\n  uint128m_T re;\n  uint128m_T im;\n} cuint128m_T;\n\ntypedef struct {\n  uint64_T chunks[3];\n} int192m_T;\n\ntypedef struct {\n  int192m_T re;\n  int192m_T im;\n} cint192m_T;\n\ntypedef struct {\n  uint64_T chunks[3];\n} uint192m_T;\n\ntypedef struct {\n  uint192m_T re;\n  uint192m_T im;\n} cuint192m_T;\n\ntypedef struct {\n  uint64_T chunks[4];\n} int256m_T;\n\ntypedef struct {\n  int256m_T re;\n  int256m_T im;\n} cint256m_T;\n\ntypedef struct {\n  uint64_T chunks[4];\n} uint256m_T;\n\ntypedef struct {\n  uint256m_T re;\n  uint256m_T im;\n} cuint256m_T;\n\ntypedef struct {\n  uint64_T chunks[5];\n} int320m_T;\n\ntypedef struct {\n  int320m_T re;\n  int320m_T im;\n} cint320m_T;\n\ntypedef struct {\n  uint64_T chunks[5];\n} uint320m_T;\n\ntypedef struct {\n  uint320m_T re;\n  uint320m_T im;\n} cuint320m_T;\n\ntypedef struct {\n  uint64_T chunks[6];\n} int384m_T;\n\ntypedef struct {\n  int384m_T re;\n  int384m_T im;\n} cint384m_T;\n\ntypedef struct {\n  uint64_T chunks[6];\n} uint384m_T;\n\ntypedef struct {\n  uint384m_T re;\n  uint384m_T im;\n} cuint384m_T;\n\ntypedef struct {\n  uint64_T chunks[7];\n} int448m_T;\n\ntypedef struct {\n  int448m_T re;\n  int448m_T im;\n} cint448m_T;\n\ntypedef struct {\n  uint64_T chunks[7];\n} uint448m_T;\n\ntypedef struct {\n  uint448m_T re;\n  uint448m_T im;\n} cuint448m_T;\n\ntypedef struct {\n  uint64_T chunks[8];\n} int512m_T;\n\ntypedef struct {\n  int512m_T re;\n  int512m_T im;\n} cint512m_T;\n\ntypedef struct {\n  uint64_T chunks[8];\n} uint512m_T;\n\ntypedef struct {\n  uint512m_T re;\n  uint512m_T im;\n} cuint512m_T;\n\ntypedef struct {\n  uint64_T chunks[9];\n} int576m_T;\n\ntypedef struct {\n  int576m_T re;\n  int576m_T im;\n} cint576m_T;\n\ntypedef struct {\n  uint64_T chunks[9];\n} uint576m_T;\n\ntypedef struct {\n  uint576m_T re;\n  uint576m_T im;\n} cuint576m_T;\n\ntypedef struct {\n  uint64_T chunks[10];\n} int640m_T;\n\ntypedef struct {\n  int640m_T re;\n  int640m_T im;\n} cint640m_T;\n\ntypedef struct {\n  uint64_T chunks[10];\n} uint640m_T;\n\ntypedef struct {\n  uint640m_T re;\n  uint640m_T im;\n} cuint640m_T;\n\ntypedef struct {\n  uint64_T chunks[11];\n} int704m_T;\n\ntypedef struct {\n  int704m_T re;\n  int704m_T im;\n} cint704m_T;\n\ntypedef struct {\n  uint64_T chunks[11];\n} uint704m_T;\n\ntypedef struct {\n  uint704m_T re;\n  uint704m_T im;\n} cuint704m_T;\n\ntypedef struct {\n  uint64_T chunks[12];\n} int768m_T;\n\ntypedef struct {\n  int768m_T re;\n  int768m_T im;\n} cint768m_T;\n\ntypedef struct {\n  uint64_T chunks[12];\n} uint768m_T;\n\ntypedef struct {\n  uint768m_T re;\n  uint768m_T im;\n} cuint768m_T;\n\ntypedef struct {\n  uint64_T chunks[13];\n} int832m_T;\n\ntypedef struct {\n  int832m_T re;\n  int832m_T im;\n} cint832m_T;\n\ntypedef struct {\n  uint64_T chunks[13];\n} uint832m_T;\n\ntypedef struct {\n  uint832m_T re;\n  uint832m_T im;\n} cuint832m_T;\n\ntypedef struct {\n  uint64_T chunks[14];\n} int896m_T;\n\ntypedef struct {\n  int896m_T re;\n  int896m_T im;\n} cint896m_T;\n\ntypedef struct {\n  uint64_T chunks[14];\n} uint896m_T;\n\ntypedef struct {\n  uint896m_T re;\n  uint896m_T im;\n} cuint896m_T;\n\ntypedef struct {\n  uint64_T chunks[15];\n} int960m_T;\n\ntypedef struct {\n  int960m_T re;\n  int960m_T im;\n} cint960m_T;\n\ntypedef struct {\n  uint64_T chunks[15];\n} uint960m_T;\n\ntypedef struct {\n  uint960m_T re;\n  uint960m_T im;\n} cuint960m_T;\n\ntypedef struct {\n  uint64_T chunks[16];\n} int1024m_T;\n\ntypedef struct {\n  int1024m_T re;\n  int1024m_T im;\n} cint1024m_T;\n\ntypedef struct {\n  uint64_T chunks[16];\n} uint1024m_T;\n\ntypedef struct {\n  uint1024m_T re;\n  uint1024m_T im;\n} cuint1024m_T;\n\ntypedef struct {\n  uint64_T chunks[17];\n} int1088m_T;\n\ntypedef struct {\n  int1088m_T re;\n  int1088m_T im;\n} cint1088m_T;\n\ntypedef struct {\n  uint64_T chunks[17];\n} uint1088m_T;\n\ntypedef struct {\n  uint1088m_T re;\n  uint1088m_T im;\n} cuint1088m_T;\n\ntypedef struct {\n  uint64_T chunks[18];\n} int1152m_T;\n\ntypedef struct {\n  int1152m_T re;\n  int1152m_T im;\n} cint1152m_T;\n\ntypedef struct {\n  uint64_T chunks[18];\n} uint1152m_T;\n\ntypedef struct {\n  uint1152m_T re;\n  uint1152m_T im;\n} cuint1152m_T;\n\ntypedef struct {\n  uint64_T chunks[19];\n} int1216m_T;\n\ntypedef struct {\n  int1216m_T re;\n  int1216m_T im;\n} cint1216m_T;\n\ntypedef struct {\n  uint64_T chunks[19];\n} uint1216m_T;\n\ntypedef struct {\n  uint1216m_T re;\n  uint1216m_T im;\n} cuint1216m_T;\n\ntypedef struct {\n  uint64_T chunks[20];\n} int1280m_T;\n\ntypedef struct {\n  int1280m_T re;\n  int1280m_T im;\n} cint1280m_T;\n\ntypedef struct {\n  uint64_T chunks[20];\n} uint1280m_T;\n\ntypedef struct {\n  uint1280m_T re;\n  uint1280m_T im;\n} cuint1280m_T;\n\ntypedef struct {\n  uint64_T chunks[21];\n} int1344m_T;\n\ntypedef struct {\n  int1344m_T re;\n  int1344m_T im;\n} cint1344m_T;\n\ntypedef struct {\n  uint64_T chunks[21];\n} uint1344m_T;\n\ntypedef struct {\n  uint1344m_T re;\n  uint1344m_T im;\n} cuint1344m_T;\n\ntypedef struct {\n  uint64_T chunks[22];\n} int1408m_T;\n\ntypedef struct {\n  int1408m_T re;\n  int1408m_T im;\n} cint1408m_T;\n\ntypedef struct {\n  uint64_T chunks[22];\n} uint1408m_T;\n\ntypedef struct {\n  uint1408m_T re;\n  uint1408m_T im;\n} cuint1408m_T;\n\ntypedef struct {\n  uint64_T chunks[23];\n} int1472m_T;\n\ntypedef struct {\n  int1472m_T re;\n  int1472m_T im;\n} cint1472m_T;\n\ntypedef struct {\n  uint64_T chunks[23];\n} uint1472m_T;\n\ntypedef struct {\n  uint1472m_T re;\n  uint1472m_T im;\n} cuint1472m_T;\n\ntypedef struct {\n  uint64_T chunks[24];\n} int1536m_T;\n\ntypedef struct {\n  int1536m_T re;\n  int1536m_T im;\n} cint1536m_T;\n\ntypedef struct {\n  uint64_T chunks[24];\n} uint1536m_T;\n\ntypedef struct {\n  uint1536m_T re;\n  uint1536m_T im;\n} cuint1536m_T;\n\ntypedef struct {\n  uint64_T chunks[25];\n} int1600m_T;\n\ntypedef struct {\n  int1600m_T re;\n  int1600m_T im;\n} cint1600m_T;\n\ntypedef struct {\n  uint64_T chunks[25];\n} uint1600m_T;\n\ntypedef struct {\n  uint1600m_T re;\n  uint1600m_T im;\n} cuint1600m_T;\n\ntypedef struct {\n  uint64_T chunks[26];\n} int1664m_T;\n\ntypedef struct {\n  int1664m_T re;\n  int1664m_T im;\n} cint1664m_T;\n\ntypedef struct {\n  uint64_T chunks[26];\n} uint1664m_T;\n\ntypedef struct {\n  uint1664m_T re;\n  uint1664m_T im;\n} cuint1664m_T;\n\ntypedef struct {\n  uint64_T chunks[27];\n} int1728m_T;\n\ntypedef struct {\n  int1728m_T re;\n  int1728m_T im;\n} cint1728m_T;\n\ntypedef struct {\n  uint64_T chunks[27];\n} uint1728m_T;\n\ntypedef struct {\n  uint1728m_T re;\n  uint1728m_T im;\n} cuint1728m_T;\n\ntypedef struct {\n  uint64_T chunks[28];\n} int1792m_T;\n\ntypedef struct {\n  int1792m_T re;\n  int1792m_T im;\n} cint1792m_T;\n\ntypedef struct {\n  uint64_T chunks[28];\n} uint1792m_T;\n\ntypedef struct {\n  uint1792m_T re;\n  uint1792m_T im;\n} cuint1792m_T;\n\ntypedef struct {\n  uint64_T chunks[29];\n} int1856m_T;\n\ntypedef struct {\n  int1856m_T re;\n  int1856m_T im;\n} cint1856m_T;\n\ntypedef struct {\n  uint64_T chunks[29];\n} uint1856m_T;\n\ntypedef struct {\n  uint1856m_T re;\n  uint1856m_T im;\n} cuint1856m_T;\n\ntypedef struct {\n  uint64_T chunks[30];\n} int1920m_T;\n\ntypedef struct {\n  int1920m_T re;\n  int1920m_T im;\n} cint1920m_T;\n\ntypedef struct {\n  uint64_T chunks[30];\n} uint1920m_T;\n\ntypedef struct {\n  uint1920m_T re;\n  uint1920m_T im;\n} cuint1920m_T;\n\ntypedef struct {\n  uint64_T chunks[31];\n} int1984m_T;\n\ntypedef struct {\n  int1984m_T re;\n  int1984m_T im;\n} cint1984m_T;\n\ntypedef struct {\n  uint64_T chunks[31];\n} uint1984m_T;\n\ntypedef struct {\n  uint1984m_T re;\n  uint1984m_T im;\n} cuint1984m_T;\n\ntypedef struct {\n  uint64_T chunks[32];\n} int2048m_T;\n\ntypedef struct {\n  int2048m_T re;\n  int2048m_T im;\n} cint2048m_T;\n\ntypedef struct {\n  uint64_T chunks[32];\n} uint2048m_T;\n\ntypedef struct {\n  uint2048m_T re;\n  uint2048m_T im;\n} cuint2048m_T;\n\n#endif                                 /* MULTIWORD_TYPES_H */\n"},{"name":"rtGetInf.c","type":"source","group":"utility","path":"/home/aman/GitHub/flightTestingLab/controls/Ingenuity_Modelling/MATLAB-env/MARS_grt_rtw","tag":"","groupDisplay":"Utility files","code":"/*\n * rtGetInf.c\n *\n * Academic License - for use in teaching, academic research, and meeting\n * course requirements at degree granting institutions only.  Not for\n * government, commercial, or other organizational use.\n *\n * Code generation for model \"MARS\".\n *\n * Model version              : 1.28\n * Simulink Coder version : 9.7 (R2022a) 13-Nov-2021\n * C source code generated on : Fri Oct 28 08:09:17 2022\n *\n * Target selection: grt.tlc\n * Note: GRT includes extra infrastructure and instrumentation for prototyping\n * Embedded hardware selection: Intel->x86-64 (Windows64)\n * Code generation objective: Execution efficiency\n * Validation result: Not run\n */\n\n#include \"rtwtypes.h\"\n#include \"rtGetInf.h\"\n#include <stddef.h>\n#include \"rt_nonfinite.h\"\n#define NumBitsPerChar                 8U\n\n/*\n * Initialize rtInf needed by the generated code.\n * Inf is initialized as non-signaling. Assumes IEEE.\n */\nreal_T rtGetInf(void)\n{\n  size_t bitsPerReal = sizeof(real_T) * (NumBitsPerChar);\n  real_T inf = 0.0;\n  if (bitsPerReal == 32U) {\n    inf = rtGetInfF();\n  } else {\n    uint16_T one = 1U;\n    enum {\n      LittleEndian,\n      BigEndian\n    } machByteOrder = (*((uint8_T *) &one) == 1U) ? LittleEndian : BigEndian;\n    switch (machByteOrder) {\n     case LittleEndian:\n      {\n        union {\n          LittleEndianIEEEDouble bitVal;\n          real_T fltVal;\n        } tmpVal;\n\n        tmpVal.bitVal.words.wordH = 0x7FF00000U;\n        tmpVal.bitVal.words.wordL = 0x00000000U;\n        inf = tmpVal.fltVal;\n        break;\n      }\n\n     case BigEndian:\n      {\n        union {\n          BigEndianIEEEDouble bitVal;\n          real_T fltVal;\n        } tmpVal;\n\n        tmpVal.bitVal.words.wordH = 0x7FF00000U;\n        tmpVal.bitVal.words.wordL = 0x00000000U;\n        inf = tmpVal.fltVal;\n        break;\n      }\n    }\n  }\n\n  return inf;\n}\n\n/*\n * Initialize rtInfF needed by the generated code.\n * Inf is initialized as non-signaling. Assumes IEEE.\n */\nreal32_T rtGetInfF(void)\n{\n  IEEESingle infF;\n  infF.wordL.wordLuint = 0x7F800000U;\n  return infF.wordL.wordLreal;\n}\n\n/*\n * Initialize rtMinusInf needed by the generated code.\n * Inf is initialized as non-signaling. Assumes IEEE.\n */\nreal_T rtGetMinusInf(void)\n{\n  size_t bitsPerReal = sizeof(real_T) * (NumBitsPerChar);\n  real_T minf = 0.0;\n  if (bitsPerReal == 32U) {\n    minf = rtGetMinusInfF();\n  } else {\n    uint16_T one = 1U;\n    enum {\n      LittleEndian,\n      BigEndian\n    } machByteOrder = (*((uint8_T *) &one) == 1U) ? LittleEndian : BigEndian;\n    switch (machByteOrder) {\n     case LittleEndian:\n      {\n        union {\n          LittleEndianIEEEDouble bitVal;\n          real_T fltVal;\n        } tmpVal;\n\n        tmpVal.bitVal.words.wordH = 0xFFF00000U;\n        tmpVal.bitVal.words.wordL = 0x00000000U;\n        minf = tmpVal.fltVal;\n        break;\n      }\n\n     case BigEndian:\n      {\n        union {\n          BigEndianIEEEDouble bitVal;\n          real_T fltVal;\n        } tmpVal;\n\n        tmpVal.bitVal.words.wordH = 0xFFF00000U;\n        tmpVal.bitVal.words.wordL = 0x00000000U;\n        minf = tmpVal.fltVal;\n        break;\n      }\n    }\n  }\n\n  return minf;\n}\n\n/*\n * Initialize rtMinusInfF needed by the generated code.\n * Inf is initialized as non-signaling. Assumes IEEE.\n */\nreal32_T rtGetMinusInfF(void)\n{\n  IEEESingle minfF;\n  minfF.wordL.wordLuint = 0xFF800000U;\n  return minfF.wordL.wordLreal;\n}\n"},{"name":"rtGetInf.h","type":"header","group":"utility","path":"/home/aman/GitHub/flightTestingLab/controls/Ingenuity_Modelling/MATLAB-env/MARS_grt_rtw","tag":"","groupDisplay":"Utility files","code":"/*\n * rtGetInf.h\n *\n * Academic License - for use in teaching, academic research, and meeting\n * course requirements at degree granting institutions only.  Not for\n * government, commercial, or other organizational use.\n *\n * Code generation for model \"MARS\".\n *\n * Model version              : 1.28\n * Simulink Coder version : 9.7 (R2022a) 13-Nov-2021\n * C source code generated on : Fri Oct 28 08:09:17 2022\n *\n * Target selection: grt.tlc\n * Note: GRT includes extra infrastructure and instrumentation for prototyping\n * Embedded hardware selection: Intel->x86-64 (Windows64)\n * Code generation objective: Execution efficiency\n * Validation result: Not run\n */\n\n#ifndef RTW_HEADER_rtGetInf_h_\n#define RTW_HEADER_rtGetInf_h_\n#include \"rtwtypes.h\"\n\nextern real_T rtGetInf(void);\nextern real32_T rtGetInfF(void);\nextern real_T rtGetMinusInf(void);\nextern real32_T rtGetMinusInfF(void);\n\n#endif                                 /* RTW_HEADER_rtGetInf_h_ */\n"},{"name":"rtGetNaN.c","type":"source","group":"utility","path":"/home/aman/GitHub/flightTestingLab/controls/Ingenuity_Modelling/MATLAB-env/MARS_grt_rtw","tag":"","groupDisplay":"Utility files","code":"/*\n * rtGetNaN.c\n *\n * Academic License - for use in teaching, academic research, and meeting\n * course requirements at degree granting institutions only.  Not for\n * government, commercial, or other organizational use.\n *\n * Code generation for model \"MARS\".\n *\n * Model version              : 1.28\n * Simulink Coder version : 9.7 (R2022a) 13-Nov-2021\n * C source code generated on : Fri Oct 28 08:09:17 2022\n *\n * Target selection: grt.tlc\n * Note: GRT includes extra infrastructure and instrumentation for prototyping\n * Embedded hardware selection: Intel->x86-64 (Windows64)\n * Code generation objective: Execution efficiency\n * Validation result: Not run\n */\n\n#include \"rtwtypes.h\"\n#include \"rtGetNaN.h\"\n#include <stddef.h>\n#include \"rt_nonfinite.h\"\n#define NumBitsPerChar                 8U\n\n/*\n * Initialize rtNaN needed by the generated code.\n * NaN is initialized as non-signaling. Assumes IEEE.\n */\nreal_T rtGetNaN(void)\n{\n  size_t bitsPerReal = sizeof(real_T) * (NumBitsPerChar);\n  real_T nan = 0.0;\n  if (bitsPerReal == 32U) {\n    nan = rtGetNaNF();\n  } else {\n    uint16_T one = 1U;\n    enum {\n      LittleEndian,\n      BigEndian\n    } machByteOrder = (*((uint8_T *) &one) == 1U) ? LittleEndian : BigEndian;\n    switch (machByteOrder) {\n     case LittleEndian:\n      {\n        union {\n          LittleEndianIEEEDouble bitVal;\n          real_T fltVal;\n        } tmpVal;\n\n        tmpVal.bitVal.words.wordH = 0xFFF80000U;\n        tmpVal.bitVal.words.wordL = 0x00000000U;\n        nan = tmpVal.fltVal;\n        break;\n      }\n\n     case BigEndian:\n      {\n        union {\n          BigEndianIEEEDouble bitVal;\n          real_T fltVal;\n        } tmpVal;\n\n        tmpVal.bitVal.words.wordH = 0x7FFFFFFFU;\n        tmpVal.bitVal.words.wordL = 0xFFFFFFFFU;\n        nan = tmpVal.fltVal;\n        break;\n      }\n    }\n  }\n\n  return nan;\n}\n\n/*\n * Initialize rtNaNF needed by the generated code.\n * NaN is initialized as non-signaling. Assumes IEEE.\n */\nreal32_T rtGetNaNF(void)\n{\n  IEEESingle nanF = { { 0.0F } };\n\n  uint16_T one = 1U;\n  enum {\n    LittleEndian,\n    BigEndian\n  } machByteOrder = (*((uint8_T *) &one) == 1U) ? LittleEndian : BigEndian;\n  switch (machByteOrder) {\n   case LittleEndian:\n    {\n      nanF.wordL.wordLuint = 0xFFC00000U;\n      break;\n    }\n\n   case BigEndian:\n    {\n      nanF.wordL.wordLuint = 0x7FFFFFFFU;\n      break;\n    }\n  }\n\n  return nanF.wordL.wordLreal;\n}\n"},{"name":"rtGetNaN.h","type":"header","group":"utility","path":"/home/aman/GitHub/flightTestingLab/controls/Ingenuity_Modelling/MATLAB-env/MARS_grt_rtw","tag":"","groupDisplay":"Utility files","code":"/*\n * rtGetNaN.h\n *\n * Academic License - for use in teaching, academic research, and meeting\n * course requirements at degree granting institutions only.  Not for\n * government, commercial, or other organizational use.\n *\n * Code generation for model \"MARS\".\n *\n * Model version              : 1.28\n * Simulink Coder version : 9.7 (R2022a) 13-Nov-2021\n * C source code generated on : Fri Oct 28 08:09:17 2022\n *\n * Target selection: grt.tlc\n * Note: GRT includes extra infrastructure and instrumentation for prototyping\n * Embedded hardware selection: Intel->x86-64 (Windows64)\n * Code generation objective: Execution efficiency\n * Validation result: Not run\n */\n\n#ifndef RTW_HEADER_rtGetNaN_h_\n#define RTW_HEADER_rtGetNaN_h_\n#include \"rtwtypes.h\"\n\nextern real_T rtGetNaN(void);\nextern real32_T rtGetNaNF(void);\n\n#endif                                 /* RTW_HEADER_rtGetNaN_h_ */\n"},{"name":"rt_assert.h","type":"header","group":"utility","path":"/home/aman/GitHub/flightTestingLab/controls/Ingenuity_Modelling/MATLAB-env/MARS_grt_rtw","tag":"","groupDisplay":"Utility files","code":"/*\n * rt_assert.h\n *\n * Academic License - for use in teaching, academic research, and meeting\n * course requirements at degree granting institutions only.  Not for\n * government, commercial, or other organizational use.\n *\n * Code generation for model \"MARS\".\n *\n * Model version              : 1.28\n * Simulink Coder version : 9.7 (R2022a) 13-Nov-2021\n * C source code generated on : Fri Oct 28 08:09:17 2022\n *\n * Target selection: grt.tlc\n * Note: GRT includes extra infrastructure and instrumentation for prototyping\n * Embedded hardware selection: Intel->x86-64 (Windows64)\n * Code generation objective: Execution efficiency\n * Validation result: Not run\n */\n\n#ifndef RTW_HEADER_rt_assert_h_\n#define RTW_HEADER_rt_assert_h_\n\n/*=========*\n * Asserts *\n *=========*/\n#ifndef utAssert\n#if defined(DOASSERTS)\n#if !defined(PRINT_ASSERTS)\n#include <assert.h>\n#define utAssert(exp)                  assert(exp)\n#else\n#include <stdio.h>\n\nstatic void _assert(char *statement, char *file, int line)\n{\n  printf(\"%s in %s on line %d\\n\", statement, file, line);\n}\n\n#define utAssert(_EX)                  ((_EX) ? (void)0 : _assert(#_EX, __FILE__, __LINE__))\n#endif\n\n#else\n#define utAssert(exp)                                            /* do nothing */\n#endif\n#endif\n#endif                                 /* RTW_HEADER_rt_assert_h_ */\n"},{"name":"rt_defines.h","type":"header","group":"utility","path":"/home/aman/GitHub/flightTestingLab/controls/Ingenuity_Modelling/MATLAB-env/MARS_grt_rtw","tag":"","groupDisplay":"Utility files","code":"/*\n * rt_defines.h\n *\n * Academic License - for use in teaching, academic research, and meeting\n * course requirements at degree granting institutions only.  Not for\n * government, commercial, or other organizational use.\n *\n * Code generation for model \"MARS\".\n *\n * Model version              : 1.28\n * Simulink Coder version : 9.7 (R2022a) 13-Nov-2021\n * C source code generated on : Fri Oct 28 08:09:17 2022\n *\n * Target selection: grt.tlc\n * Note: GRT includes extra infrastructure and instrumentation for prototyping\n * Embedded hardware selection: Intel->x86-64 (Windows64)\n * Code generation objective: Execution efficiency\n * Validation result: Not run\n */\n\n#ifndef RTW_HEADER_rt_defines_h_\n#define RTW_HEADER_rt_defines_h_\n\n/*===========*\n * Constants *\n *===========*/\n#define RT_PI                          3.14159265358979323846\n#define RT_PIF                         3.1415927F\n#define RT_LN_10                       2.30258509299404568402\n#define RT_LN_10F                      2.3025851F\n#define RT_LOG10E                      0.43429448190325182765\n#define RT_LOG10EF                     0.43429449F\n#define RT_E                           2.7182818284590452354\n#define RT_EF                          2.7182817F\n\n/*\n * UNUSED_PARAMETER(x)\n *   Used to specify that a function parameter (argument) is required but not\n *   accessed by the function body.\n */\n#ifndef UNUSED_PARAMETER\n#if defined(__LCC__)\n#define UNUSED_PARAMETER(x)                                      /* do nothing */\n#else\n\n/*\n * This is the semi-ANSI standard way of indicating that an\n * unused function parameter is required.\n */\n#define UNUSED_PARAMETER(x)            (void) (x)\n#endif\n#endif\n#endif                                 /* RTW_HEADER_rt_defines_h_ */\n"},{"name":"rt_nonfinite.c","type":"source","group":"utility","path":"/home/aman/GitHub/flightTestingLab/controls/Ingenuity_Modelling/MATLAB-env/MARS_grt_rtw","tag":"","groupDisplay":"Utility files","code":"/*\n * rt_nonfinite.c\n *\n * Academic License - for use in teaching, academic research, and meeting\n * course requirements at degree granting institutions only.  Not for\n * government, commercial, or other organizational use.\n *\n * Code generation for model \"MARS\".\n *\n * Model version              : 1.28\n * Simulink Coder version : 9.7 (R2022a) 13-Nov-2021\n * C source code generated on : Fri Oct 28 08:09:17 2022\n *\n * Target selection: grt.tlc\n * Note: GRT includes extra infrastructure and instrumentation for prototyping\n * Embedded hardware selection: Intel->x86-64 (Windows64)\n * Code generation objective: Execution efficiency\n * Validation result: Not run\n */\n\n#include \"rtGetNaN.h\"\n#include \"rtGetInf.h\"\n#include <stddef.h>\n#include \"rtwtypes.h\"\n#include \"rt_nonfinite.h\"\n#define NumBitsPerChar                 8U\n\nreal_T rtInf;\nreal_T rtMinusInf;\nreal_T rtNaN;\nreal32_T rtInfF;\nreal32_T rtMinusInfF;\nreal32_T rtNaNF;\n\n/*\n * Initialize the rtInf, rtMinusInf, and rtNaN needed by the\n * generated code. NaN is initialized as non-signaling. Assumes IEEE.\n */\nvoid rt_InitInfAndNaN(size_t realSize)\n{\n  (void) (realSize);\n  rtNaN = rtGetNaN();\n  rtNaNF = rtGetNaNF();\n  rtInf = rtGetInf();\n  rtInfF = rtGetInfF();\n  rtMinusInf = rtGetMinusInf();\n  rtMinusInfF = rtGetMinusInfF();\n}\n\n/* Test if value is infinite */\nboolean_T rtIsInf(real_T value)\n{\n  return (boolean_T)((value==rtInf || value==rtMinusInf) ? 1U : 0U);\n}\n\n/* Test if single-precision value is infinite */\nboolean_T rtIsInfF(real32_T value)\n{\n  return (boolean_T)(((value)==rtInfF || (value)==rtMinusInfF) ? 1U : 0U);\n}\n\n/* Test if value is not a number */\nboolean_T rtIsNaN(real_T value)\n{\n  boolean_T result = (boolean_T) 0;\n  size_t bitsPerReal = sizeof(real_T) * (NumBitsPerChar);\n  if (bitsPerReal == 32U) {\n    result = rtIsNaNF((real32_T)value);\n  } else {\n    union {\n      LittleEndianIEEEDouble bitVal;\n      real_T fltVal;\n    } tmpVal;\n\n    tmpVal.fltVal = value;\n    result = (boolean_T)((tmpVal.bitVal.words.wordH & 0x7FF00000) == 0x7FF00000 &&\n                         ( (tmpVal.bitVal.words.wordH & 0x000FFFFF) != 0 ||\n                          (tmpVal.bitVal.words.wordL != 0) ));\n  }\n\n  return result;\n}\n\n/* Test if single-precision value is not a number */\nboolean_T rtIsNaNF(real32_T value)\n{\n  IEEESingle tmp;\n  tmp.wordL.wordLreal = value;\n  return (boolean_T)( (tmp.wordL.wordLuint & 0x7F800000) == 0x7F800000 &&\n                     (tmp.wordL.wordLuint & 0x007FFFFF) != 0 );\n}\n"},{"name":"rt_nonfinite.h","type":"header","group":"utility","path":"/home/aman/GitHub/flightTestingLab/controls/Ingenuity_Modelling/MATLAB-env/MARS_grt_rtw","tag":"","groupDisplay":"Utility files","code":"/*\n * rt_nonfinite.h\n *\n * Academic License - for use in teaching, academic research, and meeting\n * course requirements at degree granting institutions only.  Not for\n * government, commercial, or other organizational use.\n *\n * Code generation for model \"MARS\".\n *\n * Model version              : 1.28\n * Simulink Coder version : 9.7 (R2022a) 13-Nov-2021\n * C source code generated on : Fri Oct 28 08:09:17 2022\n *\n * Target selection: grt.tlc\n * Note: GRT includes extra infrastructure and instrumentation for prototyping\n * Embedded hardware selection: Intel->x86-64 (Windows64)\n * Code generation objective: Execution efficiency\n * Validation result: Not run\n */\n\n#ifndef RTW_HEADER_rt_nonfinite_h_\n#define RTW_HEADER_rt_nonfinite_h_\n#include <stddef.h>\n#include \"rtwtypes.h\"\n\nextern real_T rtInf;\nextern real_T rtMinusInf;\nextern real_T rtNaN;\nextern real32_T rtInfF;\nextern real32_T rtMinusInfF;\nextern real32_T rtNaNF;\nextern void rt_InitInfAndNaN(size_t realSize);\nextern boolean_T rtIsInf(real_T value);\nextern boolean_T rtIsInfF(real32_T value);\nextern boolean_T rtIsNaN(real_T value);\nextern boolean_T rtIsNaNF(real32_T value);\ntypedef struct {\n  struct {\n    uint32_T wordH;\n    uint32_T wordL;\n  } words;\n} BigEndianIEEEDouble;\n\ntypedef struct {\n  struct {\n    uint32_T wordL;\n    uint32_T wordH;\n  } words;\n} LittleEndianIEEEDouble;\n\ntypedef struct {\n  union {\n    real32_T wordLreal;\n    uint32_T wordLuint;\n  } wordL;\n} IEEESingle;\n\n#endif                                 /* RTW_HEADER_rt_nonfinite_h_ */\n"},{"name":"rtwtypes.h","type":"header","group":"utility","path":"/home/aman/GitHub/flightTestingLab/controls/Ingenuity_Modelling/MATLAB-env/MARS_grt_rtw","tag":"","groupDisplay":"Utility files","code":"/*\n * rtwtypes.h\n *\n * Academic License - for use in teaching, academic research, and meeting\n * course requirements at degree granting institutions only.  Not for\n * government, commercial, or other organizational use.\n *\n * Code generation for model \"MARS\".\n *\n * Model version              : 1.28\n * Simulink Coder version : 9.7 (R2022a) 13-Nov-2021\n * C source code generated on : Fri Oct 28 08:09:17 2022\n *\n * Target selection: grt.tlc\n * Note: GRT includes extra infrastructure and instrumentation for prototyping\n * Embedded hardware selection: Intel->x86-64 (Windows64)\n * Code generation objective: Execution efficiency\n * Validation result: Not run\n */\n\n#ifndef RTWTYPES_H\n#define RTWTYPES_H\n#include \"tmwtypes.h\"\n#ifndef POINTER_T\n#define POINTER_T\n\ntypedef void * pointer_T;\n\n#endif\n\n/* Logical type definitions */\n#if (!defined(__cplusplus))\n#ifndef false\n#define false                          (0U)\n#endif\n\n#ifndef true\n#define true                           (1U)\n#endif\n#endif\n\n#ifndef INT64_T\n#define INT64_T\n\ntypedef long long int64_T;\n\n#define MAX_int64_T                    ((int64_T)(9223372036854775807LL))\n#define MIN_int64_T                    ((int64_T)(-9223372036854775807LL-1LL))\n#endif\n\n#ifndef UINT64_T\n#define UINT64_T\n\ntypedef unsigned long long uint64_T;\n\n#define MAX_uint64_T                   ((uint64_T)(0xFFFFFFFFFFFFFFFFULL))\n#endif\n\n/*===========================================================================*\n * Additional complex number type definitions                                           *\n *===========================================================================*/\n#ifndef CINT64_T\n#define CINT64_T\n\ntypedef struct {\n  int64_T re;\n  int64_T im;\n} cint64_T;\n\n#endif\n\n#ifndef CUINT64_T\n#define CUINT64_T\n\ntypedef struct {\n  uint64_T re;\n  uint64_T im;\n} cuint64_T;\n\n#endif\n#endif                                 /* RTWTYPES_H */\n"},{"name":"rtmodel.h","type":"header","group":"interface","path":"/home/aman/GitHub/flightTestingLab/controls/Ingenuity_Modelling/MATLAB-env/MARS_grt_rtw","tag":"","groupDisplay":"Interface files","code":"/*\n *  rtmodel.h:\n *\n * Academic License - for use in teaching, academic research, and meeting\n * course requirements at degree granting institutions only.  Not for\n * government, commercial, or other organizational use.\n *\n * Code generation for model \"MARS\".\n *\n * Model version              : 1.28\n * Simulink Coder version : 9.7 (R2022a) 13-Nov-2021\n * C source code generated on : Fri Oct 28 08:09:17 2022\n *\n * Target selection: grt.tlc\n * Note: GRT includes extra infrastructure and instrumentation for prototyping\n * Embedded hardware selection: Intel->x86-64 (Windows64)\n * Code generation objective: Execution efficiency\n * Validation result: Not run\n */\n\n#ifndef RTW_HEADER_rtmodel_h_\n#define RTW_HEADER_rtmodel_h_\n#include \"MARS.h\"\n#define GRTINTERFACE                   0\n#endif                                 /* RTW_HEADER_rtmodel_h_ */\n"}]};