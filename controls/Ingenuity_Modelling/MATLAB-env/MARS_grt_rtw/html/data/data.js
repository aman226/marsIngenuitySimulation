var dataJson = {"arch":{"ispc":false,"isunix":true,"ismac":false},"build":"MARS","ref":false,"files":[{"name":"MARS.cpp","type":"source","group":"model","path":"/home/aman/GitHub/flightTestingLab/controls/Ingenuity_Modelling/MATLAB-env/MARS_grt_rtw","tag":"","groupDisplay":"Model files","code":"/*\n * MARS.cpp\n *\n * Academic License - for use in teaching, academic research, and meeting\n * course requirements at degree granting institutions only.  Not for\n * government, commercial, or other organizational use.\n *\n * Code generation for model \"MARS\".\n *\n * Model version              : 1.6\n * Simulink Coder version : 9.7 (R2022a) 13-Nov-2021\n * C++ source code generated on : Thu Oct 20 23:51:39 2022\n *\n * Target selection: grt.tlc\n * Note: GRT includes extra infrastructure and instrumentation for prototyping\n * Embedded hardware selection: Intel->x86-64 (Windows64)\n * Code generation objective: Execution efficiency\n * Validation result: Not run\n */\n\n#include \"MARS.h\"\n#include \"rtwtypes.h\"\n#include \"rt_assert.h\"\n#include <cmath>\n#include \"MARS_private.h\"\n#include <emmintrin.h>\n#include <cstring>\n#include \"rt_defines.h\"\n#include <cfloat>\n\nextern \"C\" {\n\n#include \"rt_nonfinite.h\"\n\n}\n/*\n * This function updates continuous states using the ODE3 fixed-step\n * solver algorithm\n */\n  void MARS::rt_ertODEUpdateContinuousStates(RTWSolverInfo *si )\n{\n  /* Solver Matrices */\n  static const real_T rt_ODE3_A[3]{\n    1.0/2.0, 3.0/4.0, 1.0\n  };\n\n  static const real_T rt_ODE3_B[3][3]{\n    { 1.0/2.0, 0.0, 0.0 },\n\n    { 0.0, 3.0/4.0, 0.0 },\n\n    { 2.0/9.0, 1.0/3.0, 4.0/9.0 }\n  };\n\n  time_T t { rtsiGetT(si) };\n\n  time_T tnew { rtsiGetSolverStopTime(si) };\n\n  time_T h { rtsiGetStepSize(si) };\n\n  real_T *x { rtsiGetContStates(si) };\n\n  ODE3_IntgData *id { static_cast<ODE3_IntgData *>(rtsiGetSolverData(si)) };\n\n  real_T *y { id->y };\n\n  real_T *f0 { id->f[0] };\n\n  real_T *f1 { id->f[1] };\n\n  real_T *f2 { id->f[2] };\n\n  real_T hB[3];\n  int_T i;\n  int_T nXc { 17 };\n\n  rtsiSetSimTimeStep(si,MINOR_TIME_STEP);\n\n  /* Save the state values at time t in y, we'll use x as ynew. */\n  (void) std::memcpy(y, x,\n                     static_cast<uint_T>(nXc)*sizeof(real_T));\n\n  /* Assumes that rtsiSetT and ModelOutputs are up-to-date */\n  /* f0 = f(t,y) */\n  rtsiSetdX(si, f0);\n  MARS_derivatives();\n\n  /* f(:,2) = feval(odefile, t + hA(1), y + f*hB(:,1), args(:)(*)); */\n  hB[0] = h * rt_ODE3_B[0][0];\n  for (i = 0; i < nXc; i++) {\n    x[i] = y[i] + (f0[i]*hB[0]);\n  }\n\n  rtsiSetT(si, t + h*rt_ODE3_A[0]);\n  rtsiSetdX(si, f1);\n  this->step();\n  MARS_derivatives();\n\n  /* f(:,3) = feval(odefile, t + hA(2), y + f*hB(:,2), args(:)(*)); */\n  for (i = 0; i <= 1; i++) {\n    hB[i] = h * rt_ODE3_B[1][i];\n  }\n\n  for (i = 0; i < nXc; i++) {\n    x[i] = y[i] + (f0[i]*hB[0] + f1[i]*hB[1]);\n  }\n\n  rtsiSetT(si, t + h*rt_ODE3_A[1]);\n  rtsiSetdX(si, f2);\n  this->step();\n  MARS_derivatives();\n\n  /* tnew = t + hA(3);\n     ynew = y + f*hB(:,3); */\n  for (i = 0; i <= 2; i++) {\n    hB[i] = h * rt_ODE3_B[2][i];\n  }\n\n  for (i = 0; i < nXc; i++) {\n    x[i] = y[i] + (f0[i]*hB[0] + f1[i]*hB[1] + f2[i]*hB[2]);\n  }\n\n  rtsiSetT(si, tnew);\n  rtsiSetSimTimeStep(si,MAJOR_TIME_STEP);\n}\n\n/*\n * Output and update for action system:\n *    '<S51>/If Action Subsystem2'\n *    '<S47>/If Action Subsystem2'\n */\nvoid MARS::MARS_IfActionSubsystem2(real_T rtu_In, real_T *rty_OutOrig)\n{\n  /* SignalConversion generated from: '<S54>/In' */\n  *rty_OutOrig = rtu_In;\n}\n\n/*\n * Output and update for action system:\n *    '<S55>/If Not Proper'\n *    '<S93>/If Not Proper'\n */\nvoid MARS::MARS_IfNotProper(real_T rtp_action)\n{\n  /* If: '<S57>/If' incorporates:\n   *  Constant: '<S57>/Constant'\n   */\n  if (rtp_action == 2.0) {\n    /* Outputs for IfAction SubSystem: '<S57>/Warning' incorporates:\n     *  ActionPort: '<S63>/Action Port'\n     */\n    /* Assertion: '<S63>/Assertion' incorporates:\n     *  Constant: '<S57>/Constant1'\n     */\n    utAssert(false);\n\n    /* End of Outputs for SubSystem: '<S57>/Warning' */\n  } else if (rtp_action == 3.0) {\n    /* Outputs for IfAction SubSystem: '<S57>/Error' incorporates:\n     *  ActionPort: '<S62>/Action Port'\n     */\n    /* Assertion: '<S62>/Assertion' incorporates:\n     *  Constant: '<S57>/Constant1'\n     */\n    utAssert(false);\n\n    /* End of Outputs for SubSystem: '<S57>/Error' */\n  }\n\n  /* End of If: '<S57>/If' */\n}\n\n/*\n * Output and update for action system:\n *    '<S55>/Else If Not Orthogonal'\n *    '<S93>/Else If Not Orthogonal'\n */\nvoid MARS::MARS_ElseIfNotOrthogonal(real_T rtp_action)\n{\n  /* If: '<S56>/If' incorporates:\n   *  Constant: '<S56>/Constant'\n   */\n  if (rtp_action == 2.0) {\n    /* Outputs for IfAction SubSystem: '<S56>/Warning' incorporates:\n     *  ActionPort: '<S61>/Action Port'\n     */\n    /* Assertion: '<S61>/Assertion' incorporates:\n     *  Constant: '<S56>/Constant1'\n     */\n    utAssert(false);\n\n    /* End of Outputs for SubSystem: '<S56>/Warning' */\n  } else if (rtp_action == 3.0) {\n    /* Outputs for IfAction SubSystem: '<S56>/Error' incorporates:\n     *  ActionPort: '<S60>/Action Port'\n     */\n    /* Assertion: '<S60>/Assertion' incorporates:\n     *  Constant: '<S56>/Constant1'\n     */\n    utAssert(false);\n\n    /* End of Outputs for SubSystem: '<S56>/Error' */\n  }\n\n  /* End of If: '<S56>/If' */\n}\n\nreal_T rt_atan2d_snf(real_T u0, real_T u1)\n{\n  real_T y;\n  if (std::isnan(u0) || std::isnan(u1)) {\n    y = (rtNaN);\n  } else if (std::isinf(u0) && std::isinf(u1)) {\n    int32_T u0_0;\n    int32_T u1_0;\n    if (u0 > 0.0) {\n      u0_0 = 1;\n    } else {\n      u0_0 = -1;\n    }\n\n    if (u1 > 0.0) {\n      u1_0 = 1;\n    } else {\n      u1_0 = -1;\n    }\n\n    y = std::atan2(static_cast<real_T>(u0_0), static_cast<real_T>(u1_0));\n  } else if (u1 == 0.0) {\n    if (u0 > 0.0) {\n      y = RT_PI / 2.0;\n    } else if (u0 < 0.0) {\n      y = -(RT_PI / 2.0);\n    } else {\n      y = 0.0;\n    }\n  } else {\n    y = std::atan2(u0, u1);\n  }\n\n  return y;\n}\n\nreal_T rt_modd_snf(real_T u0, real_T u1)\n{\n  real_T y;\n  y = u0;\n  if (u1 == 0.0) {\n    if (u0 == 0.0) {\n      y = u1;\n    }\n  } else if (std::isnan(u0) || std::isnan(u1) || std::isinf(u0)) {\n    y = (rtNaN);\n  } else if (u0 == 0.0) {\n    y = 0.0 / u1;\n  } else if (std::isinf(u1)) {\n    if ((u1 < 0.0) != (u0 < 0.0)) {\n      y = u1;\n    }\n  } else {\n    boolean_T yEq;\n    y = std::fmod(u0, u1);\n    yEq = (y == 0.0);\n    if ((!yEq) && (u1 > std::floor(u1))) {\n      real_T q;\n      q = std::abs(u0 / u1);\n      yEq = !(std::abs(q - std::floor(q + 0.5)) > DBL_EPSILON * q);\n    }\n\n    if (yEq) {\n      y = u1 * 0.0;\n    } else if ((u0 < 0.0) != (u1 < 0.0)) {\n      y += u1;\n    }\n  }\n\n  return y;\n}\n\nreal_T rt_remd_snf(real_T u0, real_T u1)\n{\n  real_T y;\n  if (std::isnan(u0) || std::isnan(u1) || std::isinf(u0)) {\n    y = (rtNaN);\n  } else if (std::isinf(u1)) {\n    y = u0;\n  } else if ((u1 != 0.0) && (u1 != std::trunc(u1))) {\n    real_T q;\n    q = std::abs(u0 / u1);\n    if (!(std::abs(q - std::floor(q + 0.5)) > DBL_EPSILON * q)) {\n      y = 0.0 * u0;\n    } else {\n      y = std::fmod(u0, u1);\n    }\n  } else {\n    y = std::fmod(u0, u1);\n  }\n\n  return y;\n}\n\nreal_T rt_powd_snf(real_T u0, real_T u1)\n{\n  real_T y;\n  if (std::isnan(u0) || std::isnan(u1)) {\n    y = (rtNaN);\n  } else {\n    real_T tmp;\n    real_T tmp_0;\n    tmp = std::abs(u0);\n    tmp_0 = std::abs(u1);\n    if (std::isinf(u1)) {\n      if (tmp == 1.0) {\n        y = 1.0;\n      } else if (tmp > 1.0) {\n        if (u1 > 0.0) {\n          y = (rtInf);\n        } else {\n          y = 0.0;\n        }\n      } else if (u1 > 0.0) {\n        y = 0.0;\n      } else {\n        y = (rtInf);\n      }\n    } else if (tmp_0 == 0.0) {\n      y = 1.0;\n    } else if (tmp_0 == 1.0) {\n      if (u1 > 0.0) {\n        y = u0;\n      } else {\n        y = 1.0 / u0;\n      }\n    } else if (u1 == 2.0) {\n      y = u0 * u0;\n    } else if ((u1 == 0.5) && (u0 >= 0.0)) {\n      y = std::sqrt(u0);\n    } else if ((u0 < 0.0) && (u1 > std::floor(u1))) {\n      y = (rtNaN);\n    } else {\n      y = std::pow(u0, u1);\n    }\n  }\n\n  return y;\n}\n\nvoid rt_mrdivide_U1d1x3_U2d_9vOrDY9Z(const real_T u0[3], const real_T u1[9],\n  real_T y[3])\n{\n  real_T A[9];\n  real_T a21;\n  real_T maxval;\n  int32_T r1;\n  int32_T r2;\n  int32_T r3;\n  std::memcpy(&A[0], &u1[0], 9U * sizeof(real_T));\n  r1 = 0;\n  r2 = 1;\n  r3 = 2;\n  maxval = std::abs(u1[0]);\n  a21 = std::abs(u1[1]);\n  if (a21 > maxval) {\n    maxval = a21;\n    r1 = 1;\n    r2 = 0;\n  }\n\n  if (std::abs(u1[2]) > maxval) {\n    r1 = 2;\n    r2 = 1;\n    r3 = 0;\n  }\n\n  A[r2] = u1[r2] / u1[r1];\n  A[r3] /= A[r1];\n  A[r2 + 3] -= A[r1 + 3] * A[r2];\n  A[r3 + 3] -= A[r1 + 3] * A[r3];\n  A[r2 + 6] -= A[r1 + 6] * A[r2];\n  A[r3 + 6] -= A[r1 + 6] * A[r3];\n  if (std::abs(A[r3 + 3]) > std::abs(A[r2 + 3])) {\n    int32_T rtemp;\n    rtemp = r2 + 1;\n    r2 = r3;\n    r3 = rtemp - 1;\n  }\n\n  A[r3 + 3] /= A[r2 + 3];\n  A[r3 + 6] -= A[r3 + 3] * A[r2 + 6];\n  y[r1] = u0[0] / A[r1];\n  y[r2] = u0[1] - A[r1 + 3] * y[r1];\n  y[r3] = u0[2] - A[r1 + 6] * y[r1];\n  y[r2] /= A[r2 + 3];\n  y[r3] -= A[r2 + 6] * y[r2];\n  y[r3] /= A[r3 + 6];\n  y[r2] -= A[r3 + 3] * y[r3];\n  y[r1] -= y[r3] * A[r3];\n  y[r1] -= y[r2] * A[r2];\n}\n\n/* Model step function */\nvoid MARS::step()\n{\n  /* local block i/o variables */\n  real_T rtb_VectorConcatenate[7];\n  __m128d tmp_3;\n  __m128d tmp_4;\n  real_T rtb_Product4_g_tmp[9];\n  real_T rtb_VectorConcatenate_b[9];\n  real_T rtb_VectorConcatenate_f[9];\n  real_T rtb_Sum2[3];\n  real_T rtb_Sum2_0[3];\n  real_T rtb_Sum_hp[3];\n  real_T tmp_0[3];\n  real_T phi_tmp;\n  real_T rtb_ECEFPositiontoLLA_o1_idx_0;\n  real_T rtb_VectorConcatenate_f_tmp;\n  real_T rtb_VectorConcatenate_f_tmp_0;\n  real_T rtb_VectorConcatenate_f_tmp_1;\n  real_T rtb_VectorConcatenate_f_tmp_2;\n  real_T rtb_VectorConcatenate_f_tmp_3;\n  real_T rtb_VectorConcatenate_f_tmp_4;\n  real_T rtb_VectorConcatenate_f_tmp_5;\n  real_T rtb_ixk;\n  real_T rtb_jxi;\n  real_T rtb_kxj;\n  real_T rtb_q0dot;\n  real_T rtb_sincos_o2_idx_1;\n  real_T uTmp_idx_0;\n  real_T uTmp_idx_1;\n  int32_T Product4_tmp;\n  int32_T i;\n  int8_T rtAction;\n  boolean_T rtb_Compare_a[9];\n  if (rtmIsMajorTimeStep((&MARS_M))) {\n    /* set solver stop time */\n    rtsiSetSolverStopTime(&(&MARS_M)->solverInfo,(((&MARS_M)->Timing.clockTick0+\n      1)*(&MARS_M)->Timing.stepSize0));\n  }                                    /* end MajorTimeStep */\n\n  /* Update absolute time of base rate at minor time step */\n  if (rtmIsMinorTimeStep((&MARS_M))) {\n    (&MARS_M)->Timing.t[0] = rtsiGetT(&(&MARS_M)->solverInfo);\n  }\n\n  /* Integrator: '<S5>/p1' */\n  if (MARS_DW.p1_IWORK != 0) {\n    MARS_X.p1_CSTATE[0] = 2.5914855245392346E+6;\n    MARS_X.p1_CSTATE[1] = -1.0790178821353326E+6;\n    MARS_X.p1_CSTATE[2] = 5.7079969783558194E+6;\n  }\n\n  /* ECEF2LLA: '<S1>/ECEF Position to LLA' incorporates:\n   *  Integrator: '<S5>/p1'\n   */\n  uTmp_idx_0 = MARS_X.p1_CSTATE[0];\n  uTmp_idx_1 = MARS_X.p1_CSTATE[1];\n  rtb_q0dot = std::sqrt(MARS_X.p1_CSTATE[0] * MARS_X.p1_CSTATE[0] +\n                        MARS_X.p1_CSTATE[1] * MARS_X.p1_CSTATE[1]);\n  rtb_ixk = rt_atan2d_snf(MARS_X.p1_CSTATE[2], 0.99664718933525254 * rtb_q0dot);\n  phi_tmp = std::sin(rtb_ixk);\n  rtb_jxi = std::cos(rtb_ixk);\n  phi_tmp = rt_atan2d_snf(42841.311513313573 * phi_tmp * phi_tmp * phi_tmp +\n    MARS_X.p1_CSTATE[2], rtb_q0dot - 42697.672707179969 * rtb_jxi * rtb_jxi *\n    rtb_jxi);\n  rtb_jxi = rt_atan2d_snf(0.99664718933525254 * std::sin(phi_tmp), std::cos\n    (phi_tmp));\n  i = 0;\n  while ((rtb_ixk != rtb_jxi) && (i < 5)) {\n    rtb_ixk = rtb_jxi;\n    phi_tmp = std::sin(rtb_jxi);\n    rtb_jxi = std::cos(rtb_jxi);\n    phi_tmp = rt_atan2d_snf(42841.311513313573 * phi_tmp * phi_tmp * phi_tmp +\n      MARS_X.p1_CSTATE[2], std::sqrt(uTmp_idx_0 * uTmp_idx_0 + uTmp_idx_1 *\n      uTmp_idx_1) - 42697.672707179969 * rtb_jxi * rtb_jxi * rtb_jxi);\n    rtb_jxi = rt_atan2d_snf(0.99664718933525254 * std::sin(phi_tmp), std::cos\n      (phi_tmp));\n    i++;\n  }\n\n  rtb_kxj = std::abs(phi_tmp);\n  rtb_ixk = phi_tmp;\n  rtb_jxi = rt_atan2d_snf(MARS_X.p1_CSTATE[1], MARS_X.p1_CSTATE[0]);\n  if (rtb_kxj > 3.1415926535897931) {\n    rtb_ixk = rt_modd_snf(phi_tmp + 3.1415926535897931, 6.2831853071795862) -\n      3.1415926535897931;\n    rtb_kxj = std::abs(rtb_ixk);\n  }\n\n  if (rtb_kxj > 1.5707963267948966) {\n    rtb_jxi += 3.1415926535897931;\n    if (!std::isnan(rtb_ixk)) {\n      if (rtb_ixk < 0.0) {\n        rtb_ixk = -1.0;\n      } else {\n        rtb_ixk = (rtb_ixk > 0.0);\n      }\n    }\n\n    rtb_ixk *= 1.5707963267948966 - (rtb_kxj - 1.5707963267948966);\n  }\n\n  if (std::abs(rtb_jxi) > 3.1415926535897931) {\n    rtb_jxi = rt_remd_snf(rtb_jxi, 6.2831853071795862);\n    rtb_jxi -= std::trunc(rtb_jxi / 3.1415926535897931) * 6.2831853071795862;\n  }\n\n  rtb_ECEFPositiontoLLA_o1_idx_0 = rtb_ixk * 180.0 / 3.1415926535897931;\n  rtb_kxj = rtb_jxi * 180.0 / 3.1415926535897931;\n  rtb_ixk = std::sin(phi_tmp);\n  rtb_q0dot = ((6.378137E+6 / std::sqrt(1.0 - rtb_ixk * rtb_ixk *\n    0.0066943799901413165) * 0.0066943799901413165 * rtb_ixk + MARS_X.p1_CSTATE\n                [2]) * rtb_ixk + rtb_q0dot * std::cos(phi_tmp)) - 6.378137E+6 /\n    std::sqrt(1.0 - std::sin(phi_tmp) * std::sin(phi_tmp) *\n              0.0066943799901413165);\n\n  /* End of ECEF2LLA: '<S1>/ECEF Position to LLA' */\n  if (rtmIsMajorTimeStep((&MARS_M))) {\n    /* If: '<S17>/If' */\n    if (rtsiIsModeUpdateTimeStep(&(&MARS_M)->solverInfo)) {\n      rtAction = 1;\n      MARS_DW.If_ActiveSubsystem = 1;\n    } else {\n      rtAction = MARS_DW.If_ActiveSubsystem;\n    }\n\n    switch (rtAction) {\n     case 0:\n      /* Outputs for IfAction SubSystem: '<S17>/Positive Trace' incorporates:\n       *  ActionPort: '<S68>/Action Port'\n       */\n      /* Gain: '<S68>/Gain' incorporates:\n       *  Merge: '<S17>/Merge'\n       */\n      MARS_B.Merge[0] = 0.22088421489473928;\n\n      /* Product: '<S68>/Product' incorporates:\n       *  Merge: '<S17>/Merge'\n       */\n      MARS_B.Merge[1] = MARS_ConstB.Add_jx / 0.88353685957895711;\n      MARS_B.Merge[2] = MARS_ConstB.Add_o / 0.88353685957895711;\n      MARS_B.Merge[3] = MARS_ConstB.Add_n / 0.88353685957895711;\n\n      /* End of Outputs for SubSystem: '<S17>/Positive Trace' */\n      break;\n\n     case 1:\n      /* Outputs for IfAction SubSystem: '<S17>/Negative Trace' incorporates:\n       *  ActionPort: '<S67>/Action Port'\n       */\n      /* If: '<S67>/Find Maximum Diagonal Value' */\n      if ((MARS_ConstB.Product2[4] > MARS_ConstB.Product2[0]) &&\n          (MARS_ConstB.Product2[4] > MARS_ConstB.Product2[8])) {\n        /* Outputs for IfAction SubSystem: '<S67>/Maximum Value at DCM(2,2)' incorporates:\n         *  ActionPort: '<S72>/Action Port'\n         */\n        /* Gain: '<S72>/Gain' incorporates:\n         *  Merge: '<S17>/Merge'\n         */\n        MARS_B.Merge[2] = 0.955404187046654;\n\n        /* Gain: '<S72>/Gain1' incorporates:\n         *  Merge: '<S17>/Merge'\n         */\n        MARS_B.Merge[1] = MARS_ConstB.Product_d[0];\n\n        /* Gain: '<S72>/Gain3' incorporates:\n         *  Merge: '<S17>/Merge'\n         */\n        MARS_B.Merge[3] = MARS_ConstB.Product_d[1];\n\n        /* Gain: '<S72>/Gain4' incorporates:\n         *  Merge: '<S17>/Merge'\n         */\n        MARS_B.Merge[0] = MARS_ConstB.Product_d[2];\n\n        /* End of Outputs for SubSystem: '<S67>/Maximum Value at DCM(2,2)' */\n      } else if (MARS_ConstB.Product2[8] > MARS_ConstB.Product2[0]) {\n        /* Outputs for IfAction SubSystem: '<S67>/Maximum Value at DCM(3,3)' incorporates:\n         *  ActionPort: '<S73>/Action Port'\n         */\n        /* Gain: '<S73>/Gain' incorporates:\n         *  Merge: '<S17>/Merge'\n         */\n        MARS_B.Merge[3] = 0.044147846096478843;\n\n        /* Gain: '<S73>/Gain1' incorporates:\n         *  Merge: '<S17>/Merge'\n         */\n        MARS_B.Merge[1] = MARS_ConstB.Product_l[0];\n\n        /* Gain: '<S73>/Gain2' incorporates:\n         *  Merge: '<S17>/Merge'\n         */\n        MARS_B.Merge[2] = MARS_ConstB.Product_l[1];\n\n        /* Gain: '<S73>/Gain3' incorporates:\n         *  Merge: '<S17>/Merge'\n         */\n        MARS_B.Merge[0] = MARS_ConstB.Product_l[2];\n\n        /* End of Outputs for SubSystem: '<S67>/Maximum Value at DCM(3,3)' */\n      } else {\n        /* Outputs for IfAction SubSystem: '<S67>/Maximum Value at DCM(1,1)' incorporates:\n         *  ActionPort: '<S71>/Action Port'\n         */\n        /* Gain: '<S71>/Gain' incorporates:\n         *  Merge: '<S17>/Merge'\n         */\n        MARS_B.Merge[1] = 0.19095541539610353;\n\n        /* Gain: '<S71>/Gain1' incorporates:\n         *  Merge: '<S17>/Merge'\n         */\n        MARS_B.Merge[2] = MARS_ConstB.Product_n[0];\n\n        /* Gain: '<S71>/Gain2' incorporates:\n         *  Merge: '<S17>/Merge'\n         */\n        MARS_B.Merge[3] = MARS_ConstB.Product_n[1];\n\n        /* Gain: '<S71>/Gain3' incorporates:\n         *  Merge: '<S17>/Merge'\n         */\n        MARS_B.Merge[0] = MARS_ConstB.Product_n[2];\n\n        /* End of Outputs for SubSystem: '<S67>/Maximum Value at DCM(1,1)' */\n      }\n\n      /* End of If: '<S67>/Find Maximum Diagonal Value' */\n      /* End of Outputs for SubSystem: '<S17>/Negative Trace' */\n      break;\n    }\n\n    /* End of If: '<S17>/If' */\n  }\n\n  /* Integrator: '<S4>/q' */\n  if (MARS_DW.q_IWORK != 0) {\n    MARS_X.q_CSTATE[0] = MARS_B.Merge[0];\n    MARS_X.q_CSTATE[1] = MARS_B.Merge[1];\n    MARS_X.q_CSTATE[2] = MARS_B.Merge[2];\n    MARS_X.q_CSTATE[3] = MARS_B.Merge[3];\n  }\n\n  /* Sqrt: '<S116>/sqrt' incorporates:\n   *  Integrator: '<S4>/q'\n   *  Product: '<S117>/Product'\n   *  Product: '<S117>/Product1'\n   *  Product: '<S117>/Product2'\n   *  Product: '<S117>/Product3'\n   *  Sqrt: '<S120>/sqrt'\n   *  Sum: '<S117>/Sum'\n   */\n  phi_tmp = std::sqrt(((MARS_X.q_CSTATE[0] * MARS_X.q_CSTATE[0] +\n                        MARS_X.q_CSTATE[1] * MARS_X.q_CSTATE[1]) +\n                       MARS_X.q_CSTATE[2] * MARS_X.q_CSTATE[2]) +\n                      MARS_X.q_CSTATE[3] * MARS_X.q_CSTATE[3]);\n\n  /* Product: '<S115>/Product' incorporates:\n   *  Integrator: '<S4>/q'\n   *  Sqrt: '<S116>/sqrt'\n   */\n  rtb_ixk = MARS_X.q_CSTATE[0] / phi_tmp;\n\n  /* Product: '<S115>/Product1' incorporates:\n   *  Integrator: '<S4>/q'\n   *  Sqrt: '<S116>/sqrt'\n   */\n  rtb_jxi = MARS_X.q_CSTATE[1] / phi_tmp;\n\n  /* Product: '<S115>/Product2' incorporates:\n   *  Integrator: '<S4>/q'\n   *  Product: '<S119>/Product2'\n   *  Sqrt: '<S116>/sqrt'\n   */\n  uTmp_idx_0 = MARS_X.q_CSTATE[2] / phi_tmp;\n\n  /* Product: '<S115>/Product3' incorporates:\n   *  Integrator: '<S4>/q'\n   *  Product: '<S119>/Product3'\n   *  Sqrt: '<S116>/sqrt'\n   */\n  uTmp_idx_1 = MARS_X.q_CSTATE[3] / phi_tmp;\n\n  /* Product: '<S105>/Product3' incorporates:\n   *  Product: '<S109>/Product3'\n   */\n  rtb_sincos_o2_idx_1 = rtb_ixk * rtb_ixk;\n\n  /* Product: '<S105>/Product2' incorporates:\n   *  Product: '<S109>/Product2'\n   */\n  rtb_VectorConcatenate_f_tmp_1 = rtb_jxi * rtb_jxi;\n\n  /* Product: '<S105>/Product1' incorporates:\n   *  Product: '<S109>/Product1'\n   *  Product: '<S113>/Product1'\n   *  Product: '<S115>/Product2'\n   */\n  rtb_VectorConcatenate_f_tmp_2 = uTmp_idx_0 * uTmp_idx_0;\n\n  /* Product: '<S105>/Product' incorporates:\n   *  Product: '<S109>/Product'\n   *  Product: '<S113>/Product'\n   *  Product: '<S115>/Product3'\n   */\n  rtb_VectorConcatenate_f_tmp_3 = uTmp_idx_1 * uTmp_idx_1;\n\n  /* Sum: '<S105>/Sum' incorporates:\n   *  Product: '<S105>/Product'\n   *  Product: '<S105>/Product1'\n   *  Product: '<S105>/Product2'\n   *  Product: '<S105>/Product3'\n   */\n  rtb_VectorConcatenate_f[0] = ((rtb_sincos_o2_idx_1 +\n    rtb_VectorConcatenate_f_tmp_1) - rtb_VectorConcatenate_f_tmp_2) -\n    rtb_VectorConcatenate_f_tmp_3;\n\n  /* Product: '<S108>/Product3' incorporates:\n   *  Product: '<S106>/Product3'\n   *  Product: '<S115>/Product3'\n   */\n  rtb_VectorConcatenate_f_tmp = uTmp_idx_1 * rtb_ixk;\n\n  /* Product: '<S108>/Product2' incorporates:\n   *  Product: '<S106>/Product2'\n   *  Product: '<S115>/Product2'\n   */\n  rtb_VectorConcatenate_f_tmp_0 = rtb_jxi * uTmp_idx_0;\n\n  /* Gain: '<S108>/Gain' incorporates:\n   *  Product: '<S108>/Product2'\n   *  Product: '<S108>/Product3'\n   *  Sum: '<S108>/Sum'\n   */\n  rtb_VectorConcatenate_f[1] = (rtb_VectorConcatenate_f_tmp_0 -\n    rtb_VectorConcatenate_f_tmp) * 2.0;\n\n  /* Product: '<S111>/Product2' incorporates:\n   *  Product: '<S107>/Product2'\n   *  Product: '<S115>/Product3'\n   */\n  rtb_VectorConcatenate_f_tmp_4 = rtb_jxi * uTmp_idx_1;\n\n  /* Product: '<S111>/Product1' incorporates:\n   *  Product: '<S107>/Product1'\n   *  Product: '<S115>/Product2'\n   */\n  rtb_VectorConcatenate_f_tmp_5 = rtb_ixk * uTmp_idx_0;\n\n  /* Gain: '<S111>/Gain' incorporates:\n   *  Product: '<S111>/Product1'\n   *  Product: '<S111>/Product2'\n   *  Sum: '<S111>/Sum'\n   */\n  rtb_VectorConcatenate_f[2] = (rtb_VectorConcatenate_f_tmp_5 +\n    rtb_VectorConcatenate_f_tmp_4) * 2.0;\n\n  /* Gain: '<S106>/Gain' incorporates:\n   *  Sum: '<S106>/Sum'\n   */\n  rtb_VectorConcatenate_f[3] = (rtb_VectorConcatenate_f_tmp +\n    rtb_VectorConcatenate_f_tmp_0) * 2.0;\n\n  /* Sum: '<S109>/Sum' incorporates:\n   *  Sum: '<S113>/Sum'\n   */\n  rtb_sincos_o2_idx_1 -= rtb_VectorConcatenate_f_tmp_1;\n  rtb_VectorConcatenate_f[4] = (rtb_sincos_o2_idx_1 +\n    rtb_VectorConcatenate_f_tmp_2) - rtb_VectorConcatenate_f_tmp_3;\n\n  /* Product: '<S112>/Product1' incorporates:\n   *  Product: '<S110>/Product1'\n   */\n  rtb_VectorConcatenate_f_tmp_1 = rtb_ixk * rtb_jxi;\n\n  /* Product: '<S112>/Product2' incorporates:\n   *  Product: '<S110>/Product2'\n   *  Product: '<S115>/Product2'\n   *  Product: '<S115>/Product3'\n   */\n  rtb_VectorConcatenate_f_tmp = uTmp_idx_0 * uTmp_idx_1;\n\n  /* Gain: '<S112>/Gain' incorporates:\n   *  Product: '<S112>/Product1'\n   *  Product: '<S112>/Product2'\n   *  Sum: '<S112>/Sum'\n   */\n  rtb_VectorConcatenate_f[5] = (rtb_VectorConcatenate_f_tmp -\n    rtb_VectorConcatenate_f_tmp_1) * 2.0;\n\n  /* Gain: '<S107>/Gain' incorporates:\n   *  Sum: '<S107>/Sum'\n   */\n  rtb_VectorConcatenate_f[6] = (rtb_VectorConcatenate_f_tmp_4 -\n    rtb_VectorConcatenate_f_tmp_5) * 2.0;\n\n  /* Gain: '<S110>/Gain' incorporates:\n   *  Sum: '<S110>/Sum'\n   */\n  rtb_VectorConcatenate_f[7] = (rtb_VectorConcatenate_f_tmp_1 +\n    rtb_VectorConcatenate_f_tmp) * 2.0;\n\n  /* Sum: '<S113>/Sum' */\n  rtb_VectorConcatenate_f[8] = (rtb_sincos_o2_idx_1 -\n    rtb_VectorConcatenate_f_tmp_2) + rtb_VectorConcatenate_f_tmp_3;\n\n  /* UnitConversion: '<S30>/Unit Conversion' incorporates:\n   *  UnitConversion: '<S140>/Unit Conversion'\n   */\n  /* Unit Conversion - from: deg to: rad\n     Expression: output = (0.0174533*input) + (0) */\n  rtb_ECEFPositiontoLLA_o1_idx_0 *= 0.017453292519943295;\n\n  /* Trigonometry: '<S14>/sincos' incorporates:\n   *  Trigonometry: '<S13>/sine'\n   *  UnitConversion: '<S30>/Unit Conversion'\n   */\n  rtb_ixk = std::cos(rtb_ECEFPositiontoLLA_o1_idx_0);\n  rtb_VectorConcatenate_f_tmp_1 = std::sin(rtb_ECEFPositiontoLLA_o1_idx_0);\n\n  /* UnitConversion: '<S30>/Unit Conversion' */\n  rtb_kxj *= 0.017453292519943295;\n\n  /* Trigonometry: '<S14>/sincos' */\n  rtb_sincos_o2_idx_1 = std::cos(rtb_kxj);\n  rtb_kxj = std::sin(rtb_kxj);\n\n  /* UnaryMinus: '<S21>/Unary Minus' incorporates:\n   *  Product: '<S21>/u(1)*u(4)'\n   *  Trigonometry: '<S14>/sincos'\n   */\n  rtb_VectorConcatenate_b[0] = -(rtb_VectorConcatenate_f_tmp_1 *\n    rtb_sincos_o2_idx_1);\n\n  /* UnaryMinus: '<S24>/Unary Minus' */\n  rtb_VectorConcatenate_b[1] = -rtb_kxj;\n\n  /* UnaryMinus: '<S27>/Unary Minus' incorporates:\n   *  Product: '<S27>/u(3)*u(4)'\n   */\n  rtb_VectorConcatenate_b[2] = -(rtb_ixk * rtb_sincos_o2_idx_1);\n\n  /* UnaryMinus: '<S22>/Unary Minus' incorporates:\n   *  Product: '<S22>/u(1)*u(2)'\n   *  Trigonometry: '<S14>/sincos'\n   */\n  rtb_VectorConcatenate_b[3] = -(rtb_VectorConcatenate_f_tmp_1 * rtb_kxj);\n\n  /* SignalConversion generated from: '<S31>/Vector Concatenate' */\n  rtb_VectorConcatenate_b[4] = rtb_sincos_o2_idx_1;\n\n  /* UnaryMinus: '<S28>/Unary Minus' incorporates:\n   *  Product: '<S28>/u(2)*u(3)'\n   */\n  rtb_VectorConcatenate_b[5] = -(rtb_ixk * rtb_kxj);\n\n  /* SignalConversion generated from: '<S31>/Vector Concatenate' */\n  rtb_VectorConcatenate_b[6] = rtb_ixk;\n\n  /* SignalConversion generated from: '<S31>/Vector Concatenate' incorporates:\n   *  Constant: '<S26>/Constant'\n   */\n  rtb_VectorConcatenate_b[7] = 0.0;\n\n  /* UnaryMinus: '<S29>/Unary Minus' incorporates:\n   *  Trigonometry: '<S14>/sincos'\n   */\n  rtb_VectorConcatenate_b[8] = -rtb_VectorConcatenate_f_tmp_1;\n  for (i = 0; i < 3; i++) {\n    for (int32_T i_0{0}; i_0 <= 0; i_0 += 2) {\n      /* Product: '<S4>/Product4' incorporates:\n       *  Math: '<S4>/Math Function2'\n       */\n      Product4_tmp = 3 * i + i_0;\n      _mm_storeu_pd(&MARS_B.Product4[Product4_tmp], _mm_set1_pd(0.0));\n\n      /* Product: '<S4>/Product4' incorporates:\n       *  Concatenate: '<S114>/Vector Concatenate'\n       *  Concatenate: '<S139>/Vector Concatenate'\n       *  Math: '<S4>/Math Function2'\n       */\n      tmp_3 = _mm_loadu_pd(&rtb_VectorConcatenate_f[i_0]);\n      tmp_4 = _mm_loadu_pd(&MARS_B.Product4[Product4_tmp]);\n      _mm_storeu_pd(&MARS_B.Product4[Product4_tmp], _mm_add_pd(tmp_4, _mm_mul_pd\n        (tmp_3, _mm_set1_pd(rtb_VectorConcatenate_b[i]))));\n      tmp_3 = _mm_loadu_pd(&rtb_VectorConcatenate_f[i_0 + 3]);\n      tmp_4 = _mm_loadu_pd(&MARS_B.Product4[Product4_tmp]);\n      _mm_storeu_pd(&MARS_B.Product4[Product4_tmp], _mm_add_pd(tmp_4, _mm_mul_pd\n        (tmp_3, _mm_set1_pd(rtb_VectorConcatenate_b[i + 3]))));\n      tmp_3 = _mm_loadu_pd(&rtb_VectorConcatenate_f[i_0 + 6]);\n      tmp_4 = _mm_loadu_pd(&MARS_B.Product4[Product4_tmp]);\n      _mm_storeu_pd(&MARS_B.Product4[Product4_tmp], _mm_add_pd(tmp_4, _mm_mul_pd\n        (tmp_3, _mm_set1_pd(rtb_VectorConcatenate_b[i + 6]))));\n    }\n\n    for (int32_T i_0{2}; i_0 < 3; i_0++) {\n      /* Product: '<S4>/Product4' incorporates:\n       *  Concatenate: '<S114>/Vector Concatenate'\n       *  Concatenate: '<S139>/Vector Concatenate'\n       *  Math: '<S4>/Math Function2'\n       */\n      Product4_tmp = 3 * i + i_0;\n      MARS_B.Product4[Product4_tmp] = 0.0;\n      MARS_B.Product4[Product4_tmp] += rtb_VectorConcatenate_f[i_0] *\n        rtb_VectorConcatenate_b[i];\n      MARS_B.Product4[Product4_tmp] += rtb_VectorConcatenate_f[i_0 + 3] *\n        rtb_VectorConcatenate_b[i + 3];\n      MARS_B.Product4[Product4_tmp] += rtb_VectorConcatenate_f[i_0 + 6] *\n        rtb_VectorConcatenate_b[i + 6];\n    }\n  }\n\n  /* Gain: '<S45>/Gain1' incorporates:\n   *  Concatenate: '<S45>/Vector Concatenate'\n   *  Product: '<S4>/Product4'\n   *  Selector: '<S45>/Selector1'\n   */\n  rtb_VectorConcatenate[0] = MARS_B.Product4[3];\n  rtb_VectorConcatenate[1] = MARS_B.Product4[0];\n  rtb_VectorConcatenate[2] = -MARS_B.Product4[6];\n\n  /* Gain: '<S45>/Gain2' incorporates:\n   *  Concatenate: '<S45>/Vector Concatenate'\n   *  Product: '<S4>/Product4'\n   *  Selector: '<S45>/Selector2'\n   */\n  rtb_VectorConcatenate[3] = MARS_B.Product4[7];\n\n  /* Gain: '<S45>/Gain3' incorporates:\n   *  Concatenate: '<S45>/Vector Concatenate'\n   *  Product: '<S4>/Product4'\n   *  Selector: '<S45>/Selector3'\n   */\n  rtb_VectorConcatenate[5] = -MARS_B.Product4[1];\n\n  /* Gain: '<S45>/Gain2' incorporates:\n   *  Concatenate: '<S45>/Vector Concatenate'\n   *  Product: '<S4>/Product4'\n   *  Selector: '<S45>/Selector2'\n   */\n  rtb_VectorConcatenate[4] = MARS_B.Product4[8];\n\n  /* Gain: '<S45>/Gain3' incorporates:\n   *  Concatenate: '<S45>/Vector Concatenate'\n   *  Product: '<S4>/Product4'\n   *  Selector: '<S45>/Selector3'\n   */\n  rtb_VectorConcatenate[6] = MARS_B.Product4[4];\n\n  /* If: '<S16>/If' */\n  if (rtsiIsModeUpdateTimeStep(&(&MARS_M)->solverInfo)) {\n    rtAction = static_cast<int8_T>((!(rtb_VectorConcatenate[2] >= 1.0)) &&\n      (!(rtb_VectorConcatenate[2] <= -1.0)));\n    MARS_DW.If_ActiveSubsystem_h = rtAction;\n  } else {\n    rtAction = MARS_DW.If_ActiveSubsystem_h;\n  }\n\n  switch (rtAction) {\n   case 0:\n    /* Outputs for IfAction SubSystem: '<S16>/AxisRotZeroR3' incorporates:\n     *  ActionPort: '<S44>/Action Port'\n     */\n    /* If: '<S51>/If' */\n    if (rtsiIsModeUpdateTimeStep(&(&MARS_M)->solverInfo)) {\n      if (rtb_VectorConcatenate[2] > 1.0) {\n        rtAction = 0;\n      } else if (rtb_VectorConcatenate[2] < -1.0) {\n        rtAction = 1;\n      } else {\n        rtAction = 2;\n      }\n\n      MARS_DW.If_ActiveSubsystem_c0 = rtAction;\n    } else {\n      rtAction = MARS_DW.If_ActiveSubsystem_c0;\n    }\n\n    switch (rtAction) {\n     case 0:\n      /* Outputs for IfAction SubSystem: '<S51>/If Action Subsystem' incorporates:\n       *  ActionPort: '<S52>/Action Port'\n       */\n      if (rtmIsMajorTimeStep((&MARS_M))) {\n        /* Merge: '<S51>/Merge' incorporates:\n         *  Constant: '<S52>/Constant'\n         */\n        MARS_B.Merge_j2 = 1.0;\n      }\n\n      /* End of Outputs for SubSystem: '<S51>/If Action Subsystem' */\n      break;\n\n     case 1:\n      /* Outputs for IfAction SubSystem: '<S51>/If Action Subsystem1' incorporates:\n       *  ActionPort: '<S53>/Action Port'\n       */\n      if (rtmIsMajorTimeStep((&MARS_M))) {\n        /* Merge: '<S51>/Merge' incorporates:\n         *  Constant: '<S53>/Constant'\n         */\n        MARS_B.Merge_j2 = 1.0;\n      }\n\n      /* End of Outputs for SubSystem: '<S51>/If Action Subsystem1' */\n      break;\n\n     case 2:\n      /* Outputs for IfAction SubSystem: '<S51>/If Action Subsystem2' incorporates:\n       *  ActionPort: '<S54>/Action Port'\n       */\n      MARS_IfActionSubsystem2(rtb_VectorConcatenate[2], &MARS_B.Merge_j2);\n\n      /* End of Outputs for SubSystem: '<S51>/If Action Subsystem2' */\n      break;\n    }\n\n    /* End of If: '<S51>/If' */\n    /* End of Outputs for SubSystem: '<S16>/AxisRotZeroR3' */\n    break;\n\n   case 1:\n    /* Outputs for IfAction SubSystem: '<S16>/AxisRotDefault' incorporates:\n     *  ActionPort: '<S43>/Action Port'\n     */\n    /* If: '<S47>/If' */\n    if (rtsiIsModeUpdateTimeStep(&(&MARS_M)->solverInfo)) {\n      if (rtb_VectorConcatenate[2] > 1.0) {\n        rtAction = 0;\n      } else if (rtb_VectorConcatenate[2] < -1.0) {\n        rtAction = 1;\n      } else {\n        rtAction = 2;\n      }\n\n      MARS_DW.If_ActiveSubsystem_c = rtAction;\n    } else {\n      rtAction = MARS_DW.If_ActiveSubsystem_c;\n    }\n\n    switch (rtAction) {\n     case 0:\n      /* Outputs for IfAction SubSystem: '<S47>/If Action Subsystem' incorporates:\n       *  ActionPort: '<S48>/Action Port'\n       */\n      if (rtmIsMajorTimeStep((&MARS_M))) {\n        /* Merge: '<S47>/Merge' incorporates:\n         *  Constant: '<S48>/Constant'\n         */\n        MARS_B.Merge_j = 1.0;\n      }\n\n      /* End of Outputs for SubSystem: '<S47>/If Action Subsystem' */\n      break;\n\n     case 1:\n      /* Outputs for IfAction SubSystem: '<S47>/If Action Subsystem1' incorporates:\n       *  ActionPort: '<S49>/Action Port'\n       */\n      if (rtmIsMajorTimeStep((&MARS_M))) {\n        /* Merge: '<S47>/Merge' incorporates:\n         *  Constant: '<S49>/Constant'\n         */\n        MARS_B.Merge_j = 1.0;\n      }\n\n      /* End of Outputs for SubSystem: '<S47>/If Action Subsystem1' */\n      break;\n\n     case 2:\n      /* Outputs for IfAction SubSystem: '<S47>/If Action Subsystem2' incorporates:\n       *  ActionPort: '<S50>/Action Port'\n       */\n      MARS_IfActionSubsystem2(rtb_VectorConcatenate[2], &MARS_B.Merge_j);\n\n      /* End of Outputs for SubSystem: '<S47>/If Action Subsystem2' */\n      break;\n    }\n\n    /* End of If: '<S47>/If' */\n    /* End of Outputs for SubSystem: '<S16>/AxisRotDefault' */\n    break;\n  }\n\n  /* End of If: '<S16>/If' */\n  if (rtmIsMajorTimeStep((&MARS_M))) {\n    boolean_T tmp;\n\n    /* If: '<S46>/If1' */\n    rtAction = -1;\n    if (rtsiIsModeUpdateTimeStep(&(&MARS_M)->solverInfo)) {\n      MARS_DW.If1_ActiveSubsystem = -1;\n    } else {\n      rtAction = MARS_DW.If1_ActiveSubsystem;\n    }\n\n    if (rtAction == 0) {\n      /* Outputs for IfAction SubSystem: '<S46>/If Warning//Error' incorporates:\n       *  ActionPort: '<S55>/if'\n       */\n      /* Bias: '<S58>/Bias1' incorporates:\n       *  Math: '<S58>/Math Function'\n       *  Product: '<S4>/Product4'\n       *  Product: '<S58>/Product'\n       */\n      for (i = 0; i < 3; i++) {\n        for (int32_T i_0{0}; i_0 < 3; i_0++) {\n          Product4_tmp = 3 * i + i_0;\n          rtb_Product4_g_tmp[Product4_tmp] = ((MARS_B.Product4[3 * i_0 + 1] *\n            MARS_B.Product4[3 * i + 1] + MARS_B.Product4[3 * i_0] *\n            MARS_B.Product4[3 * i]) + MARS_B.Product4[3 * i_0 + 2] *\n            MARS_B.Product4[3 * i + 2]) + MARS_ConstP.pooled5[Product4_tmp];\n        }\n      }\n\n      /* End of Bias: '<S58>/Bias1' */\n\n      /* RelationalOperator: '<S64>/Compare' incorporates:\n       *  Abs: '<S58>/Abs2'\n       *  Constant: '<S64>/Constant'\n       */\n      for (i = 0; i < 9; i++) {\n        rtb_Compare_a[i] = (std::abs(rtb_Product4_g_tmp[i]) >\n                            4.4408920985006262E-16);\n      }\n\n      /* End of RelationalOperator: '<S64>/Compare' */\n\n      /* Logic: '<S58>/Logical Operator1' incorporates:\n       *  RelationalOperator: '<S64>/Compare'\n       */\n      tmp = rtb_Compare_a[0];\n      for (i = 0; i < 8; i++) {\n        tmp = (tmp || rtb_Compare_a[i + 1]);\n      }\n\n      /* If: '<S55>/If' incorporates:\n       *  Abs: '<S59>/Abs1'\n       *  Bias: '<S59>/Bias'\n       *  Constant: '<S66>/Constant'\n       *  Logic: '<S58>/Logical Operator1'\n       *  Product: '<S4>/Product4'\n       *  Product: '<S65>/Product'\n       *  Product: '<S65>/Product1'\n       *  Product: '<S65>/Product2'\n       *  Product: '<S65>/Product3'\n       *  Product: '<S65>/Product4'\n       *  Product: '<S65>/Product5'\n       *  RelationalOperator: '<S66>/Compare'\n       *  Reshape: '<S65>/Reshape'\n       *  Sum: '<S65>/Sum'\n       */\n      if (std::abs((((((MARS_B.Product4[0] * MARS_B.Product4[4] *\n                        MARS_B.Product4[8] - MARS_B.Product4[0] *\n                        MARS_B.Product4[5] * MARS_B.Product4[7]) -\n                       MARS_B.Product4[1] * MARS_B.Product4[3] *\n                       MARS_B.Product4[8]) + MARS_B.Product4[2] *\n                      MARS_B.Product4[3] * MARS_B.Product4[7]) +\n                     MARS_B.Product4[1] * MARS_B.Product4[5] * MARS_B.Product4[6])\n                    - MARS_B.Product4[2] * MARS_B.Product4[4] * MARS_B.Product4\n                    [6]) + -1.0) > 4.4408920985006262E-16) {\n        /* Outputs for IfAction SubSystem: '<S55>/If Not Proper' incorporates:\n         *  ActionPort: '<S57>/Action Port'\n         */\n        MARS_IfNotProper(1.0);\n\n        /* End of Outputs for SubSystem: '<S55>/If Not Proper' */\n      } else if (tmp) {\n        /* Outputs for IfAction SubSystem: '<S55>/Else If Not Orthogonal' incorporates:\n         *  ActionPort: '<S56>/Action Port'\n         */\n        MARS_ElseIfNotOrthogonal(1.0);\n\n        /* End of Outputs for SubSystem: '<S55>/Else If Not Orthogonal' */\n      }\n\n      /* End of If: '<S55>/If' */\n      /* End of Outputs for SubSystem: '<S46>/If Warning//Error' */\n    }\n\n    /* End of If: '<S46>/If1' */\n\n    /* If: '<S69>/If1' */\n    rtAction = -1;\n    if (rtsiIsModeUpdateTimeStep(&(&MARS_M)->solverInfo)) {\n      MARS_DW.If1_ActiveSubsystem_l = -1;\n    } else {\n      rtAction = MARS_DW.If1_ActiveSubsystem_l;\n    }\n\n    if (rtAction == 0) {\n      /* Outputs for IfAction SubSystem: '<S69>/If Warning//Error' incorporates:\n       *  ActionPort: '<S93>/if'\n       */\n      /* RelationalOperator: '<S102>/Compare' incorporates:\n       *  Abs: '<S96>/Abs2'\n       *  Constant: '<S102>/Constant'\n       */\n      for (i = 0; i < 9; i++) {\n        rtb_Compare_a[i] = (MARS_ConstB.Abs2[i] > 4.4408920985006262E-16);\n      }\n\n      /* End of RelationalOperator: '<S102>/Compare' */\n\n      /* Logic: '<S96>/Logical Operator1' incorporates:\n       *  RelationalOperator: '<S102>/Compare'\n       */\n      tmp = rtb_Compare_a[0];\n      for (i = 0; i < 8; i++) {\n        tmp = (tmp || rtb_Compare_a[i + 1]);\n      }\n\n      /* If: '<S93>/If' incorporates:\n       *  Logic: '<S96>/Logical Operator1'\n       */\n      if (tmp) {\n        /* Outputs for IfAction SubSystem: '<S93>/Else If Not Orthogonal' incorporates:\n         *  ActionPort: '<S94>/Action Port'\n         */\n        MARS_ElseIfNotOrthogonal(1.0);\n\n        /* End of Outputs for SubSystem: '<S93>/Else If Not Orthogonal' */\n      }\n\n      /* End of If: '<S93>/If' */\n      /* End of Outputs for SubSystem: '<S69>/If Warning//Error' */\n    }\n\n    /* End of If: '<S69>/If1' */\n  }\n\n  /* Trigonometry: '<S10>/sincos' incorporates:\n   *  Integrator: '<S8>/Integrator'\n   */\n  rtb_ixk = std::sin(MARS_X.Integrator_CSTATE);\n  rtb_jxi = std::cos(MARS_X.Integrator_CSTATE);\n\n  /* SignalConversion generated from: '<S139>/Vector Concatenate' */\n  rtb_VectorConcatenate_b[0] = rtb_jxi;\n\n  /* SignalConversion generated from: '<S139>/Vector Concatenate' */\n  rtb_VectorConcatenate_b[1] = rtb_ixk;\n\n  /* SignalConversion generated from: '<S139>/Vector Concatenate' incorporates:\n   *  Constant: '<S10>/Zero'\n   */\n  rtb_VectorConcatenate_b[2] = 0.0;\n\n  /* UnaryMinus: '<S10>/Unary Minus' */\n  rtb_VectorConcatenate_b[3] = -rtb_ixk;\n\n  /* SignalConversion generated from: '<S139>/Vector Concatenate' */\n  rtb_VectorConcatenate_b[4] = rtb_jxi;\n\n  /* SignalConversion generated from: '<S139>/Vector Concatenate' incorporates:\n   *  Constant: '<S10>/Zero'\n   */\n  rtb_VectorConcatenate_b[5] = 0.0;\n\n  /* SignalConversion generated from: '<S139>/Vector Concatenate' incorporates:\n   *  Constant: '<S10>/Zero'\n   */\n  rtb_VectorConcatenate_b[6] = 0.0;\n\n  /* SignalConversion generated from: '<S139>/Vector Concatenate' incorporates:\n   *  Constant: '<S10>/Zero'\n   */\n  rtb_VectorConcatenate_b[7] = 0.0;\n\n  /* SignalConversion generated from: '<S139>/Vector Concatenate' incorporates:\n   *  Constant: '<S10>/Zero1'\n   */\n  rtb_VectorConcatenate_b[8] = 1.0;\n  for (i = 0; i < 3; i++) {\n    /* Product: '<S1>/Product3' incorporates:\n     *  Concatenate: '<S114>/Vector Concatenate'\n     *  Product: '<S6>/Product2'\n     */\n    rtb_Sum_hp[i] = (rtb_VectorConcatenate_f[i + 3] * 0.0 +\n                     rtb_VectorConcatenate_f[i] * 0.0) +\n      rtb_VectorConcatenate_f[i + 6] * 7.292115E-5;\n\n    /* Product: '<S13>/Product3' incorporates:\n     *  Integrator: '<S6>/ub,vb,wb'\n     *  Math: '<S13>/Math Function2'\n     *  Product: '<S4>/Product4'\n     */\n    rtb_Sum2[i] = (MARS_B.Product4[3 * i + 1] * MARS_X.ubvbwb_CSTATE[1] +\n                   MARS_B.Product4[3 * i] * MARS_X.ubvbwb_CSTATE[0]) +\n      MARS_B.Product4[3 * i + 2] * MARS_X.ubvbwb_CSTATE[2];\n  }\n\n  /* Sum: '<S13>/Sum2' incorporates:\n   *  Constant: '<S13>/f2'\n   *  Product: '<S13>/Product'\n   */\n  /* Unit Conversion - from: deg to: rad\n     Expression: output = (0.0174533*input) + (0) */\n  rtb_jxi = 1.0 - rtb_VectorConcatenate_f_tmp_1 * rtb_VectorConcatenate_f_tmp_1 *\n    0.00669437999014133;\n\n  /* Product: '<S13>/w1' incorporates:\n   *  Constant: '<S142>/f4'\n   *  Product: '<S142>/N'\n   *  Sqrt: '<S142>/sqrt'\n   *  Sum: '<S142>/Sum4'\n   */\n  rtb_kxj = rtb_Sum2[1] / (6.378137E+6 / std::sqrt(rtb_jxi) + rtb_q0dot);\n\n  /* SignalConversion generated from: '<S1>/Product2' incorporates:\n   *  Constant: '<S141>/f1'\n   *  Constant: '<S141>/f3'\n   *  Gain: '<S13>/Gain'\n   *  Gain: '<S13>/Gain1'\n   *  Math: '<S141>/Math Function'\n   *  Product: '<S13>/w2'\n   *  Product: '<S13>/w3'\n   *  Product: '<S141>/M'\n   *  Sum: '<S141>/Sum1'\n   *  Trigonometry: '<S13>/tan'\n   */\n  rtb_q0dot = -(rtb_Sum2[0] / (6.3354393272928195E+6 / rt_powd_snf(rtb_jxi, 1.5)\n    + rtb_q0dot));\n  rtb_ixk = -(rtb_kxj * std::tan(rtb_ECEFPositiontoLLA_o1_idx_0));\n  for (i = 0; i <= 0; i += 2) {\n    __m128d tmp_1;\n    __m128d tmp_2;\n\n    /* Sum: '<S1>/Sum2' incorporates:\n     *  Product: '<S1>/Product2'\n     *  Product: '<S4>/Product4'\n     */\n    tmp_3 = _mm_loadu_pd(&MARS_B.Product4[i + 3]);\n    tmp_4 = _mm_loadu_pd(&MARS_B.Product4[i]);\n    tmp_1 = _mm_loadu_pd(&MARS_B.Product4[i + 6]);\n\n    /* Product: '<S1>/Product3' incorporates:\n     *  Product: '<S1>/Product2'\n     *  Sum: '<S1>/Sum2'\n     */\n    tmp_2 = _mm_loadu_pd(&rtb_Sum_hp[i]);\n\n    /* Sum: '<S1>/Sum2' incorporates:\n     *  Product: '<S1>/Product2'\n     *  SignalConversion generated from: '<S1>/Product2'\n     */\n    _mm_storeu_pd(&MARS_B.Sum2[i], _mm_add_pd(_mm_add_pd(_mm_add_pd(_mm_mul_pd\n      (tmp_3, _mm_set1_pd(rtb_q0dot)), _mm_mul_pd(tmp_4, _mm_set1_pd(rtb_kxj))),\n      _mm_mul_pd(tmp_1, _mm_set1_pd(rtb_ixk))), tmp_2));\n  }\n\n  for (i = 2; i < 3; i++) {\n    /* Sum: '<S1>/Sum2' incorporates:\n     *  Product: '<S1>/Product2'\n     *  Product: '<S1>/Product3'\n     *  Product: '<S4>/Product4'\n     *  SignalConversion generated from: '<S1>/Product2'\n     *  Sum: '<S1>/Sum3'\n     */\n    MARS_B.Sum2[i] = ((MARS_B.Product4[i + 3] * rtb_q0dot + MARS_B.Product4[i] *\n                       rtb_kxj) + MARS_B.Product4[i + 6] * rtb_ixk) +\n      rtb_Sum_hp[i];\n  }\n\n  /* Integrator: '<S1>/p,q,r ' */\n  if (MARS_DW.pqr_IWORK != 0) {\n    MARS_X.pqr_CSTATE[0] = MARS_B.Sum2[0];\n    MARS_X.pqr_CSTATE[1] = MARS_B.Sum2[1];\n    MARS_X.pqr_CSTATE[2] = MARS_B.Sum2[2];\n  }\n\n  /* Sum: '<S1>/Sum4' incorporates:\n   *  Integrator: '<S1>/p,q,r '\n   *  Product: '<S1>/Product3'\n   */\n  rtb_Sum2[0] = MARS_X.pqr_CSTATE[0] - rtb_Sum_hp[0];\n  rtb_Sum2[1] = MARS_X.pqr_CSTATE[1] - rtb_Sum_hp[1];\n  rtb_Sum2[2] = MARS_X.pqr_CSTATE[2] - rtb_Sum_hp[2];\n\n  /* Product: '<S119>/Product' incorporates:\n   *  Integrator: '<S4>/q'\n   */\n  rtb_jxi = MARS_X.q_CSTATE[0] / phi_tmp;\n\n  /* Product: '<S119>/Product1' incorporates:\n   *  Integrator: '<S4>/q'\n   */\n  rtb_kxj = MARS_X.q_CSTATE[1] / phi_tmp;\n\n  /* SignalConversion generated from: '<S4>/q' incorporates:\n   *  Fcn: '<S20>/q0dot'\n   *  Fcn: '<S20>/q1dot'\n   *  Fcn: '<S20>/q2dot'\n   *  Fcn: '<S20>/q3dot'\n   */\n  MARS_B.TmpSignalConversionAtqInport1[0] = ((rtb_kxj * rtb_Sum2[0] + uTmp_idx_0\n    * rtb_Sum2[1]) + uTmp_idx_1 * rtb_Sum2[2]) * -0.5;\n  MARS_B.TmpSignalConversionAtqInport1[1] = ((rtb_jxi * rtb_Sum2[0] + uTmp_idx_0\n    * rtb_Sum2[2]) - uTmp_idx_1 * rtb_Sum2[1]) * 0.5;\n  MARS_B.TmpSignalConversionAtqInport1[2] = ((rtb_jxi * rtb_Sum2[1] + uTmp_idx_1\n    * rtb_Sum2[0]) - rtb_kxj * rtb_Sum2[2]) * 0.5;\n  MARS_B.TmpSignalConversionAtqInport1[3] = ((rtb_jxi * rtb_Sum2[2] + rtb_kxj *\n    rtb_Sum2[1]) - uTmp_idx_0 * rtb_Sum2[0]) * 0.5;\n  for (i = 0; i < 3; i++) {\n    /* Product: '<S5>/Product1' */\n    MARS_B.Product1[i] = 0.0;\n\n    /* Product: '<S5>/Product1' incorporates:\n     *  Concatenate: '<S139>/Vector Concatenate'\n     */\n    phi_tmp = rtb_VectorConcatenate_b[i];\n\n    /* Product: '<S5>/Product1' incorporates:\n     *  LLA2ECEF: '<S5>/LLA to ECEF Position'\n     */\n    MARS_B.Product1[i] += phi_tmp * 2.5914855245392346E+6;\n\n    /* Math: '<S5>/Math Function1' incorporates:\n     *  Math: '<S4>/Math Function'\n     */\n    rtb_Product4_g_tmp[3 * i] = phi_tmp;\n\n    /* Product: '<S5>/Product1' incorporates:\n     *  Concatenate: '<S139>/Vector Concatenate'\n     */\n    phi_tmp = rtb_VectorConcatenate_b[i + 3];\n\n    /* Product: '<S5>/Product1' incorporates:\n     *  LLA2ECEF: '<S5>/LLA to ECEF Position'\n     */\n    MARS_B.Product1[i] += phi_tmp * -1.0790178821353326E+6;\n\n    /* Math: '<S5>/Math Function1' incorporates:\n     *  Math: '<S4>/Math Function'\n     */\n    rtb_Product4_g_tmp[3 * i + 1] = phi_tmp;\n\n    /* Product: '<S5>/Product1' incorporates:\n     *  Concatenate: '<S139>/Vector Concatenate'\n     */\n    phi_tmp = rtb_VectorConcatenate_b[i + 6];\n\n    /* Product: '<S5>/Product1' incorporates:\n     *  LLA2ECEF: '<S5>/LLA to ECEF Position'\n     */\n    MARS_B.Product1[i] += phi_tmp * 5.7079969783558194E+6;\n\n    /* Math: '<S5>/Math Function1' incorporates:\n     *  Math: '<S4>/Math Function'\n     */\n    rtb_Product4_g_tmp[3 * i + 2] = phi_tmp;\n  }\n\n  for (i = 0; i < 3; i++) {\n    /* Product: '<S5>/Product5' incorporates:\n     *  Concatenate: '<S114>/Vector Concatenate'\n     *  Integrator: '<S6>/ub,vb,wb'\n     *  Math: '<S5>/Math Function2'\n     */\n    MARS_B.Product5[i] = 0.0;\n    MARS_B.Product5[i] += rtb_VectorConcatenate_f[3 * i] * MARS_X.ubvbwb_CSTATE\n      [0];\n    MARS_B.Product5[i] += rtb_VectorConcatenate_f[3 * i + 1] *\n      MARS_X.ubvbwb_CSTATE[1];\n    MARS_B.Product5[i] += rtb_VectorConcatenate_f[3 * i + 2] *\n      MARS_X.ubvbwb_CSTATE[2];\n\n    /* Product: '<S5>/Product4' incorporates:\n     *  Math: '<S5>/Math Function1'\n     */\n    rtb_Sum2[i] = (rtb_Product4_g_tmp[i + 3] * 0.0 + rtb_Product4_g_tmp[i] * 0.0)\n      + rtb_Product4_g_tmp[i + 6] * 7.292115E-5;\n  }\n\n  /* Integrator: '<S5>/p' */\n  if (MARS_DW.p_IWORK != 0) {\n    MARS_X.p_CSTATE[0] = MARS_B.Product1[0];\n    MARS_X.p_CSTATE[1] = MARS_B.Product1[1];\n    MARS_X.p_CSTATE[2] = MARS_B.Product1[2];\n  }\n\n  /* Sum: '<S122>/Sum' incorporates:\n   *  Integrator: '<S5>/p'\n   *  Product: '<S123>/i x j'\n   *  Product: '<S123>/j x k'\n   *  Product: '<S123>/k x i'\n   *  Product: '<S124>/i x k'\n   *  Product: '<S124>/j x i'\n   *  Product: '<S124>/k x j'\n   */\n  tmp_0[0] = MARS_X.p_CSTATE[1] * rtb_Sum2[2];\n  tmp_0[1] = rtb_Sum2[0] * MARS_X.p_CSTATE[2];\n  tmp_0[2] = MARS_X.p_CSTATE[0] * rtb_Sum2[1];\n  rtb_Sum2_0[0] = rtb_Sum2[1] * MARS_X.p_CSTATE[2];\n  rtb_Sum2_0[1] = MARS_X.p_CSTATE[0] * rtb_Sum2[2];\n  rtb_Sum2_0[2] = rtb_Sum2[0] * MARS_X.p_CSTATE[1];\n  for (i = 0; i < 3; i++) {\n    /* Sum: '<S5>/Sum2' */\n    phi_tmp = 0.0;\n    for (int32_T i_0{0}; i_0 < 3; i_0++) {\n      /* Math: '<S5>/Math Function' incorporates:\n       *  Concatenate: '<S114>/Vector Concatenate'\n       *  Math: '<S4>/Math Function'\n       *  Product: '<S4>/Product1'\n       *  Product: '<S5>/Product2'\n       */\n      Product4_tmp = 3 * i_0 + i;\n      rtb_VectorConcatenate_b[Product4_tmp] = 0.0;\n      rtb_VectorConcatenate_b[Product4_tmp] += rtb_Product4_g_tmp[3 * i] *\n        rtb_VectorConcatenate_f[i_0];\n      rtb_VectorConcatenate_b[Product4_tmp] += rtb_Product4_g_tmp[3 * i + 1] *\n        rtb_VectorConcatenate_f[i_0 + 3];\n      rtb_VectorConcatenate_b[Product4_tmp] += rtb_Product4_g_tmp[3 * i + 2] *\n        rtb_VectorConcatenate_f[i_0 + 6];\n\n      /* Sum: '<S5>/Sum2' incorporates:\n       *  Integrator: '<S6>/ub,vb,wb'\n       *  Product: '<S5>/Product2'\n       */\n      phi_tmp += rtb_VectorConcatenate_b[Product4_tmp] *\n        MARS_X.ubvbwb_CSTATE[i_0];\n    }\n\n    /* Sum: '<S5>/Sum2' incorporates:\n     *  Product: '<S5>/Product2'\n     *  Sum: '<S122>/Sum'\n     */\n    MARS_B.Sum2_e[i] = phi_tmp - (tmp_0[i] - rtb_Sum2_0[i]);\n\n    /* Sum: '<S6>/Sum2' incorporates:\n     *  Integrator: '<S1>/p,q,r '\n     *  Product: '<S6>/Product2'\n     */\n    rtb_Sum_hp[i] += MARS_X.pqr_CSTATE[i];\n  }\n\n  /* Sum: '<S127>/Sum' incorporates:\n   *  Constant: '<S1>/omega_earth2'\n   *  Constant: '<S1>/omega_earth3'\n   *  Integrator: '<S5>/p1'\n   *  Product: '<S132>/i x j'\n   *  Product: '<S132>/j x k'\n   *  Product: '<S132>/k x i'\n   *  Product: '<S133>/i x k'\n   *  Product: '<S133>/j x i'\n   *  Product: '<S133>/k x j'\n   */\n  rtb_Sum2[0] = 0.0 * MARS_X.p1_CSTATE[2] - 7.292115E-5 * MARS_X.p1_CSTATE[1];\n  rtb_Sum2[1] = 7.292115E-5 * MARS_X.p1_CSTATE[0] - 0.0 * MARS_X.p1_CSTATE[2];\n  rtb_Sum2[2] = 0.0 * MARS_X.p1_CSTATE[1] - 0.0 * MARS_X.p1_CSTATE[0];\n\n  /* Sum: '<S125>/Sum' incorporates:\n   *  Integrator: '<S6>/ub,vb,wb'\n   *  Product: '<S128>/i x j'\n   *  Product: '<S128>/j x k'\n   *  Product: '<S128>/k x i'\n   *  Product: '<S129>/i x k'\n   *  Product: '<S129>/j x i'\n   *  Product: '<S129>/k x j'\n   */\n  tmp_0[0] = MARS_X.ubvbwb_CSTATE[1] * rtb_Sum_hp[2];\n  tmp_0[1] = rtb_Sum_hp[0] * MARS_X.ubvbwb_CSTATE[2];\n  tmp_0[2] = MARS_X.ubvbwb_CSTATE[0] * rtb_Sum_hp[1];\n  rtb_Sum2_0[0] = rtb_Sum_hp[1] * MARS_X.ubvbwb_CSTATE[2];\n  rtb_Sum2_0[1] = MARS_X.ubvbwb_CSTATE[0] * rtb_Sum_hp[2];\n  rtb_Sum2_0[2] = rtb_Sum_hp[0] * MARS_X.ubvbwb_CSTATE[1];\n\n  /* Sum: '<S126>/Sum' incorporates:\n   *  Constant: '<S1>/omega_earth2'\n   *  Constant: '<S1>/omega_earth3'\n   *  Product: '<S130>/i x j'\n   *  Product: '<S130>/j x k'\n   *  Product: '<S130>/k x i'\n   *  Product: '<S131>/i x k'\n   *  Product: '<S131>/j x i'\n   *  Product: '<S131>/k x j'\n   */\n  phi_tmp = 0.0 * rtb_Sum2[2] - 7.292115E-5 * rtb_Sum2[1];\n  rtb_q0dot = 7.292115E-5 * rtb_Sum2[0] - 0.0 * rtb_Sum2[2];\n  uTmp_idx_0 = 0.0 * rtb_Sum2[1] - 0.0 * rtb_Sum2[0];\n  for (i = 0; i < 3; i++) {\n    /* Sum: '<S6>/Sum' incorporates:\n     *  Concatenate: '<S114>/Vector Concatenate'\n     *  Product: '<S6>/Product1'\n     *  Sum: '<S125>/Sum'\n     */\n    uTmp_idx_1 = ((tmp_0[i] - rtb_Sum2_0[i]) - ((rtb_VectorConcatenate_f[i + 3] *\n      rtb_q0dot + rtb_VectorConcatenate_f[i] * phi_tmp) +\n      rtb_VectorConcatenate_f[i + 6] * uTmp_idx_0)) + MARS_ConstB.Product[i];\n\n    /* DeadZone: '<S6>/Dead Zone' */\n    if (uTmp_idx_1 > 2.2204460492503131E-16) {\n      /* DeadZone: '<S6>/Dead Zone' */\n      MARS_B.DeadZone[i] = uTmp_idx_1 - 2.2204460492503131E-16;\n    } else if (uTmp_idx_1 >= -2.2204460492503131E-16) {\n      /* DeadZone: '<S6>/Dead Zone' */\n      MARS_B.DeadZone[i] = 0.0;\n    } else {\n      /* DeadZone: '<S6>/Dead Zone' */\n      MARS_B.DeadZone[i] = uTmp_idx_1 - -2.2204460492503131E-16;\n    }\n\n    /* End of DeadZone: '<S6>/Dead Zone' */\n\n    /* Sum: '<S6>/Sum' incorporates:\n     *  Integrator: '<S1>/p,q,r '\n     *  Product: '<S135>/Product'\n     *  Product: '<S6>/Product1'\n     *  Selector: '<S7>/Selector'\n     */\n    rtb_Sum_hp[i] = (MARS_ConstB.Selector[i + 3] * MARS_X.pqr_CSTATE[1] +\n                     MARS_ConstB.Selector[i] * MARS_X.pqr_CSTATE[0]) +\n      MARS_ConstB.Selector[i + 6] * MARS_X.pqr_CSTATE[2];\n  }\n\n  /* Sum: '<S134>/Sum' incorporates:\n   *  Integrator: '<S1>/p,q,r '\n   *  Product: '<S137>/i x j'\n   *  Product: '<S137>/j x k'\n   *  Product: '<S137>/k x i'\n   *  Product: '<S138>/i x k'\n   *  Product: '<S138>/j x i'\n   *  Product: '<S138>/k x j'\n   */\n  tmp_0[0] = MARS_X.pqr_CSTATE[1] * rtb_Sum_hp[2];\n  tmp_0[1] = rtb_Sum_hp[0] * MARS_X.pqr_CSTATE[2];\n  tmp_0[2] = MARS_X.pqr_CSTATE[0] * rtb_Sum_hp[1];\n  rtb_Sum2_0[0] = rtb_Sum_hp[1] * MARS_X.pqr_CSTATE[2];\n  rtb_Sum2_0[1] = MARS_X.pqr_CSTATE[0] * rtb_Sum_hp[2];\n  rtb_Sum2_0[2] = rtb_Sum_hp[0] * MARS_X.pqr_CSTATE[1];\n  for (i = 0; i <= 0; i += 2) {\n    /* Sum: '<S134>/Sum' */\n    tmp_3 = _mm_loadu_pd(&tmp_0[i]);\n    tmp_4 = _mm_loadu_pd(&rtb_Sum2_0[i]);\n    _mm_storeu_pd(&rtb_Sum_hp[i], _mm_sub_pd(tmp_3, tmp_4));\n\n    /* Product: '<S136>/Product' incorporates:\n     *  Integrator: '<S1>/p,q,r '\n     *  Sum: '<S134>/Sum'\n     *  Sum: '<S7>/Sum2'\n     */\n    _mm_storeu_pd(&rtb_Sum2[i], _mm_set1_pd(0.0 * MARS_X.pqr_CSTATE[2] + (0.0 *\n      MARS_X.pqr_CSTATE[1] + 0.0 * MARS_X.pqr_CSTATE[0])));\n  }\n\n  for (i = 2; i < 3; i++) {\n    /* Sum: '<S134>/Sum' */\n    rtb_Sum_hp[i] = tmp_0[i] - rtb_Sum2_0[i];\n\n    /* Product: '<S136>/Product' incorporates:\n     *  Integrator: '<S1>/p,q,r '\n     *  Sum: '<S7>/Sum2'\n     */\n    rtb_Sum2[i] = (0.0 * MARS_X.pqr_CSTATE[1] + 0.0 * MARS_X.pqr_CSTATE[0]) +\n      0.0 * MARS_X.pqr_CSTATE[2];\n  }\n\n  /* Sum: '<S7>/Sum2' incorporates:\n   *  Constant: '<Root>/M_x'\n   *  Constant: '<Root>/M_y'\n   *  Constant: '<Root>/M_z'\n   */\n  tmp_0[0] = (0.0 - rtb_Sum2[0]) - rtb_Sum_hp[0];\n  tmp_0[1] = (0.0 - rtb_Sum2[1]) - rtb_Sum_hp[1];\n  tmp_0[2] = (0.01 - rtb_Sum2[2]) - rtb_Sum_hp[2];\n\n  /* Product: '<S7>/Product2' incorporates:\n   *  Selector: '<S7>/Selector2'\n   */\n  rt_mrdivide_U1d1x3_U2d_9vOrDY9Z(tmp_0, MARS_ConstB.Selector2, MARS_B.Product2);\n  if (rtmIsMajorTimeStep((&MARS_M))) {\n    /* Update for Integrator: '<S5>/p1' */\n    MARS_DW.p1_IWORK = 0;\n\n    /* Update for Integrator: '<S4>/q' */\n    MARS_DW.q_IWORK = 0;\n\n    /* Update for Integrator: '<S1>/p,q,r ' */\n    MARS_DW.pqr_IWORK = 0;\n\n    /* Update for Integrator: '<S5>/p' */\n    MARS_DW.p_IWORK = 0;\n  }                                    /* end MajorTimeStep */\n\n  if (rtmIsMajorTimeStep((&MARS_M))) {\n    rt_ertODEUpdateContinuousStates(&(&MARS_M)->solverInfo);\n\n    /* Update absolute time for base rate */\n    /* The \"clockTick0\" counts the number of times the code of this task has\n     * been executed. The absolute time is the multiplication of \"clockTick0\"\n     * and \"Timing.stepSize0\". Size of \"clockTick0\" ensures timer will not\n     * overflow during the application lifespan selected.\n     */\n    ++(&MARS_M)->Timing.clockTick0;\n    (&MARS_M)->Timing.t[0] = rtsiGetSolverStopTime(&(&MARS_M)->solverInfo);\n\n    {\n      /* Update absolute timer for sample time: [0.016666666666666666s, 0.0s] */\n      /* The \"clockTick1\" counts the number of times the code of this task has\n       * been executed. The resolution of this integer timer is 0.016666666666666666, which is the step size\n       * of the task. Size of \"clockTick1\" ensures timer will not overflow during the\n       * application lifespan selected.\n       */\n      (&MARS_M)->Timing.clockTick1++;\n    }\n  }                                    /* end MajorTimeStep */\n}\n\n/* Derivatives for root system: '<Root>' */\nvoid MARS::MARS_derivatives()\n{\n  XDot_MARS_T *_rtXdot;\n  _rtXdot = ((XDot_MARS_T *) (&MARS_M)->derivs);\n\n  /* Derivatives for Integrator: '<S5>/p1' */\n  _rtXdot->p1_CSTATE[0] = MARS_B.Product5[0];\n  _rtXdot->p1_CSTATE[1] = MARS_B.Product5[1];\n  _rtXdot->p1_CSTATE[2] = MARS_B.Product5[2];\n\n  /* Derivatives for Integrator: '<S4>/q' */\n  _rtXdot->q_CSTATE[0] = MARS_B.TmpSignalConversionAtqInport1[0];\n  _rtXdot->q_CSTATE[1] = MARS_B.TmpSignalConversionAtqInport1[1];\n  _rtXdot->q_CSTATE[2] = MARS_B.TmpSignalConversionAtqInport1[2];\n  _rtXdot->q_CSTATE[3] = MARS_B.TmpSignalConversionAtqInport1[3];\n\n  /* Derivatives for Integrator: '<S8>/Integrator' incorporates:\n   *  Constant: '<S8>/Constant1'\n   */\n  _rtXdot->Integrator_CSTATE = 7.292115E-5;\n\n  /* Derivatives for Integrator: '<S6>/ub,vb,wb' */\n  _rtXdot->ubvbwb_CSTATE[0] = MARS_B.DeadZone[0];\n\n  /* Derivatives for Integrator: '<S1>/p,q,r ' */\n  _rtXdot->pqr_CSTATE[0] = MARS_B.Product2[0];\n\n  /* Derivatives for Integrator: '<S5>/p' */\n  _rtXdot->p_CSTATE[0] = MARS_B.Sum2_e[0];\n\n  /* Derivatives for Integrator: '<S6>/ub,vb,wb' */\n  _rtXdot->ubvbwb_CSTATE[1] = MARS_B.DeadZone[1];\n\n  /* Derivatives for Integrator: '<S1>/p,q,r ' */\n  _rtXdot->pqr_CSTATE[1] = MARS_B.Product2[1];\n\n  /* Derivatives for Integrator: '<S5>/p' */\n  _rtXdot->p_CSTATE[1] = MARS_B.Sum2_e[1];\n\n  /* Derivatives for Integrator: '<S6>/ub,vb,wb' */\n  _rtXdot->ubvbwb_CSTATE[2] = MARS_B.DeadZone[2];\n\n  /* Derivatives for Integrator: '<S1>/p,q,r ' */\n  _rtXdot->pqr_CSTATE[2] = MARS_B.Product2[2];\n\n  /* Derivatives for Integrator: '<S5>/p' */\n  _rtXdot->p_CSTATE[2] = MARS_B.Sum2_e[2];\n}\n\n/* Model initialize function */\nvoid MARS::initialize()\n{\n  /* Registration code */\n\n  /* initialize non-finites */\n  rt_InitInfAndNaN(sizeof(real_T));\n\n  {\n    /* Setup solver object */\n    rtsiSetSimTimeStepPtr(&(&MARS_M)->solverInfo, &(&MARS_M)->Timing.simTimeStep);\n    rtsiSetTPtr(&(&MARS_M)->solverInfo, &rtmGetTPtr((&MARS_M)));\n    rtsiSetStepSizePtr(&(&MARS_M)->solverInfo, &(&MARS_M)->Timing.stepSize0);\n    rtsiSetdXPtr(&(&MARS_M)->solverInfo, &(&MARS_M)->derivs);\n    rtsiSetContStatesPtr(&(&MARS_M)->solverInfo, (real_T **) &(&MARS_M)\n                         ->contStates);\n    rtsiSetNumContStatesPtr(&(&MARS_M)->solverInfo, &(&MARS_M)\n      ->Sizes.numContStates);\n    rtsiSetNumPeriodicContStatesPtr(&(&MARS_M)->solverInfo, &(&MARS_M)\n      ->Sizes.numPeriodicContStates);\n    rtsiSetPeriodicContStateIndicesPtr(&(&MARS_M)->solverInfo, &(&MARS_M)\n      ->periodicContStateIndices);\n    rtsiSetPeriodicContStateRangesPtr(&(&MARS_M)->solverInfo, &(&MARS_M)\n      ->periodicContStateRanges);\n    rtsiSetErrorStatusPtr(&(&MARS_M)->solverInfo, (&rtmGetErrorStatus((&MARS_M))));\n    rtsiSetRTModelPtr(&(&MARS_M)->solverInfo, (&MARS_M));\n  }\n\n  rtsiSetSimTimeStep(&(&MARS_M)->solverInfo, MAJOR_TIME_STEP);\n  (&MARS_M)->intgData.y = (&MARS_M)->odeY;\n  (&MARS_M)->intgData.f[0] = (&MARS_M)->odeF[0];\n  (&MARS_M)->intgData.f[1] = (&MARS_M)->odeF[1];\n  (&MARS_M)->intgData.f[2] = (&MARS_M)->odeF[2];\n  (&MARS_M)->contStates = ((X_MARS_T *) &MARS_X);\n  rtsiSetSolverData(&(&MARS_M)->solverInfo, static_cast<void *>(&(&MARS_M)\n    ->intgData));\n  rtsiSetIsMinorTimeStepWithModeChange(&(&MARS_M)->solverInfo, false);\n  rtsiSetSolverName(&(&MARS_M)->solverInfo,\"ode3\");\n  rtmSetTPtr((&MARS_M), &(&MARS_M)->Timing.tArray[0]);\n  (&MARS_M)->Timing.stepSize0 = 0.016666666666666666;\n  rtmSetFirstInitCond((&MARS_M), 1);\n\n  /* Start for If: '<S17>/If' */\n  MARS_DW.If_ActiveSubsystem = -1;\n\n  /* Start for If: '<S16>/If' */\n  MARS_DW.If_ActiveSubsystem_h = -1;\n\n  /* Start for If: '<S46>/If1' */\n  MARS_DW.If1_ActiveSubsystem = -1;\n\n  /* Start for If: '<S69>/If1' */\n  MARS_DW.If1_ActiveSubsystem_l = -1;\n\n  /* InitializeConditions for Integrator: '<S5>/p1' incorporates:\n   *  Integrator: '<S4>/q'\n   */\n  if (rtmIsFirstInitCond((&MARS_M))) {\n    MARS_X.p1_CSTATE[0] = 0.0;\n    MARS_X.p1_CSTATE[1] = 0.0;\n    MARS_X.p1_CSTATE[2] = 0.0;\n    MARS_X.q_CSTATE[0] = 0.0;\n    MARS_X.q_CSTATE[1] = 0.0;\n    MARS_X.q_CSTATE[2] = 0.0;\n    MARS_X.q_CSTATE[3] = 0.0;\n  }\n\n  MARS_DW.p1_IWORK = 1;\n\n  /* End of InitializeConditions for Integrator: '<S5>/p1' */\n\n  /* InitializeConditions for Integrator: '<S4>/q' */\n  MARS_DW.q_IWORK = 1;\n\n  /* InitializeConditions for Integrator: '<S8>/Integrator' */\n  MARS_X.Integrator_CSTATE = 0.0;\n\n  /* InitializeConditions for Integrator: '<S6>/ub,vb,wb' */\n  MARS_X.ubvbwb_CSTATE[0] = 0.0;\n  MARS_X.ubvbwb_CSTATE[1] = 0.0;\n  MARS_X.ubvbwb_CSTATE[2] = 0.0;\n\n  /* InitializeConditions for Integrator: '<S1>/p,q,r ' incorporates:\n   *  Integrator: '<S5>/p'\n   */\n  if (rtmIsFirstInitCond((&MARS_M))) {\n    MARS_X.pqr_CSTATE[0] = 0.0;\n    MARS_X.pqr_CSTATE[1] = 0.0;\n    MARS_X.pqr_CSTATE[2] = 0.0;\n    MARS_X.p_CSTATE[0] = 0.0;\n    MARS_X.p_CSTATE[1] = 0.0;\n    MARS_X.p_CSTATE[2] = 0.0;\n  }\n\n  MARS_DW.pqr_IWORK = 1;\n\n  /* End of InitializeConditions for Integrator: '<S1>/p,q,r ' */\n\n  /* InitializeConditions for Integrator: '<S5>/p' */\n  MARS_DW.p_IWORK = 1;\n\n  /* SystemInitialize for Merge: '<S17>/Merge' */\n  MARS_B.Merge[0] = 1.0;\n  MARS_B.Merge[1] = 0.0;\n  MARS_B.Merge[2] = 0.0;\n  MARS_B.Merge[3] = 0.0;\n\n  /* SystemInitialize for IfAction SubSystem: '<S16>/AxisRotZeroR3' */\n  /* Start for If: '<S51>/If' */\n  MARS_DW.If_ActiveSubsystem_c0 = -1;\n\n  /* End of SystemInitialize for SubSystem: '<S16>/AxisRotZeroR3' */\n\n  /* SystemInitialize for IfAction SubSystem: '<S16>/AxisRotDefault' */\n  /* Start for If: '<S47>/If' */\n  MARS_DW.If_ActiveSubsystem_c = -1;\n\n  /* End of SystemInitialize for SubSystem: '<S16>/AxisRotDefault' */\n\n  /* set \"at time zero\" to false */\n  if (rtmIsFirstInitCond((&MARS_M))) {\n    rtmSetFirstInitCond((&MARS_M), 0);\n  }\n}\n\n/* Model terminate function */\nvoid MARS::terminate()\n{\n  /* (no terminate code required) */\n}\n\n/* Constructor */\nMARS::MARS() :\n  MARS_B(),\n  MARS_DW(),\n  MARS_X(),\n  MARS_M()\n{\n  /* Currently there is no constructor body generated.*/\n}\n\n/* Destructor */\nMARS::~MARS()\n{\n  /* Currently there is no destructor body generated.*/\n}\n\n/* Real-Time Model get method */\nRT_MODEL_MARS_T * MARS::getRTM()\n{\n  return (&MARS_M);\n}\n"},{"name":"MARS.h","type":"header","group":"model","path":"/home/aman/GitHub/flightTestingLab/controls/Ingenuity_Modelling/MATLAB-env/MARS_grt_rtw","tag":"","groupDisplay":"Model files","code":"/*\n * MARS.h\n *\n * Academic License - for use in teaching, academic research, and meeting\n * course requirements at degree granting institutions only.  Not for\n * government, commercial, or other organizational use.\n *\n * Code generation for model \"MARS\".\n *\n * Model version              : 1.6\n * Simulink Coder version : 9.7 (R2022a) 13-Nov-2021\n * C++ source code generated on : Thu Oct 20 23:51:39 2022\n *\n * Target selection: grt.tlc\n * Note: GRT includes extra infrastructure and instrumentation for prototyping\n * Embedded hardware selection: Intel->x86-64 (Windows64)\n * Code generation objective: Execution efficiency\n * Validation result: Not run\n */\n\n#ifndef RTW_HEADER_MARS_h_\n#define RTW_HEADER_MARS_h_\n#include \"rtwtypes.h\"\n#include \"rtw_continuous.h\"\n#include \"rtw_solver.h\"\n#include \"MARS_types.h\"\n#include <cstring>\n\nextern \"C\" {\n\n#include \"rt_nonfinite.h\"\n\n}\n/* Macros for accessing real-time model data structure */\n#ifndef rtmGetContStateDisabled\n#define rtmGetContStateDisabled(rtm)   ((rtm)->contStateDisabled)\n#endif\n\n#ifndef rtmSetContStateDisabled\n#define rtmSetContStateDisabled(rtm, val) ((rtm)->contStateDisabled = (val))\n#endif\n\n#ifndef rtmGetContStates\n#define rtmGetContStates(rtm)          ((rtm)->contStates)\n#endif\n\n#ifndef rtmSetContStates\n#define rtmSetContStates(rtm, val)     ((rtm)->contStates = (val))\n#endif\n\n#ifndef rtmGetContTimeOutputInconsistentWithStateAtMajorStepFlag\n#define rtmGetContTimeOutputInconsistentWithStateAtMajorStepFlag(rtm) ((rtm)->CTOutputIncnstWithState)\n#endif\n\n#ifndef rtmSetContTimeOutputInconsistentWithStateAtMajorStepFlag\n#define rtmSetContTimeOutputInconsistentWithStateAtMajorStepFlag(rtm, val) ((rtm)->CTOutputIncnstWithState = (val))\n#endif\n\n#ifndef rtmGetDerivCacheNeedsReset\n#define rtmGetDerivCacheNeedsReset(rtm) ((rtm)->derivCacheNeedsReset)\n#endif\n\n#ifndef rtmSetDerivCacheNeedsReset\n#define rtmSetDerivCacheNeedsReset(rtm, val) ((rtm)->derivCacheNeedsReset = (val))\n#endif\n\n#ifndef rtmGetIntgData\n#define rtmGetIntgData(rtm)            ((rtm)->intgData)\n#endif\n\n#ifndef rtmSetIntgData\n#define rtmSetIntgData(rtm, val)       ((rtm)->intgData = (val))\n#endif\n\n#ifndef rtmGetOdeF\n#define rtmGetOdeF(rtm)                ((rtm)->odeF)\n#endif\n\n#ifndef rtmSetOdeF\n#define rtmSetOdeF(rtm, val)           ((rtm)->odeF = (val))\n#endif\n\n#ifndef rtmGetOdeY\n#define rtmGetOdeY(rtm)                ((rtm)->odeY)\n#endif\n\n#ifndef rtmSetOdeY\n#define rtmSetOdeY(rtm, val)           ((rtm)->odeY = (val))\n#endif\n\n#ifndef rtmGetPeriodicContStateIndices\n#define rtmGetPeriodicContStateIndices(rtm) ((rtm)->periodicContStateIndices)\n#endif\n\n#ifndef rtmSetPeriodicContStateIndices\n#define rtmSetPeriodicContStateIndices(rtm, val) ((rtm)->periodicContStateIndices = (val))\n#endif\n\n#ifndef rtmGetPeriodicContStateRanges\n#define rtmGetPeriodicContStateRanges(rtm) ((rtm)->periodicContStateRanges)\n#endif\n\n#ifndef rtmSetPeriodicContStateRanges\n#define rtmSetPeriodicContStateRanges(rtm, val) ((rtm)->periodicContStateRanges = (val))\n#endif\n\n#ifndef rtmGetZCCacheNeedsReset\n#define rtmGetZCCacheNeedsReset(rtm)   ((rtm)->zCCacheNeedsReset)\n#endif\n\n#ifndef rtmSetZCCacheNeedsReset\n#define rtmSetZCCacheNeedsReset(rtm, val) ((rtm)->zCCacheNeedsReset = (val))\n#endif\n\n#ifndef rtmGetdX\n#define rtmGetdX(rtm)                  ((rtm)->derivs)\n#endif\n\n#ifndef rtmSetdX\n#define rtmSetdX(rtm, val)             ((rtm)->derivs = (val))\n#endif\n\n#ifndef rtmGetErrorStatus\n#define rtmGetErrorStatus(rtm)         ((rtm)->errorStatus)\n#endif\n\n#ifndef rtmSetErrorStatus\n#define rtmSetErrorStatus(rtm, val)    ((rtm)->errorStatus = (val))\n#endif\n\n#ifndef rtmGetStopRequested\n#define rtmGetStopRequested(rtm)       ((rtm)->Timing.stopRequestedFlag)\n#endif\n\n#ifndef rtmSetStopRequested\n#define rtmSetStopRequested(rtm, val)  ((rtm)->Timing.stopRequestedFlag = (val))\n#endif\n\n#ifndef rtmGetStopRequestedPtr\n#define rtmGetStopRequestedPtr(rtm)    (&((rtm)->Timing.stopRequestedFlag))\n#endif\n\n#ifndef rtmGetT\n#define rtmGetT(rtm)                   (rtmGetTPtr((rtm))[0])\n#endif\n\n#ifndef rtmGetTPtr\n#define rtmGetTPtr(rtm)                ((rtm)->Timing.t)\n#endif\n\n/* Block signals (default storage) */\nstruct B_MARS_T {\n  real_T Merge[4];                     /* '<S17>/Merge' */\n  real_T Product4[9];                  /* '<S4>/Product4' */\n  real_T Sum2[3];                      /* '<S1>/Sum2' */\n  real_T TmpSignalConversionAtqInport1[4];/* '<S4>/qdot' */\n  real_T Product1[3];                  /* '<S5>/Product1' */\n  real_T Product5[3];                  /* '<S5>/Product5' */\n  real_T Sum2_e[3];                    /* '<S5>/Sum2' */\n  real_T DeadZone[3];                  /* '<S6>/Dead Zone' */\n  real_T Product2[3];                  /* '<S7>/Product2' */\n  real_T Merge_j;                      /* '<S47>/Merge' */\n  real_T Merge_j2;                     /* '<S51>/Merge' */\n};\n\n/* Block states (default storage) for system '<Root>' */\nstruct DW_MARS_T {\n  real_T Product2_DWORK4[9];           /* '<S7>/Product2' */\n  int_T p1_IWORK;                      /* '<S5>/p1' */\n  int_T q_IWORK;                       /* '<S4>/q' */\n  int_T pqr_IWORK;                     /* '<S1>/p,q,r ' */\n  int_T p_IWORK;                       /* '<S5>/p' */\n  int8_T If_ActiveSubsystem;           /* '<S17>/If' */\n  int8_T If_ActiveSubsystem_h;         /* '<S16>/If' */\n  int8_T If1_ActiveSubsystem;          /* '<S46>/If1' */\n  int8_T If1_ActiveSubsystem_l;        /* '<S69>/If1' */\n  int8_T If_ActiveSubsystem_c;         /* '<S47>/If' */\n  int8_T If_ActiveSubsystem_c0;        /* '<S51>/If' */\n};\n\n/* Continuous states (default storage) */\nstruct X_MARS_T {\n  real_T p1_CSTATE[3];                 /* '<S5>/p1' */\n  real_T q_CSTATE[4];                  /* '<S4>/q' */\n  real_T Integrator_CSTATE;            /* '<S8>/Integrator' */\n  real_T ubvbwb_CSTATE[3];             /* '<S6>/ub,vb,wb' */\n  real_T pqr_CSTATE[3];                /* '<S1>/p,q,r ' */\n  real_T p_CSTATE[3];                  /* '<S5>/p' */\n};\n\n/* State derivatives (default storage) */\nstruct XDot_MARS_T {\n  real_T p1_CSTATE[3];                 /* '<S5>/p1' */\n  real_T q_CSTATE[4];                  /* '<S4>/q' */\n  real_T Integrator_CSTATE;            /* '<S8>/Integrator' */\n  real_T ubvbwb_CSTATE[3];             /* '<S6>/ub,vb,wb' */\n  real_T pqr_CSTATE[3];                /* '<S1>/p,q,r ' */\n  real_T p_CSTATE[3];                  /* '<S5>/p' */\n};\n\n/* State disabled  */\nstruct XDis_MARS_T {\n  boolean_T p1_CSTATE[3];              /* '<S5>/p1' */\n  boolean_T q_CSTATE[4];               /* '<S4>/q' */\n  boolean_T Integrator_CSTATE;         /* '<S8>/Integrator' */\n  boolean_T ubvbwb_CSTATE[3];          /* '<S6>/ub,vb,wb' */\n  boolean_T pqr_CSTATE[3];             /* '<S1>/p,q,r ' */\n  boolean_T p_CSTATE[3];               /* '<S5>/p' */\n};\n\n/* Invariant block signals (default storage) */\nstruct ConstB_MARS_T {\n  real_T Product2[9];                  /* '<S4>/Product2' */\n  real_T Selector[9];                  /* '<S7>/Selector' */\n  real_T Selector2[9];                 /* '<S7>/Selector2' */\n  real_T Product[3];                   /* '<S1>/Product' */\n  real_T Abs2[9];                      /* '<S96>/Abs2' */\n  real_T Product_n[3];                 /* '<S71>/Product' */\n  real_T Product_l[3];                 /* '<S73>/Product' */\n  real_T Product_d[3];                 /* '<S72>/Product' */\n  real_T Add_o;                        /* '<S90>/Add' */\n  real_T Add_jx;                       /* '<S91>/Add' */\n  real_T Add_n;                        /* '<S92>/Add' */\n};\n\n#ifndef ODE3_INTG\n#define ODE3_INTG\n\n/* ODE3 Integration Data */\nstruct ODE3_IntgData {\n  real_T *y;                           /* output */\n  real_T *f[3];                        /* derivatives */\n};\n\n#endif\n\n/* Constant parameters (default storage) */\nstruct ConstP_MARS_T {\n  /* Pooled Parameter (Expression: -eye(3))\n   * Referenced by:\n   *   '<S58>/Bias1'\n   *   '<S96>/Bias1'\n   */\n  real_T pooled5[9];\n};\n\n/* Real-time Model Data Structure */\nstruct tag_RTM_MARS_T {\n  const char_T *errorStatus;\n  RTWSolverInfo solverInfo;\n  X_MARS_T *contStates;\n  int_T *periodicContStateIndices;\n  real_T *periodicContStateRanges;\n  real_T *derivs;\n  boolean_T *contStateDisabled;\n  boolean_T zCCacheNeedsReset;\n  boolean_T derivCacheNeedsReset;\n  boolean_T CTOutputIncnstWithState;\n  real_T odeY[17];\n  real_T odeF[3][17];\n  ODE3_IntgData intgData;\n\n  /*\n   * Sizes:\n   * The following substructure contains sizes information\n   * for many of the model attributes such as inputs, outputs,\n   * dwork, sample times, etc.\n   */\n  struct {\n    int_T numContStates;\n    int_T numPeriodicContStates;\n    int_T numSampTimes;\n  } Sizes;\n\n  /*\n   * Timing:\n   * The following substructure contains information regarding\n   * the timing information for the model.\n   */\n  struct {\n    uint32_T clockTick0;\n    time_T stepSize0;\n    uint32_T clockTick1;\n    boolean_T firstInitCondFlag;\n    SimTimeStep simTimeStep;\n    boolean_T stopRequestedFlag;\n    time_T *t;\n    time_T tArray[2];\n  } Timing;\n};\n\nextern const ConstB_MARS_T MARS_ConstB;/* constant block i/o */\n\n/* Constant parameters (default storage) */\nextern const ConstP_MARS_T MARS_ConstP;\n\n/* Class declaration for model MARS */\nclass MARS final\n{\n  /* public data and function members */\n public:\n  /* Copy Constructor */\n  MARS(MARS const&) = delete;\n\n  /* Assignment Operator */\n  MARS& operator= (MARS const&) & = delete;\n\n  /* Move Constructor */\n  MARS(MARS &&) = delete;\n\n  /* Move Assignment Operator */\n  MARS& operator= (MARS &&) = delete;\n\n  /* Real-Time Model get method */\n  RT_MODEL_MARS_T * getRTM();\n\n  /* model start function */\n  void start();\n\n  /* Initial conditions function */\n  void initialize();\n\n  /* model step function */\n  void step();\n\n  /* model terminate function */\n  static void terminate();\n\n  /* Constructor */\n  MARS();\n\n  /* Destructor */\n  ~MARS();\n\n  /* private data and function members */\n private:\n  /* Block signals */\n  B_MARS_T MARS_B;\n\n  /* Block states */\n  DW_MARS_T MARS_DW;\n\n  /* Block continuous states */\n  X_MARS_T MARS_X;\n\n  /* private member function(s) for subsystem '<S51>/If Action Subsystem2'*/\n  static void MARS_IfActionSubsystem2(real_T rtu_In, real_T *rty_OutOrig);\n\n  /* private member function(s) for subsystem '<S55>/If Not Proper'*/\n  static void MARS_IfNotProper(real_T rtp_action);\n\n  /* private member function(s) for subsystem '<S55>/Else If Not Orthogonal'*/\n  static void MARS_ElseIfNotOrthogonal(real_T rtp_action);\n\n  /* Continuous states update member function*/\n  void rt_ertODEUpdateContinuousStates(RTWSolverInfo *si );\n\n  /* Derivatives member function */\n  void MARS_derivatives();\n\n  /* Real-Time Model */\n  RT_MODEL_MARS_T MARS_M;\n};\n\n/*-\n * These blocks were eliminated from the model due to optimizations:\n *\n * Block '<S1>/Math Function1' : Unused code path elimination\n * Block '<S1>/Product1' : Unused code path elimination\n * Block '<S1>/Sum1' : Unused code path elimination\n * Block '<S11>/Unit Conversion' : Unused code path elimination\n * Block '<S12>/Unit Conversion' : Unused code path elimination\n * Block '<S31>/Reshape (9) to [3x3] column-major' : Reshape block reduction\n * Block '<S42>/Reshape (9) to [3x3] column-major' : Reshape block reduction\n * Block '<S45>/Reshape' : Reshape block reduction\n * Block '<S45>/Reshape1' : Reshape block reduction\n * Block '<S45>/Reshape2' : Reshape block reduction\n * Block '<S58>/Reshape' : Reshape block reduction\n * Block '<S17>/Reshape 3x3 -> 9' : Reshape block reduction\n * Block '<S96>/Reshape' : Reshape block reduction\n * Block '<S103>/Reshape' : Reshape block reduction\n * Block '<S114>/Reshape (9) to [3x3] column-major' : Reshape block reduction\n * Block '<S118>/Reshape (9) to [3x3] column-major' : Reshape block reduction\n * Block '<S135>/Reshape1' : Reshape block reduction\n * Block '<S135>/Reshape2' : Reshape block reduction\n * Block '<S136>/Reshape1' : Reshape block reduction\n * Block '<S136>/Reshape2' : Reshape block reduction\n * Block '<S7>/Reshape' : Reshape block reduction\n * Block '<S7>/Reshape1' : Reshape block reduction\n * Block '<S139>/Reshape (9) to [3x3] column-major' : Reshape block reduction\n * Block '<S2>/Rate Transition' : Eliminated since input and output rates are identical\n */\n\n/*-\n * The generated code includes comments that allow you to trace directly\n * back to the appropriate location in the model.  The basic format\n * is <system>/block_name, where system is the system number (uniquely\n * assigned by Simulink) and block_name is the name of the block.\n *\n * Use the MATLAB hilite_system command to trace the generated code back\n * to the model.  For example,\n *\n * hilite_system('<S3>')    - opens system 3\n * hilite_system('<S3>/Kp') - opens and selects block Kp which resides in S3\n *\n * Here is the system hierarchy for this model\n *\n * '<Root>' : 'MARS'\n * '<S1>'   : 'MARS/6DOF ECEF (Quaternion)'\n * '<S2>'   : 'MARS/FlightGear Preconfigured 6DoF Animation'\n * '<S3>'   : 'MARS/6DOF ECEF (Quaternion)/Angle Conversion'\n * '<S4>'   : 'MARS/6DOF ECEF (Quaternion)/Calculate DCM & Euler Angles'\n * '<S5>'   : 'MARS/6DOF ECEF (Quaternion)/Calculate Position in EI '\n * '<S6>'   : 'MARS/6DOF ECEF (Quaternion)/Calculate Velocity in Body Axes'\n * '<S7>'   : 'MARS/6DOF ECEF (Quaternion)/Calculate omega_dot'\n * '<S8>'   : 'MARS/6DOF ECEF (Quaternion)/Celestial Longitude of Greenwich'\n * '<S9>'   : 'MARS/6DOF ECEF (Quaternion)/Determine Force,  Mass & Inertia'\n * '<S10>'  : 'MARS/6DOF ECEF (Quaternion)/ECEF to Inertial'\n * '<S11>'  : 'MARS/6DOF ECEF (Quaternion)/Velocity Conversion'\n * '<S12>'  : 'MARS/6DOF ECEF (Quaternion)/Velocity Conversion2'\n * '<S13>'  : 'MARS/6DOF ECEF (Quaternion)/w_ned'\n * '<S14>'  : 'MARS/6DOF ECEF (Quaternion)/Calculate DCM & Euler Angles/Direction Cosine Matrix ECEF to NED'\n * '<S15>'  : 'MARS/6DOF ECEF (Quaternion)/Calculate DCM & Euler Angles/Direction Cosine Matrix ECEF to NED1'\n * '<S16>'  : 'MARS/6DOF ECEF (Quaternion)/Calculate DCM & Euler Angles/Direction Cosine Matrix to Rotation Angles'\n * '<S17>'  : 'MARS/6DOF ECEF (Quaternion)/Calculate DCM & Euler Angles/Direction Cosine Matrix  to Quaternions'\n * '<S18>'  : 'MARS/6DOF ECEF (Quaternion)/Calculate DCM & Euler Angles/Quaternions to  Direction Cosine Matrix'\n * '<S19>'  : 'MARS/6DOF ECEF (Quaternion)/Calculate DCM & Euler Angles/Rotation Angles to Direction Cosine Matrix'\n * '<S20>'  : 'MARS/6DOF ECEF (Quaternion)/Calculate DCM & Euler Angles/qdot'\n * '<S21>'  : 'MARS/6DOF ECEF (Quaternion)/Calculate DCM & Euler Angles/Direction Cosine Matrix ECEF to NED/A11'\n * '<S22>'  : 'MARS/6DOF ECEF (Quaternion)/Calculate DCM & Euler Angles/Direction Cosine Matrix ECEF to NED/A12'\n * '<S23>'  : 'MARS/6DOF ECEF (Quaternion)/Calculate DCM & Euler Angles/Direction Cosine Matrix ECEF to NED/A13'\n * '<S24>'  : 'MARS/6DOF ECEF (Quaternion)/Calculate DCM & Euler Angles/Direction Cosine Matrix ECEF to NED/A21'\n * '<S25>'  : 'MARS/6DOF ECEF (Quaternion)/Calculate DCM & Euler Angles/Direction Cosine Matrix ECEF to NED/A22'\n * '<S26>'  : 'MARS/6DOF ECEF (Quaternion)/Calculate DCM & Euler Angles/Direction Cosine Matrix ECEF to NED/A23'\n * '<S27>'  : 'MARS/6DOF ECEF (Quaternion)/Calculate DCM & Euler Angles/Direction Cosine Matrix ECEF to NED/A31'\n * '<S28>'  : 'MARS/6DOF ECEF (Quaternion)/Calculate DCM & Euler Angles/Direction Cosine Matrix ECEF to NED/A32'\n * '<S29>'  : 'MARS/6DOF ECEF (Quaternion)/Calculate DCM & Euler Angles/Direction Cosine Matrix ECEF to NED/A33'\n * '<S30>'  : 'MARS/6DOF ECEF (Quaternion)/Calculate DCM & Euler Angles/Direction Cosine Matrix ECEF to NED/Angle Conversion'\n * '<S31>'  : 'MARS/6DOF ECEF (Quaternion)/Calculate DCM & Euler Angles/Direction Cosine Matrix ECEF to NED/Create Transformation Matrix'\n * '<S32>'  : 'MARS/6DOF ECEF (Quaternion)/Calculate DCM & Euler Angles/Direction Cosine Matrix ECEF to NED1/A11'\n * '<S33>'  : 'MARS/6DOF ECEF (Quaternion)/Calculate DCM & Euler Angles/Direction Cosine Matrix ECEF to NED1/A12'\n * '<S34>'  : 'MARS/6DOF ECEF (Quaternion)/Calculate DCM & Euler Angles/Direction Cosine Matrix ECEF to NED1/A13'\n * '<S35>'  : 'MARS/6DOF ECEF (Quaternion)/Calculate DCM & Euler Angles/Direction Cosine Matrix ECEF to NED1/A21'\n * '<S36>'  : 'MARS/6DOF ECEF (Quaternion)/Calculate DCM & Euler Angles/Direction Cosine Matrix ECEF to NED1/A22'\n * '<S37>'  : 'MARS/6DOF ECEF (Quaternion)/Calculate DCM & Euler Angles/Direction Cosine Matrix ECEF to NED1/A23'\n * '<S38>'  : 'MARS/6DOF ECEF (Quaternion)/Calculate DCM & Euler Angles/Direction Cosine Matrix ECEF to NED1/A31'\n * '<S39>'  : 'MARS/6DOF ECEF (Quaternion)/Calculate DCM & Euler Angles/Direction Cosine Matrix ECEF to NED1/A32'\n * '<S40>'  : 'MARS/6DOF ECEF (Quaternion)/Calculate DCM & Euler Angles/Direction Cosine Matrix ECEF to NED1/A33'\n * '<S41>'  : 'MARS/6DOF ECEF (Quaternion)/Calculate DCM & Euler Angles/Direction Cosine Matrix ECEF to NED1/Angle Conversion'\n * '<S42>'  : 'MARS/6DOF ECEF (Quaternion)/Calculate DCM & Euler Angles/Direction Cosine Matrix ECEF to NED1/Create Transformation Matrix'\n * '<S43>'  : 'MARS/6DOF ECEF (Quaternion)/Calculate DCM & Euler Angles/Direction Cosine Matrix to Rotation Angles/AxisRotDefault'\n * '<S44>'  : 'MARS/6DOF ECEF (Quaternion)/Calculate DCM & Euler Angles/Direction Cosine Matrix to Rotation Angles/AxisRotZeroR3'\n * '<S45>'  : 'MARS/6DOF ECEF (Quaternion)/Calculate DCM & Euler Angles/Direction Cosine Matrix to Rotation Angles/Get DCM Values'\n * '<S46>'  : 'MARS/6DOF ECEF (Quaternion)/Calculate DCM & Euler Angles/Direction Cosine Matrix to Rotation Angles/Validate DCM'\n * '<S47>'  : 'MARS/6DOF ECEF (Quaternion)/Calculate DCM & Euler Angles/Direction Cosine Matrix to Rotation Angles/AxisRotDefault/Protect asincos input'\n * '<S48>'  : 'MARS/6DOF ECEF (Quaternion)/Calculate DCM & Euler Angles/Direction Cosine Matrix to Rotation Angles/AxisRotDefault/Protect asincos input/If Action Subsystem'\n * '<S49>'  : 'MARS/6DOF ECEF (Quaternion)/Calculate DCM & Euler Angles/Direction Cosine Matrix to Rotation Angles/AxisRotDefault/Protect asincos input/If Action Subsystem1'\n * '<S50>'  : 'MARS/6DOF ECEF (Quaternion)/Calculate DCM & Euler Angles/Direction Cosine Matrix to Rotation Angles/AxisRotDefault/Protect asincos input/If Action Subsystem2'\n * '<S51>'  : 'MARS/6DOF ECEF (Quaternion)/Calculate DCM & Euler Angles/Direction Cosine Matrix to Rotation Angles/AxisRotZeroR3/Protect asincos input'\n * '<S52>'  : 'MARS/6DOF ECEF (Quaternion)/Calculate DCM & Euler Angles/Direction Cosine Matrix to Rotation Angles/AxisRotZeroR3/Protect asincos input/If Action Subsystem'\n * '<S53>'  : 'MARS/6DOF ECEF (Quaternion)/Calculate DCM & Euler Angles/Direction Cosine Matrix to Rotation Angles/AxisRotZeroR3/Protect asincos input/If Action Subsystem1'\n * '<S54>'  : 'MARS/6DOF ECEF (Quaternion)/Calculate DCM & Euler Angles/Direction Cosine Matrix to Rotation Angles/AxisRotZeroR3/Protect asincos input/If Action Subsystem2'\n * '<S55>'  : 'MARS/6DOF ECEF (Quaternion)/Calculate DCM & Euler Angles/Direction Cosine Matrix to Rotation Angles/Validate DCM/If Warning//Error'\n * '<S56>'  : 'MARS/6DOF ECEF (Quaternion)/Calculate DCM & Euler Angles/Direction Cosine Matrix to Rotation Angles/Validate DCM/If Warning//Error/Else If Not Orthogonal'\n * '<S57>'  : 'MARS/6DOF ECEF (Quaternion)/Calculate DCM & Euler Angles/Direction Cosine Matrix to Rotation Angles/Validate DCM/If Warning//Error/If Not Proper'\n * '<S58>'  : 'MARS/6DOF ECEF (Quaternion)/Calculate DCM & Euler Angles/Direction Cosine Matrix to Rotation Angles/Validate DCM/If Warning//Error/isNotOrthogonal'\n * '<S59>'  : 'MARS/6DOF ECEF (Quaternion)/Calculate DCM & Euler Angles/Direction Cosine Matrix to Rotation Angles/Validate DCM/If Warning//Error/isNotProper'\n * '<S60>'  : 'MARS/6DOF ECEF (Quaternion)/Calculate DCM & Euler Angles/Direction Cosine Matrix to Rotation Angles/Validate DCM/If Warning//Error/Else If Not Orthogonal/Error'\n * '<S61>'  : 'MARS/6DOF ECEF (Quaternion)/Calculate DCM & Euler Angles/Direction Cosine Matrix to Rotation Angles/Validate DCM/If Warning//Error/Else If Not Orthogonal/Warning'\n * '<S62>'  : 'MARS/6DOF ECEF (Quaternion)/Calculate DCM & Euler Angles/Direction Cosine Matrix to Rotation Angles/Validate DCM/If Warning//Error/If Not Proper/Error'\n * '<S63>'  : 'MARS/6DOF ECEF (Quaternion)/Calculate DCM & Euler Angles/Direction Cosine Matrix to Rotation Angles/Validate DCM/If Warning//Error/If Not Proper/Warning'\n * '<S64>'  : 'MARS/6DOF ECEF (Quaternion)/Calculate DCM & Euler Angles/Direction Cosine Matrix to Rotation Angles/Validate DCM/If Warning//Error/isNotOrthogonal/transpose*dcm ~= eye(3)'\n * '<S65>'  : 'MARS/6DOF ECEF (Quaternion)/Calculate DCM & Euler Angles/Direction Cosine Matrix to Rotation Angles/Validate DCM/If Warning//Error/isNotProper/Determinant of 3x3 Matrix'\n * '<S66>'  : 'MARS/6DOF ECEF (Quaternion)/Calculate DCM & Euler Angles/Direction Cosine Matrix to Rotation Angles/Validate DCM/If Warning//Error/isNotProper/determinant does not equal 1'\n * '<S67>'  : 'MARS/6DOF ECEF (Quaternion)/Calculate DCM & Euler Angles/Direction Cosine Matrix  to Quaternions/Negative Trace'\n * '<S68>'  : 'MARS/6DOF ECEF (Quaternion)/Calculate DCM & Euler Angles/Direction Cosine Matrix  to Quaternions/Positive Trace'\n * '<S69>'  : 'MARS/6DOF ECEF (Quaternion)/Calculate DCM & Euler Angles/Direction Cosine Matrix  to Quaternions/Validate DCM'\n * '<S70>'  : 'MARS/6DOF ECEF (Quaternion)/Calculate DCM & Euler Angles/Direction Cosine Matrix  to Quaternions/trace(DCM)'\n * '<S71>'  : 'MARS/6DOF ECEF (Quaternion)/Calculate DCM & Euler Angles/Direction Cosine Matrix  to Quaternions/Negative Trace/Maximum Value at DCM(1,1)'\n * '<S72>'  : 'MARS/6DOF ECEF (Quaternion)/Calculate DCM & Euler Angles/Direction Cosine Matrix  to Quaternions/Negative Trace/Maximum Value at DCM(2,2)'\n * '<S73>'  : 'MARS/6DOF ECEF (Quaternion)/Calculate DCM & Euler Angles/Direction Cosine Matrix  to Quaternions/Negative Trace/Maximum Value at DCM(3,3)'\n * '<S74>'  : 'MARS/6DOF ECEF (Quaternion)/Calculate DCM & Euler Angles/Direction Cosine Matrix  to Quaternions/Negative Trace/diag(DCM)'\n * '<S75>'  : 'MARS/6DOF ECEF (Quaternion)/Calculate DCM & Euler Angles/Direction Cosine Matrix  to Quaternions/Negative Trace/Maximum Value at DCM(1,1)/cos(phi)sin(theta)cos(psi) + sin(phi)sin(psi) -sin(theta)'\n * '<S76>'  : 'MARS/6DOF ECEF (Quaternion)/Calculate DCM & Euler Angles/Direction Cosine Matrix  to Quaternions/Negative Trace/Maximum Value at DCM(1,1)/cos(theta)sin(phi) - (cos(phi)sin(theta)sin(psi) - sin(phi)cos(psi))'\n * '<S77>'  : 'MARS/6DOF ECEF (Quaternion)/Calculate DCM & Euler Angles/Direction Cosine Matrix  to Quaternions/Negative Trace/Maximum Value at DCM(1,1)/cos(theta)sin(psi) + (sin(phi)sin(theta)cos(psi) - cos(phi)sin(psi))'\n * '<S78>'  : 'MARS/6DOF ECEF (Quaternion)/Calculate DCM & Euler Angles/Direction Cosine Matrix  to Quaternions/Negative Trace/Maximum Value at DCM(1,1)/if s~=0; s=0.5//s'\n * '<S79>'  : 'MARS/6DOF ECEF (Quaternion)/Calculate DCM & Euler Angles/Direction Cosine Matrix  to Quaternions/Negative Trace/Maximum Value at DCM(1,1)/u(1) -(u(5)+u(9)) +1'\n * '<S80>'  : 'MARS/6DOF ECEF (Quaternion)/Calculate DCM & Euler Angles/Direction Cosine Matrix  to Quaternions/Negative Trace/Maximum Value at DCM(2,2)/cos(phi)sin(theta)cos(psi) + sin(phi)sin(psi) +sin(theta)'\n * '<S81>'  : 'MARS/6DOF ECEF (Quaternion)/Calculate DCM & Euler Angles/Direction Cosine Matrix  to Quaternions/Negative Trace/Maximum Value at DCM(2,2)/cos(theta)sin(phi) + (cos(phi)sin(theta)sin(psi) - sin(phi)cos(psi))'\n * '<S82>'  : 'MARS/6DOF ECEF (Quaternion)/Calculate DCM & Euler Angles/Direction Cosine Matrix  to Quaternions/Negative Trace/Maximum Value at DCM(2,2)/cos(theta)sin(psi) + (sin(phi)sin(theta)cos(psi) - cos(phi)sin(psi))'\n * '<S83>'  : 'MARS/6DOF ECEF (Quaternion)/Calculate DCM & Euler Angles/Direction Cosine Matrix  to Quaternions/Negative Trace/Maximum Value at DCM(2,2)/if s~=0; s=0.5//s'\n * '<S84>'  : 'MARS/6DOF ECEF (Quaternion)/Calculate DCM & Euler Angles/Direction Cosine Matrix  to Quaternions/Negative Trace/Maximum Value at DCM(2,2)/u(5) -(u(1)+u(9)) +1'\n * '<S85>'  : 'MARS/6DOF ECEF (Quaternion)/Calculate DCM & Euler Angles/Direction Cosine Matrix  to Quaternions/Negative Trace/Maximum Value at DCM(3,3)/cos(phi)sin(theta)cos(psi) + sin(phi)sin(psi) -sin(theta)'\n * '<S86>'  : 'MARS/6DOF ECEF (Quaternion)/Calculate DCM & Euler Angles/Direction Cosine Matrix  to Quaternions/Negative Trace/Maximum Value at DCM(3,3)/cos(theta)sin(phi) + (cos(phi)sin(theta)sin(psi) - sin(phi)cos(psi))'\n * '<S87>'  : 'MARS/6DOF ECEF (Quaternion)/Calculate DCM & Euler Angles/Direction Cosine Matrix  to Quaternions/Negative Trace/Maximum Value at DCM(3,3)/cos(theta)sin(psi) - (sin(phi)sin(theta)cos(psi) - cos(phi)sin(psi))'\n * '<S88>'  : 'MARS/6DOF ECEF (Quaternion)/Calculate DCM & Euler Angles/Direction Cosine Matrix  to Quaternions/Negative Trace/Maximum Value at DCM(3,3)/if s~=0; s=0.5//s'\n * '<S89>'  : 'MARS/6DOF ECEF (Quaternion)/Calculate DCM & Euler Angles/Direction Cosine Matrix  to Quaternions/Negative Trace/Maximum Value at DCM(3,3)/u(9) -(u(1)+u(5)) +1'\n * '<S90>'  : 'MARS/6DOF ECEF (Quaternion)/Calculate DCM & Euler Angles/Direction Cosine Matrix  to Quaternions/Positive Trace/cos(phi)sin(theta)cos(psi) + sin(phi)sin(psi) +sin(theta)'\n * '<S91>'  : 'MARS/6DOF ECEF (Quaternion)/Calculate DCM & Euler Angles/Direction Cosine Matrix  to Quaternions/Positive Trace/cos(theta)sin(phi) - (cos(phi)sin(theta)sin(psi) - sin(phi)cos(psi))'\n * '<S92>'  : 'MARS/6DOF ECEF (Quaternion)/Calculate DCM & Euler Angles/Direction Cosine Matrix  to Quaternions/Positive Trace/cos(theta)sin(psi) - (sin(phi)sin(theta)cos(psi) - cos(phi)sin(psi))'\n * '<S93>'  : 'MARS/6DOF ECEF (Quaternion)/Calculate DCM & Euler Angles/Direction Cosine Matrix  to Quaternions/Validate DCM/If Warning//Error'\n * '<S94>'  : 'MARS/6DOF ECEF (Quaternion)/Calculate DCM & Euler Angles/Direction Cosine Matrix  to Quaternions/Validate DCM/If Warning//Error/Else If Not Orthogonal'\n * '<S95>'  : 'MARS/6DOF ECEF (Quaternion)/Calculate DCM & Euler Angles/Direction Cosine Matrix  to Quaternions/Validate DCM/If Warning//Error/If Not Proper'\n * '<S96>'  : 'MARS/6DOF ECEF (Quaternion)/Calculate DCM & Euler Angles/Direction Cosine Matrix  to Quaternions/Validate DCM/If Warning//Error/isNotOrthogonal'\n * '<S97>'  : 'MARS/6DOF ECEF (Quaternion)/Calculate DCM & Euler Angles/Direction Cosine Matrix  to Quaternions/Validate DCM/If Warning//Error/isNotProper'\n * '<S98>'  : 'MARS/6DOF ECEF (Quaternion)/Calculate DCM & Euler Angles/Direction Cosine Matrix  to Quaternions/Validate DCM/If Warning//Error/Else If Not Orthogonal/Error'\n * '<S99>'  : 'MARS/6DOF ECEF (Quaternion)/Calculate DCM & Euler Angles/Direction Cosine Matrix  to Quaternions/Validate DCM/If Warning//Error/Else If Not Orthogonal/Warning'\n * '<S100>' : 'MARS/6DOF ECEF (Quaternion)/Calculate DCM & Euler Angles/Direction Cosine Matrix  to Quaternions/Validate DCM/If Warning//Error/If Not Proper/Error'\n * '<S101>' : 'MARS/6DOF ECEF (Quaternion)/Calculate DCM & Euler Angles/Direction Cosine Matrix  to Quaternions/Validate DCM/If Warning//Error/If Not Proper/Warning'\n * '<S102>' : 'MARS/6DOF ECEF (Quaternion)/Calculate DCM & Euler Angles/Direction Cosine Matrix  to Quaternions/Validate DCM/If Warning//Error/isNotOrthogonal/transpose*dcm ~= eye(3)'\n * '<S103>' : 'MARS/6DOF ECEF (Quaternion)/Calculate DCM & Euler Angles/Direction Cosine Matrix  to Quaternions/Validate DCM/If Warning//Error/isNotProper/Determinant of 3x3 Matrix'\n * '<S104>' : 'MARS/6DOF ECEF (Quaternion)/Calculate DCM & Euler Angles/Direction Cosine Matrix  to Quaternions/Validate DCM/If Warning//Error/isNotProper/determinant does not equal 1'\n * '<S105>' : 'MARS/6DOF ECEF (Quaternion)/Calculate DCM & Euler Angles/Quaternions to  Direction Cosine Matrix/A11'\n * '<S106>' : 'MARS/6DOF ECEF (Quaternion)/Calculate DCM & Euler Angles/Quaternions to  Direction Cosine Matrix/A12'\n * '<S107>' : 'MARS/6DOF ECEF (Quaternion)/Calculate DCM & Euler Angles/Quaternions to  Direction Cosine Matrix/A13'\n * '<S108>' : 'MARS/6DOF ECEF (Quaternion)/Calculate DCM & Euler Angles/Quaternions to  Direction Cosine Matrix/A21'\n * '<S109>' : 'MARS/6DOF ECEF (Quaternion)/Calculate DCM & Euler Angles/Quaternions to  Direction Cosine Matrix/A22'\n * '<S110>' : 'MARS/6DOF ECEF (Quaternion)/Calculate DCM & Euler Angles/Quaternions to  Direction Cosine Matrix/A23'\n * '<S111>' : 'MARS/6DOF ECEF (Quaternion)/Calculate DCM & Euler Angles/Quaternions to  Direction Cosine Matrix/A31'\n * '<S112>' : 'MARS/6DOF ECEF (Quaternion)/Calculate DCM & Euler Angles/Quaternions to  Direction Cosine Matrix/A32'\n * '<S113>' : 'MARS/6DOF ECEF (Quaternion)/Calculate DCM & Euler Angles/Quaternions to  Direction Cosine Matrix/A33'\n * '<S114>' : 'MARS/6DOF ECEF (Quaternion)/Calculate DCM & Euler Angles/Quaternions to  Direction Cosine Matrix/Create 3x3 Matrix'\n * '<S115>' : 'MARS/6DOF ECEF (Quaternion)/Calculate DCM & Euler Angles/Quaternions to  Direction Cosine Matrix/Quaternion Normalize'\n * '<S116>' : 'MARS/6DOF ECEF (Quaternion)/Calculate DCM & Euler Angles/Quaternions to  Direction Cosine Matrix/Quaternion Normalize/Quaternion Modulus'\n * '<S117>' : 'MARS/6DOF ECEF (Quaternion)/Calculate DCM & Euler Angles/Quaternions to  Direction Cosine Matrix/Quaternion Normalize/Quaternion Modulus/Quaternion Norm'\n * '<S118>' : 'MARS/6DOF ECEF (Quaternion)/Calculate DCM & Euler Angles/Rotation Angles to Direction Cosine Matrix/Create 3x3 Matrix'\n * '<S119>' : 'MARS/6DOF ECEF (Quaternion)/Calculate DCM & Euler Angles/qdot/Quaternion Normalize'\n * '<S120>' : 'MARS/6DOF ECEF (Quaternion)/Calculate DCM & Euler Angles/qdot/Quaternion Normalize/Quaternion Modulus'\n * '<S121>' : 'MARS/6DOF ECEF (Quaternion)/Calculate DCM & Euler Angles/qdot/Quaternion Normalize/Quaternion Modulus/Quaternion Norm'\n * '<S122>' : 'MARS/6DOF ECEF (Quaternion)/Calculate Position in EI /pxwe'\n * '<S123>' : 'MARS/6DOF ECEF (Quaternion)/Calculate Position in EI /pxwe/Subsystem'\n * '<S124>' : 'MARS/6DOF ECEF (Quaternion)/Calculate Position in EI /pxwe/Subsystem1'\n * '<S125>' : 'MARS/6DOF ECEF (Quaternion)/Calculate Velocity in Body Axes/Vbxwb'\n * '<S126>' : 'MARS/6DOF ECEF (Quaternion)/Calculate Velocity in Body Axes/wex(wexp)'\n * '<S127>' : 'MARS/6DOF ECEF (Quaternion)/Calculate Velocity in Body Axes/wexp'\n * '<S128>' : 'MARS/6DOF ECEF (Quaternion)/Calculate Velocity in Body Axes/Vbxwb/Subsystem'\n * '<S129>' : 'MARS/6DOF ECEF (Quaternion)/Calculate Velocity in Body Axes/Vbxwb/Subsystem1'\n * '<S130>' : 'MARS/6DOF ECEF (Quaternion)/Calculate Velocity in Body Axes/wex(wexp)/Subsystem'\n * '<S131>' : 'MARS/6DOF ECEF (Quaternion)/Calculate Velocity in Body Axes/wex(wexp)/Subsystem1'\n * '<S132>' : 'MARS/6DOF ECEF (Quaternion)/Calculate Velocity in Body Axes/wexp/Subsystem'\n * '<S133>' : 'MARS/6DOF ECEF (Quaternion)/Calculate Velocity in Body Axes/wexp/Subsystem1'\n * '<S134>' : 'MARS/6DOF ECEF (Quaternion)/Calculate omega_dot/3x3 Cross Product'\n * '<S135>' : 'MARS/6DOF ECEF (Quaternion)/Calculate omega_dot/I x w'\n * '<S136>' : 'MARS/6DOF ECEF (Quaternion)/Calculate omega_dot/I x w1'\n * '<S137>' : 'MARS/6DOF ECEF (Quaternion)/Calculate omega_dot/3x3 Cross Product/Subsystem'\n * '<S138>' : 'MARS/6DOF ECEF (Quaternion)/Calculate omega_dot/3x3 Cross Product/Subsystem1'\n * '<S139>' : 'MARS/6DOF ECEF (Quaternion)/ECEF to Inertial/Create 3x3 Matrix'\n * '<S140>' : 'MARS/6DOF ECEF (Quaternion)/w_ned/Angle Conversion'\n * '<S141>' : 'MARS/6DOF ECEF (Quaternion)/w_ned/M+h'\n * '<S142>' : 'MARS/6DOF ECEF (Quaternion)/w_ned/N+h'\n * '<S143>' : 'MARS/6DOF ECEF (Quaternion)/w_ned/e2'\n * '<S144>' : 'MARS/FlightGear Preconfigured 6DoF Animation/Angle Conversion'\n * '<S145>' : 'MARS/FlightGear Preconfigured 6DoF Animation/Angle Conversion1'\n */\n#endif                                 /* RTW_HEADER_MARS_h_ */\n"},{"name":"MARS_private.h","type":"header","group":"model","path":"/home/aman/GitHub/flightTestingLab/controls/Ingenuity_Modelling/MATLAB-env/MARS_grt_rtw","tag":"","groupDisplay":"Model files","code":"/*\n * MARS_private.h\n *\n * Academic License - for use in teaching, academic research, and meeting\n * course requirements at degree granting institutions only.  Not for\n * government, commercial, or other organizational use.\n *\n * Code generation for model \"MARS\".\n *\n * Model version              : 1.6\n * Simulink Coder version : 9.7 (R2022a) 13-Nov-2021\n * C++ source code generated on : Thu Oct 20 23:51:39 2022\n *\n * Target selection: grt.tlc\n * Note: GRT includes extra infrastructure and instrumentation for prototyping\n * Embedded hardware selection: Intel->x86-64 (Windows64)\n * Code generation objective: Execution efficiency\n * Validation result: Not run\n */\n\n#ifndef RTW_HEADER_MARS_private_h_\n#define RTW_HEADER_MARS_private_h_\n#include \"rtwtypes.h\"\n#include \"multiword_types.h\"\n\n/* Private macros used by the generated code to access rtModel */\n#ifndef rtmSetFirstInitCond\n#define rtmSetFirstInitCond(rtm, val)  ((rtm)->Timing.firstInitCondFlag = (val))\n#endif\n\n#ifndef rtmIsFirstInitCond\n#define rtmIsFirstInitCond(rtm)        ((rtm)->Timing.firstInitCondFlag)\n#endif\n\n#ifndef rtmIsMajorTimeStep\n#define rtmIsMajorTimeStep(rtm)        (((rtm)->Timing.simTimeStep) == MAJOR_TIME_STEP)\n#endif\n\n#ifndef rtmIsMinorTimeStep\n#define rtmIsMinorTimeStep(rtm)        (((rtm)->Timing.simTimeStep) == MINOR_TIME_STEP)\n#endif\n\n#ifndef rtmSetTPtr\n#define rtmSetTPtr(rtm, val)           ((rtm)->Timing.t = (val))\n#endif\n\nextern real_T rt_atan2d_snf(real_T u0, real_T u1);\nextern real_T rt_modd_snf(real_T u0, real_T u1);\nextern real_T rt_remd_snf(real_T u0, real_T u1);\nextern real_T rt_powd_snf(real_T u0, real_T u1);\nextern void rt_mrdivide_U1d1x3_U2d_9vOrDY9Z(const real_T u0[3], const real_T u1\n  [9], real_T y[3]);\n\n/* private model entry point functions */\nextern void MARS_derivatives();\n\n#endif                                 /* RTW_HEADER_MARS_private_h_ */\n"},{"name":"MARS_types.h","type":"header","group":"model","path":"/home/aman/GitHub/flightTestingLab/controls/Ingenuity_Modelling/MATLAB-env/MARS_grt_rtw","tag":"","groupDisplay":"Model files","code":"/*\n * MARS_types.h\n *\n * Academic License - for use in teaching, academic research, and meeting\n * course requirements at degree granting institutions only.  Not for\n * government, commercial, or other organizational use.\n *\n * Code generation for model \"MARS\".\n *\n * Model version              : 1.6\n * Simulink Coder version : 9.7 (R2022a) 13-Nov-2021\n * C++ source code generated on : Thu Oct 20 23:51:39 2022\n *\n * Target selection: grt.tlc\n * Note: GRT includes extra infrastructure and instrumentation for prototyping\n * Embedded hardware selection: Intel->x86-64 (Windows64)\n * Code generation objective: Execution efficiency\n * Validation result: Not run\n */\n\n#ifndef RTW_HEADER_MARS_types_h_\n#define RTW_HEADER_MARS_types_h_\n\n/* Model Code Variants */\n\n/* Forward declaration for rtModel */\ntypedef struct tag_RTM_MARS_T RT_MODEL_MARS_T;\n\n#endif                                 /* RTW_HEADER_MARS_types_h_ */\n"},{"name":"MARS_data.cpp","type":"source","group":"data","path":"/home/aman/GitHub/flightTestingLab/controls/Ingenuity_Modelling/MATLAB-env/MARS_grt_rtw","tag":"","groupDisplay":"Data files","code":"/*\n * MARS_data.cpp\n *\n * Academic License - for use in teaching, academic research, and meeting\n * course requirements at degree granting institutions only.  Not for\n * government, commercial, or other organizational use.\n *\n * Code generation for model \"MARS\".\n *\n * Model version              : 1.6\n * Simulink Coder version : 9.7 (R2022a) 13-Nov-2021\n * C++ source code generated on : Thu Oct 20 23:51:39 2022\n *\n * Target selection: grt.tlc\n * Note: GRT includes extra infrastructure and instrumentation for prototyping\n * Embedded hardware selection: Intel->x86-64 (Windows64)\n * Code generation objective: Execution efficiency\n * Validation result: Not run\n */\n\n#include \"MARS.h\"\n\n/* Invariant block signals (default storage) */\nconst ConstB_MARS_T MARS_ConstB{\n  {\n    -0.82949238588247243,\n    0.38438233146596967,\n    -0.4052068669455009,\n    0.34537608216871168,\n    0.92317399403188638,\n    0.1687161480386685,\n    0.43892794810628633,\n    0.0,\n    -0.89852226259075252\n  }\n  ,                                    /* '<S4>/Product2' */\n\n  {\n    1.0,\n    0.0,\n    0.0,\n    0.0,\n    1.0,\n    0.0,\n    0.0,\n    0.0,\n    1.0\n  }\n  ,                                    /* '<S7>/Selector' */\n\n  {\n    1.0,\n    0.0,\n    0.0,\n    0.0,\n    1.0,\n    0.0,\n    0.0,\n    0.0,\n    1.0\n  }\n  ,                                    /* '<S7>/Selector2' */\n\n  {\n    3.125,\n    0.0,\n    -5.0\n  }\n  ,                                    /* '<S1>/Product' */\n\n  {\n    1.1102230246251565E-16,\n    1.3877787807814457E-17,\n    0.0,\n    1.3877787807814457E-17,\n    1.1102230246251565E-16,\n    0.0,\n    0.0,\n    0.0,\n    0.0\n  }\n  ,                                    /* '<S96>/Abs2' */\n\n  {\n    0.95540418704665353,\n    0.044147846096478795,\n    -0.22088421489473919\n  }\n  ,                                    /* '<S71>/Product' */\n\n  {\n    0.19095541539610336,\n    0.95540418704665309,\n    -0.22088421489473903\n  }\n  ,                                    /* '<S73>/Product' */\n\n  {\n    0.19095541539610345,\n    0.044147846096478795,\n    -0.22088421489473928\n  }\n  ,                                    /* '<S72>/Product' */\n  -0.84413481505178722\n  ,                                    /* '<S90>/Add' */\n  -0.1687161480386685\n  ,                                    /* '<S91>/Add' */\n  -0.039006249297257989\n  /* '<S92>/Add' */\n};\n\n/* Constant parameters (default storage) */\nconst ConstP_MARS_T MARS_ConstP{\n  /* Pooled Parameter (Expression: -eye(3))\n   * Referenced by:\n   *   '<S58>/Bias1'\n   *   '<S96>/Bias1'\n   */\n  { -1.0, -0.0, -0.0, -0.0, -1.0, -0.0, -0.0, -0.0, -1.0 }\n};\n"},{"name":"multiword_types.h","type":"header","group":"utility","path":"/home/aman/GitHub/flightTestingLab/controls/Ingenuity_Modelling/MATLAB-env/MARS_grt_rtw","tag":"","groupDisplay":"Utility files","code":"/*\n * multiword_types.h\n *\n * Academic License - for use in teaching, academic research, and meeting\n * course requirements at degree granting institutions only.  Not for\n * government, commercial, or other organizational use.\n *\n * Code generation for model \"MARS\".\n *\n * Model version              : 1.6\n * Simulink Coder version : 9.7 (R2022a) 13-Nov-2021\n * C++ source code generated on : Thu Oct 20 23:51:39 2022\n *\n * Target selection: grt.tlc\n * Note: GRT includes extra infrastructure and instrumentation for prototyping\n * Embedded hardware selection: Intel->x86-64 (Windows64)\n * Code generation objective: Execution efficiency\n * Validation result: Not run\n */\n\n#ifndef MULTIWORD_TYPES_H\n#define MULTIWORD_TYPES_H\n#include \"rtwtypes.h\"\n\n/*\n * MultiWord supporting definitions\n */\ntypedef long long longlong_T;\n\n/*\n * MultiWord types\n */\ntypedef struct {\n  uint64_T chunks[2];\n} int128m_T;\n\ntypedef struct {\n  int128m_T re;\n  int128m_T im;\n} cint128m_T;\n\ntypedef struct {\n  uint64_T chunks[2];\n} uint128m_T;\n\ntypedef struct {\n  uint128m_T re;\n  uint128m_T im;\n} cuint128m_T;\n\ntypedef struct {\n  uint64_T chunks[3];\n} int192m_T;\n\ntypedef struct {\n  int192m_T re;\n  int192m_T im;\n} cint192m_T;\n\ntypedef struct {\n  uint64_T chunks[3];\n} uint192m_T;\n\ntypedef struct {\n  uint192m_T re;\n  uint192m_T im;\n} cuint192m_T;\n\ntypedef struct {\n  uint64_T chunks[4];\n} int256m_T;\n\ntypedef struct {\n  int256m_T re;\n  int256m_T im;\n} cint256m_T;\n\ntypedef struct {\n  uint64_T chunks[4];\n} uint256m_T;\n\ntypedef struct {\n  uint256m_T re;\n  uint256m_T im;\n} cuint256m_T;\n\ntypedef struct {\n  uint64_T chunks[5];\n} int320m_T;\n\ntypedef struct {\n  int320m_T re;\n  int320m_T im;\n} cint320m_T;\n\ntypedef struct {\n  uint64_T chunks[5];\n} uint320m_T;\n\ntypedef struct {\n  uint320m_T re;\n  uint320m_T im;\n} cuint320m_T;\n\ntypedef struct {\n  uint64_T chunks[6];\n} int384m_T;\n\ntypedef struct {\n  int384m_T re;\n  int384m_T im;\n} cint384m_T;\n\ntypedef struct {\n  uint64_T chunks[6];\n} uint384m_T;\n\ntypedef struct {\n  uint384m_T re;\n  uint384m_T im;\n} cuint384m_T;\n\ntypedef struct {\n  uint64_T chunks[7];\n} int448m_T;\n\ntypedef struct {\n  int448m_T re;\n  int448m_T im;\n} cint448m_T;\n\ntypedef struct {\n  uint64_T chunks[7];\n} uint448m_T;\n\ntypedef struct {\n  uint448m_T re;\n  uint448m_T im;\n} cuint448m_T;\n\ntypedef struct {\n  uint64_T chunks[8];\n} int512m_T;\n\ntypedef struct {\n  int512m_T re;\n  int512m_T im;\n} cint512m_T;\n\ntypedef struct {\n  uint64_T chunks[8];\n} uint512m_T;\n\ntypedef struct {\n  uint512m_T re;\n  uint512m_T im;\n} cuint512m_T;\n\ntypedef struct {\n  uint64_T chunks[9];\n} int576m_T;\n\ntypedef struct {\n  int576m_T re;\n  int576m_T im;\n} cint576m_T;\n\ntypedef struct {\n  uint64_T chunks[9];\n} uint576m_T;\n\ntypedef struct {\n  uint576m_T re;\n  uint576m_T im;\n} cuint576m_T;\n\ntypedef struct {\n  uint64_T chunks[10];\n} int640m_T;\n\ntypedef struct {\n  int640m_T re;\n  int640m_T im;\n} cint640m_T;\n\ntypedef struct {\n  uint64_T chunks[10];\n} uint640m_T;\n\ntypedef struct {\n  uint640m_T re;\n  uint640m_T im;\n} cuint640m_T;\n\ntypedef struct {\n  uint64_T chunks[11];\n} int704m_T;\n\ntypedef struct {\n  int704m_T re;\n  int704m_T im;\n} cint704m_T;\n\ntypedef struct {\n  uint64_T chunks[11];\n} uint704m_T;\n\ntypedef struct {\n  uint704m_T re;\n  uint704m_T im;\n} cuint704m_T;\n\ntypedef struct {\n  uint64_T chunks[12];\n} int768m_T;\n\ntypedef struct {\n  int768m_T re;\n  int768m_T im;\n} cint768m_T;\n\ntypedef struct {\n  uint64_T chunks[12];\n} uint768m_T;\n\ntypedef struct {\n  uint768m_T re;\n  uint768m_T im;\n} cuint768m_T;\n\ntypedef struct {\n  uint64_T chunks[13];\n} int832m_T;\n\ntypedef struct {\n  int832m_T re;\n  int832m_T im;\n} cint832m_T;\n\ntypedef struct {\n  uint64_T chunks[13];\n} uint832m_T;\n\ntypedef struct {\n  uint832m_T re;\n  uint832m_T im;\n} cuint832m_T;\n\ntypedef struct {\n  uint64_T chunks[14];\n} int896m_T;\n\ntypedef struct {\n  int896m_T re;\n  int896m_T im;\n} cint896m_T;\n\ntypedef struct {\n  uint64_T chunks[14];\n} uint896m_T;\n\ntypedef struct {\n  uint896m_T re;\n  uint896m_T im;\n} cuint896m_T;\n\ntypedef struct {\n  uint64_T chunks[15];\n} int960m_T;\n\ntypedef struct {\n  int960m_T re;\n  int960m_T im;\n} cint960m_T;\n\ntypedef struct {\n  uint64_T chunks[15];\n} uint960m_T;\n\ntypedef struct {\n  uint960m_T re;\n  uint960m_T im;\n} cuint960m_T;\n\ntypedef struct {\n  uint64_T chunks[16];\n} int1024m_T;\n\ntypedef struct {\n  int1024m_T re;\n  int1024m_T im;\n} cint1024m_T;\n\ntypedef struct {\n  uint64_T chunks[16];\n} uint1024m_T;\n\ntypedef struct {\n  uint1024m_T re;\n  uint1024m_T im;\n} cuint1024m_T;\n\ntypedef struct {\n  uint64_T chunks[17];\n} int1088m_T;\n\ntypedef struct {\n  int1088m_T re;\n  int1088m_T im;\n} cint1088m_T;\n\ntypedef struct {\n  uint64_T chunks[17];\n} uint1088m_T;\n\ntypedef struct {\n  uint1088m_T re;\n  uint1088m_T im;\n} cuint1088m_T;\n\ntypedef struct {\n  uint64_T chunks[18];\n} int1152m_T;\n\ntypedef struct {\n  int1152m_T re;\n  int1152m_T im;\n} cint1152m_T;\n\ntypedef struct {\n  uint64_T chunks[18];\n} uint1152m_T;\n\ntypedef struct {\n  uint1152m_T re;\n  uint1152m_T im;\n} cuint1152m_T;\n\ntypedef struct {\n  uint64_T chunks[19];\n} int1216m_T;\n\ntypedef struct {\n  int1216m_T re;\n  int1216m_T im;\n} cint1216m_T;\n\ntypedef struct {\n  uint64_T chunks[19];\n} uint1216m_T;\n\ntypedef struct {\n  uint1216m_T re;\n  uint1216m_T im;\n} cuint1216m_T;\n\ntypedef struct {\n  uint64_T chunks[20];\n} int1280m_T;\n\ntypedef struct {\n  int1280m_T re;\n  int1280m_T im;\n} cint1280m_T;\n\ntypedef struct {\n  uint64_T chunks[20];\n} uint1280m_T;\n\ntypedef struct {\n  uint1280m_T re;\n  uint1280m_T im;\n} cuint1280m_T;\n\ntypedef struct {\n  uint64_T chunks[21];\n} int1344m_T;\n\ntypedef struct {\n  int1344m_T re;\n  int1344m_T im;\n} cint1344m_T;\n\ntypedef struct {\n  uint64_T chunks[21];\n} uint1344m_T;\n\ntypedef struct {\n  uint1344m_T re;\n  uint1344m_T im;\n} cuint1344m_T;\n\ntypedef struct {\n  uint64_T chunks[22];\n} int1408m_T;\n\ntypedef struct {\n  int1408m_T re;\n  int1408m_T im;\n} cint1408m_T;\n\ntypedef struct {\n  uint64_T chunks[22];\n} uint1408m_T;\n\ntypedef struct {\n  uint1408m_T re;\n  uint1408m_T im;\n} cuint1408m_T;\n\ntypedef struct {\n  uint64_T chunks[23];\n} int1472m_T;\n\ntypedef struct {\n  int1472m_T re;\n  int1472m_T im;\n} cint1472m_T;\n\ntypedef struct {\n  uint64_T chunks[23];\n} uint1472m_T;\n\ntypedef struct {\n  uint1472m_T re;\n  uint1472m_T im;\n} cuint1472m_T;\n\ntypedef struct {\n  uint64_T chunks[24];\n} int1536m_T;\n\ntypedef struct {\n  int1536m_T re;\n  int1536m_T im;\n} cint1536m_T;\n\ntypedef struct {\n  uint64_T chunks[24];\n} uint1536m_T;\n\ntypedef struct {\n  uint1536m_T re;\n  uint1536m_T im;\n} cuint1536m_T;\n\ntypedef struct {\n  uint64_T chunks[25];\n} int1600m_T;\n\ntypedef struct {\n  int1600m_T re;\n  int1600m_T im;\n} cint1600m_T;\n\ntypedef struct {\n  uint64_T chunks[25];\n} uint1600m_T;\n\ntypedef struct {\n  uint1600m_T re;\n  uint1600m_T im;\n} cuint1600m_T;\n\ntypedef struct {\n  uint64_T chunks[26];\n} int1664m_T;\n\ntypedef struct {\n  int1664m_T re;\n  int1664m_T im;\n} cint1664m_T;\n\ntypedef struct {\n  uint64_T chunks[26];\n} uint1664m_T;\n\ntypedef struct {\n  uint1664m_T re;\n  uint1664m_T im;\n} cuint1664m_T;\n\ntypedef struct {\n  uint64_T chunks[27];\n} int1728m_T;\n\ntypedef struct {\n  int1728m_T re;\n  int1728m_T im;\n} cint1728m_T;\n\ntypedef struct {\n  uint64_T chunks[27];\n} uint1728m_T;\n\ntypedef struct {\n  uint1728m_T re;\n  uint1728m_T im;\n} cuint1728m_T;\n\ntypedef struct {\n  uint64_T chunks[28];\n} int1792m_T;\n\ntypedef struct {\n  int1792m_T re;\n  int1792m_T im;\n} cint1792m_T;\n\ntypedef struct {\n  uint64_T chunks[28];\n} uint1792m_T;\n\ntypedef struct {\n  uint1792m_T re;\n  uint1792m_T im;\n} cuint1792m_T;\n\ntypedef struct {\n  uint64_T chunks[29];\n} int1856m_T;\n\ntypedef struct {\n  int1856m_T re;\n  int1856m_T im;\n} cint1856m_T;\n\ntypedef struct {\n  uint64_T chunks[29];\n} uint1856m_T;\n\ntypedef struct {\n  uint1856m_T re;\n  uint1856m_T im;\n} cuint1856m_T;\n\ntypedef struct {\n  uint64_T chunks[30];\n} int1920m_T;\n\ntypedef struct {\n  int1920m_T re;\n  int1920m_T im;\n} cint1920m_T;\n\ntypedef struct {\n  uint64_T chunks[30];\n} uint1920m_T;\n\ntypedef struct {\n  uint1920m_T re;\n  uint1920m_T im;\n} cuint1920m_T;\n\ntypedef struct {\n  uint64_T chunks[31];\n} int1984m_T;\n\ntypedef struct {\n  int1984m_T re;\n  int1984m_T im;\n} cint1984m_T;\n\ntypedef struct {\n  uint64_T chunks[31];\n} uint1984m_T;\n\ntypedef struct {\n  uint1984m_T re;\n  uint1984m_T im;\n} cuint1984m_T;\n\ntypedef struct {\n  uint64_T chunks[32];\n} int2048m_T;\n\ntypedef struct {\n  int2048m_T re;\n  int2048m_T im;\n} cint2048m_T;\n\ntypedef struct {\n  uint64_T chunks[32];\n} uint2048m_T;\n\ntypedef struct {\n  uint2048m_T re;\n  uint2048m_T im;\n} cuint2048m_T;\n\n#endif                                 /* MULTIWORD_TYPES_H */\n"},{"name":"rtGetInf.cpp","type":"source","group":"utility","path":"/home/aman/GitHub/flightTestingLab/controls/Ingenuity_Modelling/MATLAB-env/MARS_grt_rtw","tag":"","groupDisplay":"Utility files","code":"/*\n * rtGetInf.cpp\n *\n * Academic License - for use in teaching, academic research, and meeting\n * course requirements at degree granting institutions only.  Not for\n * government, commercial, or other organizational use.\n *\n * Code generation for model \"MARS\".\n *\n * Model version              : 1.6\n * Simulink Coder version : 9.7 (R2022a) 13-Nov-2021\n * C++ source code generated on : Thu Oct 20 23:51:39 2022\n *\n * Target selection: grt.tlc\n * Note: GRT includes extra infrastructure and instrumentation for prototyping\n * Embedded hardware selection: Intel->x86-64 (Windows64)\n * Code generation objective: Execution efficiency\n * Validation result: Not run\n */\n\n#include \"rtwtypes.h\"\n\nextern \"C\" {\n\n#include \"rtGetInf.h\"\n\n}\n#include <stddef.h>\n\nextern \"C\" {\n\n#include \"rt_nonfinite.h\"\n\n}\n#define NumBitsPerChar                 8U\n\nextern \"C\" {\n  /*\n   * Initialize rtInf needed by the generated code.\n   * Inf is initialized as non-signaling. Assumes IEEE.\n   */\n  real_T rtGetInf(void)\n  {\n    size_t bitsPerReal{ sizeof(real_T) * (NumBitsPerChar) };\n\n    real_T inf{ 0.0 };\n\n    if (bitsPerReal == 32U) {\n      inf = rtGetInfF();\n    } else {\n      uint16_T one{ 1U };\n\n      enum {\n        LittleEndian,\n        BigEndian\n      } machByteOrder\n{\n        (*((uint8_T *) &one) == 1U) ? LittleEndian : BigEndian\n      };\n      switch (machByteOrder) {\n       case LittleEndian:\n        {\n          union {\n            LittleEndianIEEEDouble bitVal;\n            real_T fltVal;\n          } tmpVal;\n\n          tmpVal.bitVal.words.wordH = 0x7FF00000U;\n          tmpVal.bitVal.words.wordL = 0x00000000U;\n          inf = tmpVal.fltVal;\n          break;\n        }\n\n       case BigEndian:\n        {\n          union {\n            BigEndianIEEEDouble bitVal;\n            real_T fltVal;\n          } tmpVal;\n\n          tmpVal.bitVal.words.wordH = 0x7FF00000U;\n          tmpVal.bitVal.words.wordL = 0x00000000U;\n          inf = tmpVal.fltVal;\n          break;\n        }\n      }\n    }\n\n    return inf;\n  }\n\n  /*\n   * Initialize rtInfF needed by the generated code.\n   * Inf is initialized as non-signaling. Assumes IEEE.\n   */\n  real32_T rtGetInfF(void)\n  {\n    IEEESingle infF;\n    infF.wordL.wordLuint = 0x7F800000U;\n    return infF.wordL.wordLreal;\n  }\n\n  /*\n   * Initialize rtMinusInf needed by the generated code.\n   * Inf is initialized as non-signaling. Assumes IEEE.\n   */\n  real_T rtGetMinusInf(void)\n  {\n    size_t bitsPerReal{ sizeof(real_T) * (NumBitsPerChar) };\n\n    real_T minf{ 0.0 };\n\n    if (bitsPerReal == 32U) {\n      minf = rtGetMinusInfF();\n    } else {\n      uint16_T one{ 1U };\n\n      enum {\n        LittleEndian,\n        BigEndian\n      } machByteOrder\n{\n        (*((uint8_T *) &one) == 1U) ? LittleEndian : BigEndian\n      };\n      switch (machByteOrder) {\n       case LittleEndian:\n        {\n          union {\n            LittleEndianIEEEDouble bitVal;\n            real_T fltVal;\n          } tmpVal;\n\n          tmpVal.bitVal.words.wordH = 0xFFF00000U;\n          tmpVal.bitVal.words.wordL = 0x00000000U;\n          minf = tmpVal.fltVal;\n          break;\n        }\n\n       case BigEndian:\n        {\n          union {\n            BigEndianIEEEDouble bitVal;\n            real_T fltVal;\n          } tmpVal;\n\n          tmpVal.bitVal.words.wordH = 0xFFF00000U;\n          tmpVal.bitVal.words.wordL = 0x00000000U;\n          minf = tmpVal.fltVal;\n          break;\n        }\n      }\n    }\n\n    return minf;\n  }\n\n  /*\n   * Initialize rtMinusInfF needed by the generated code.\n   * Inf is initialized as non-signaling. Assumes IEEE.\n   */\n  real32_T rtGetMinusInfF(void)\n  {\n    IEEESingle minfF;\n    minfF.wordL.wordLuint = 0xFF800000U;\n    return minfF.wordL.wordLreal;\n  }\n}\n"},{"name":"rtGetInf.h","type":"header","group":"utility","path":"/home/aman/GitHub/flightTestingLab/controls/Ingenuity_Modelling/MATLAB-env/MARS_grt_rtw","tag":"","groupDisplay":"Utility files","code":"/*\n * rtGetInf.h\n *\n * Academic License - for use in teaching, academic research, and meeting\n * course requirements at degree granting institutions only.  Not for\n * government, commercial, or other organizational use.\n *\n * Code generation for model \"MARS\".\n *\n * Model version              : 1.6\n * Simulink Coder version : 9.7 (R2022a) 13-Nov-2021\n * C++ source code generated on : Thu Oct 20 23:51:39 2022\n *\n * Target selection: grt.tlc\n * Note: GRT includes extra infrastructure and instrumentation for prototyping\n * Embedded hardware selection: Intel->x86-64 (Windows64)\n * Code generation objective: Execution efficiency\n * Validation result: Not run\n */\n\n#ifndef RTW_HEADER_rtGetInf_h_\n#define RTW_HEADER_rtGetInf_h_\n#include \"rtwtypes.h\"\n#ifdef __cplusplus\n\nextern \"C\" {\n\n#endif\n\n  extern real_T rtGetInf(void);\n  extern real32_T rtGetInfF(void);\n  extern real_T rtGetMinusInf(void);\n  extern real32_T rtGetMinusInfF(void);\n\n#ifdef __cplusplus\n\n}                                      /* extern \"C\" */\n#endif\n#endif                                 /* RTW_HEADER_rtGetInf_h_ */\n"},{"name":"rtGetNaN.cpp","type":"source","group":"utility","path":"/home/aman/GitHub/flightTestingLab/controls/Ingenuity_Modelling/MATLAB-env/MARS_grt_rtw","tag":"","groupDisplay":"Utility files","code":"/*\n * rtGetNaN.cpp\n *\n * Academic License - for use in teaching, academic research, and meeting\n * course requirements at degree granting institutions only.  Not for\n * government, commercial, or other organizational use.\n *\n * Code generation for model \"MARS\".\n *\n * Model version              : 1.6\n * Simulink Coder version : 9.7 (R2022a) 13-Nov-2021\n * C++ source code generated on : Thu Oct 20 23:51:39 2022\n *\n * Target selection: grt.tlc\n * Note: GRT includes extra infrastructure and instrumentation for prototyping\n * Embedded hardware selection: Intel->x86-64 (Windows64)\n * Code generation objective: Execution efficiency\n * Validation result: Not run\n */\n\n#include \"rtwtypes.h\"\n\nextern \"C\" {\n\n#include \"rtGetNaN.h\"\n\n}\n#include <stddef.h>\n\nextern \"C\" {\n\n#include \"rt_nonfinite.h\"\n\n}\n#define NumBitsPerChar                 8U\n\nextern \"C\" {\n  /*\n   * Initialize rtNaN needed by the generated code.\n   * NaN is initialized as non-signaling. Assumes IEEE.\n   */\n  real_T rtGetNaN(void)\n  {\n    size_t bitsPerReal{ sizeof(real_T) * (NumBitsPerChar) };\n\n    real_T nan{ 0.0 };\n\n    if (bitsPerReal == 32U) {\n      nan = rtGetNaNF();\n    } else {\n      uint16_T one = 1U;\n      enum {\n        LittleEndian,\n        BigEndian\n      } machByteOrder\n{\n        (*((uint8_T *) &one) == 1U) ? LittleEndian : BigEndian\n      };\n      switch (machByteOrder) {\n       case LittleEndian:\n        {\n          union {\n            LittleEndianIEEEDouble bitVal;\n            real_T fltVal;\n          } tmpVal;\n\n          tmpVal.bitVal.words.wordH = 0xFFF80000U;\n          tmpVal.bitVal.words.wordL = 0x00000000U;\n          nan = tmpVal.fltVal;\n          break;\n        }\n\n       case BigEndian:\n        {\n          union {\n            BigEndianIEEEDouble bitVal;\n            real_T fltVal;\n          } tmpVal;\n\n          tmpVal.bitVal.words.wordH = 0x7FFFFFFFU;\n          tmpVal.bitVal.words.wordL = 0xFFFFFFFFU;\n          nan = tmpVal.fltVal;\n          break;\n        }\n      }\n    }\n\n    return nan;\n  }\n\n  /*\n   * Initialize rtNaNF needed by the generated code.\n   * NaN is initialized as non-signaling. Assumes IEEE.\n   */\n  real32_T rtGetNaNF(void)\n  {\n    IEEESingle nanF{ { 0.0F } };\n\n    uint16_T one{ 1U };\n\n    enum {\n      LittleEndian,\n      BigEndian\n    } machByteOrder\n{\n      (*((uint8_T *) &one) == 1U) ? LittleEndian : BigEndian\n    };\n    switch (machByteOrder) {\n     case LittleEndian:\n      {\n        nanF.wordL.wordLuint = 0xFFC00000U;\n        break;\n      }\n\n     case BigEndian:\n      {\n        nanF.wordL.wordLuint = 0x7FFFFFFFU;\n        break;\n      }\n    }\n\n    return nanF.wordL.wordLreal;\n  }\n}\n"},{"name":"rtGetNaN.h","type":"header","group":"utility","path":"/home/aman/GitHub/flightTestingLab/controls/Ingenuity_Modelling/MATLAB-env/MARS_grt_rtw","tag":"","groupDisplay":"Utility files","code":"/*\n * rtGetNaN.h\n *\n * Academic License - for use in teaching, academic research, and meeting\n * course requirements at degree granting institutions only.  Not for\n * government, commercial, or other organizational use.\n *\n * Code generation for model \"MARS\".\n *\n * Model version              : 1.6\n * Simulink Coder version : 9.7 (R2022a) 13-Nov-2021\n * C++ source code generated on : Thu Oct 20 23:51:39 2022\n *\n * Target selection: grt.tlc\n * Note: GRT includes extra infrastructure and instrumentation for prototyping\n * Embedded hardware selection: Intel->x86-64 (Windows64)\n * Code generation objective: Execution efficiency\n * Validation result: Not run\n */\n\n#ifndef RTW_HEADER_rtGetNaN_h_\n#define RTW_HEADER_rtGetNaN_h_\n#include \"rtwtypes.h\"\n#ifdef __cplusplus\n\nextern \"C\" {\n\n#endif\n\n  extern real_T rtGetNaN(void);\n  extern real32_T rtGetNaNF(void);\n\n#ifdef __cplusplus\n\n}                                      /* extern \"C\" */\n#endif\n#endif                                 /* RTW_HEADER_rtGetNaN_h_ */\n"},{"name":"rt_assert.h","type":"header","group":"utility","path":"/home/aman/GitHub/flightTestingLab/controls/Ingenuity_Modelling/MATLAB-env/MARS_grt_rtw","tag":"","groupDisplay":"Utility files","code":"/*\n * rt_assert.h\n *\n * Academic License - for use in teaching, academic research, and meeting\n * course requirements at degree granting institutions only.  Not for\n * government, commercial, or other organizational use.\n *\n * Code generation for model \"MARS\".\n *\n * Model version              : 1.6\n * Simulink Coder version : 9.7 (R2022a) 13-Nov-2021\n * C++ source code generated on : Thu Oct 20 23:51:39 2022\n *\n * Target selection: grt.tlc\n * Note: GRT includes extra infrastructure and instrumentation for prototyping\n * Embedded hardware selection: Intel->x86-64 (Windows64)\n * Code generation objective: Execution efficiency\n * Validation result: Not run\n */\n\n#ifndef RTW_HEADER_rt_assert_h_\n#define RTW_HEADER_rt_assert_h_\n\n/*=========*\n * Asserts *\n *=========*/\n#ifndef utAssert\n#if defined(DOASSERTS)\n#if !defined(PRINT_ASSERTS)\n#include <assert.h>\n#define utAssert(exp)                  assert(exp)\n#else\n#include <stdio.h>\n\nstatic void _assert(char *statement, char *file, int line)\n{\n  printf(\"%s in %s on line %d\\n\", statement, file, line);\n}\n\n#define utAssert(_EX)                  ((_EX) ? (void)0 : _assert(#_EX, __FILE__, __LINE__))\n#endif\n\n#else\n#define utAssert(exp)                                            /* do nothing */\n#endif\n#endif\n#endif                                 /* RTW_HEADER_rt_assert_h_ */\n"},{"name":"rt_defines.h","type":"header","group":"utility","path":"/home/aman/GitHub/flightTestingLab/controls/Ingenuity_Modelling/MATLAB-env/MARS_grt_rtw","tag":"","groupDisplay":"Utility files","code":"/*\n * rt_defines.h\n *\n * Academic License - for use in teaching, academic research, and meeting\n * course requirements at degree granting institutions only.  Not for\n * government, commercial, or other organizational use.\n *\n * Code generation for model \"MARS\".\n *\n * Model version              : 1.6\n * Simulink Coder version : 9.7 (R2022a) 13-Nov-2021\n * C++ source code generated on : Thu Oct 20 23:51:39 2022\n *\n * Target selection: grt.tlc\n * Note: GRT includes extra infrastructure and instrumentation for prototyping\n * Embedded hardware selection: Intel->x86-64 (Windows64)\n * Code generation objective: Execution efficiency\n * Validation result: Not run\n */\n\n#ifndef RTW_HEADER_rt_defines_h_\n#define RTW_HEADER_rt_defines_h_\n\n/*===========*\n * Constants *\n *===========*/\n#define RT_PI                          3.14159265358979323846\n#define RT_PIF                         3.1415927F\n#define RT_LN_10                       2.30258509299404568402\n#define RT_LN_10F                      2.3025851F\n#define RT_LOG10E                      0.43429448190325182765\n#define RT_LOG10EF                     0.43429449F\n#define RT_E                           2.7182818284590452354\n#define RT_EF                          2.7182817F\n\n/*\n * UNUSED_PARAMETER(x)\n *   Used to specify that a function parameter (argument) is required but not\n *   accessed by the function body.\n */\n#ifndef UNUSED_PARAMETER\n#if defined(__LCC__)\n#define UNUSED_PARAMETER(x)                                      /* do nothing */\n#else\n\n/*\n * This is the semi-ANSI standard way of indicating that an\n * unused function parameter is required.\n */\n#define UNUSED_PARAMETER(x)            (void) (x)\n#endif\n#endif\n#endif                                 /* RTW_HEADER_rt_defines_h_ */\n"},{"name":"rt_nonfinite.cpp","type":"source","group":"utility","path":"/home/aman/GitHub/flightTestingLab/controls/Ingenuity_Modelling/MATLAB-env/MARS_grt_rtw","tag":"","groupDisplay":"Utility files","code":"/*\n * rt_nonfinite.cpp\n *\n * Academic License - for use in teaching, academic research, and meeting\n * course requirements at degree granting institutions only.  Not for\n * government, commercial, or other organizational use.\n *\n * Code generation for model \"MARS\".\n *\n * Model version              : 1.6\n * Simulink Coder version : 9.7 (R2022a) 13-Nov-2021\n * C++ source code generated on : Thu Oct 20 23:51:39 2022\n *\n * Target selection: grt.tlc\n * Note: GRT includes extra infrastructure and instrumentation for prototyping\n * Embedded hardware selection: Intel->x86-64 (Windows64)\n * Code generation objective: Execution efficiency\n * Validation result: Not run\n */\n\nextern \"C\" {\n\n#include \"rtGetNaN.h\"\n\n}\n  extern \"C\"\n{\n\n#include \"rtGetInf.h\"\n\n}\n\n#include <stddef.h>\n#include \"rtwtypes.h\"\n\nextern \"C\" {\n\n#include \"rt_nonfinite.h\"\n\n}\n#define NumBitsPerChar                 8U\n\nextern \"C\" {\n  real_T rtInf;\n  real_T rtMinusInf;\n  real_T rtNaN;\n  real32_T rtInfF;\n  real32_T rtMinusInfF;\n  real32_T rtNaNF;\n}\n  extern \"C\"\n{\n  /*\n   * Initialize the rtInf, rtMinusInf, and rtNaN needed by the\n   * generated code. NaN is initialized as non-signaling. Assumes IEEE.\n   */\n  void rt_InitInfAndNaN(size_t realSize)\n  {\n    (void) (realSize);\n    rtNaN = rtGetNaN();\n    rtNaNF = rtGetNaNF();\n    rtInf = rtGetInf();\n    rtInfF = rtGetInfF();\n    rtMinusInf = rtGetMinusInf();\n    rtMinusInfF = rtGetMinusInfF();\n  }\n\n  /* Test if value is infinite */\n  boolean_T rtIsInf(real_T value)\n  {\n    return (boolean_T)((value==rtInf || value==rtMinusInf) ? 1U : 0U);\n  }\n\n  /* Test if single-precision value is infinite */\n  boolean_T rtIsInfF(real32_T value)\n  {\n    return (boolean_T)(((value)==rtInfF || (value)==rtMinusInfF) ? 1U : 0U);\n  }\n\n  /* Test if value is not a number */\n  boolean_T rtIsNaN(real_T value)\n  {\n    boolean_T result{ (boolean_T) 0 };\n\n    size_t bitsPerReal{ sizeof(real_T) * (NumBitsPerChar) };\n\n    if (bitsPerReal == 32U) {\n      result = rtIsNaNF((real32_T)value);\n    } else {\n      union {\n        LittleEndianIEEEDouble bitVal;\n        real_T fltVal;\n      } tmpVal;\n\n      tmpVal.fltVal = value;\n      result = (boolean_T)((tmpVal.bitVal.words.wordH & 0x7FF00000) ==\n                           0x7FF00000 &&\n                           ( (tmpVal.bitVal.words.wordH & 0x000FFFFF) != 0 ||\n                            (tmpVal.bitVal.words.wordL != 0) ));\n    }\n\n    return result;\n  }\n\n  /* Test if single-precision value is not a number */\n  boolean_T rtIsNaNF(real32_T value)\n  {\n    IEEESingle tmp;\n    tmp.wordL.wordLreal = value;\n    return (boolean_T)( (tmp.wordL.wordLuint & 0x7F800000) == 0x7F800000 &&\n                       (tmp.wordL.wordLuint & 0x007FFFFF) != 0 );\n  }\n}\n"},{"name":"rt_nonfinite.h","type":"header","group":"utility","path":"/home/aman/GitHub/flightTestingLab/controls/Ingenuity_Modelling/MATLAB-env/MARS_grt_rtw","tag":"","groupDisplay":"Utility files","code":"/*\n * rt_nonfinite.h\n *\n * Academic License - for use in teaching, academic research, and meeting\n * course requirements at degree granting institutions only.  Not for\n * government, commercial, or other organizational use.\n *\n * Code generation for model \"MARS\".\n *\n * Model version              : 1.6\n * Simulink Coder version : 9.7 (R2022a) 13-Nov-2021\n * C++ source code generated on : Thu Oct 20 23:51:39 2022\n *\n * Target selection: grt.tlc\n * Note: GRT includes extra infrastructure and instrumentation for prototyping\n * Embedded hardware selection: Intel->x86-64 (Windows64)\n * Code generation objective: Execution efficiency\n * Validation result: Not run\n */\n\n#ifndef RTW_HEADER_rt_nonfinite_h_\n#define RTW_HEADER_rt_nonfinite_h_\n#include <stddef.h>\n#include \"rtwtypes.h\"\n#ifdef __cplusplus\n\nextern \"C\" {\n\n#endif\n\n  extern real_T rtInf;\n  extern real_T rtMinusInf;\n  extern real_T rtNaN;\n  extern real32_T rtInfF;\n  extern real32_T rtMinusInfF;\n  extern real32_T rtNaNF;\n  extern void rt_InitInfAndNaN(size_t realSize);\n  extern boolean_T rtIsInf(real_T value);\n  extern boolean_T rtIsInfF(real32_T value);\n  extern boolean_T rtIsNaN(real_T value);\n  extern boolean_T rtIsNaNF(real32_T value);\n  struct BigEndianIEEEDouble {\n    struct {\n      uint32_T wordH;\n      uint32_T wordL;\n    } words;\n  };\n\n  struct LittleEndianIEEEDouble {\n    struct {\n      uint32_T wordL;\n      uint32_T wordH;\n    } words;\n  };\n\n  struct IEEESingle {\n    union {\n      real32_T wordLreal;\n      uint32_T wordLuint;\n    } wordL;\n  };\n\n#ifdef __cplusplus\n\n}                                      /* extern \"C\" */\n#endif\n#endif                                 /* RTW_HEADER_rt_nonfinite_h_ */\n"},{"name":"rtwtypes.h","type":"header","group":"utility","path":"/home/aman/GitHub/flightTestingLab/controls/Ingenuity_Modelling/MATLAB-env/MARS_grt_rtw","tag":"","groupDisplay":"Utility files","code":"/*\n * rtwtypes.h\n *\n * Academic License - for use in teaching, academic research, and meeting\n * course requirements at degree granting institutions only.  Not for\n * government, commercial, or other organizational use.\n *\n * Code generation for model \"MARS\".\n *\n * Model version              : 1.6\n * Simulink Coder version : 9.7 (R2022a) 13-Nov-2021\n * C++ source code generated on : Thu Oct 20 23:51:39 2022\n *\n * Target selection: grt.tlc\n * Note: GRT includes extra infrastructure and instrumentation for prototyping\n * Embedded hardware selection: Intel->x86-64 (Windows64)\n * Code generation objective: Execution efficiency\n * Validation result: Not run\n */\n\n#ifndef RTWTYPES_H\n#define RTWTYPES_H\n#include \"tmwtypes.h\"\n#ifndef POINTER_T\n#define POINTER_T\n\ntypedef void * pointer_T;\n\n#endif\n\n/* Logical type definitions */\n#if (!defined(__cplusplus))\n#ifndef false\n#define false                          (0U)\n#endif\n\n#ifndef true\n#define true                           (1U)\n#endif\n#endif\n\n#ifndef INT64_T\n#define INT64_T\n\ntypedef long long int64_T;\n\n#define MAX_int64_T                    ((int64_T)(9223372036854775807LL))\n#define MIN_int64_T                    ((int64_T)(-9223372036854775807LL-1LL))\n#endif\n\n#ifndef UINT64_T\n#define UINT64_T\n\ntypedef unsigned long long uint64_T;\n\n#define MAX_uint64_T                   ((uint64_T)(0xFFFFFFFFFFFFFFFFULL))\n#endif\n\n/*===========================================================================*\n * Additional complex number type definitions                                           *\n *===========================================================================*/\n#ifndef CINT64_T\n#define CINT64_T\n\ntypedef struct {\n  int64_T re;\n  int64_T im;\n} cint64_T;\n\n#endif\n\n#ifndef CUINT64_T\n#define CUINT64_T\n\ntypedef struct {\n  uint64_T re;\n  uint64_T im;\n} cuint64_T;\n\n#endif\n#endif                                 /* RTWTYPES_H */\n"},{"name":"rtmodel.h","type":"header","group":"interface","path":"/home/aman/GitHub/flightTestingLab/controls/Ingenuity_Modelling/MATLAB-env/MARS_grt_rtw","tag":"","groupDisplay":"Interface files","code":"/*\n *  rtmodel.h:\n *\n * Academic License - for use in teaching, academic research, and meeting\n * course requirements at degree granting institutions only.  Not for\n * government, commercial, or other organizational use.\n *\n * Code generation for model \"MARS\".\n *\n * Model version              : 1.6\n * Simulink Coder version : 9.7 (R2022a) 13-Nov-2021\n * C++ source code generated on : Thu Oct 20 23:51:39 2022\n *\n * Target selection: grt.tlc\n * Note: GRT includes extra infrastructure and instrumentation for prototyping\n * Embedded hardware selection: Intel->x86-64 (Windows64)\n * Code generation objective: Execution efficiency\n * Validation result: Not run\n */\n\n#ifndef RTW_HEADER_rtmodel_h_\n#define RTW_HEADER_rtmodel_h_\n#include \"MARS.h\"\n#define MODEL_CLASSNAME                MARS\n#define MODEL_STEPNAME                 step\n#define GRTINTERFACE                   0\n\n/*\n * ROOT_IO_FORMAT: 0 (Individual arguments)\n * ROOT_IO_FORMAT: 1 (Structure reference)\n * ROOT_IO_FORMAT: 2 (Part of model data structure)\n */\n#define ROOT_IO_FORMAT                 2\n#endif                                 /* RTW_HEADER_rtmodel_h_ */\n"}]};